<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>适配器模式</title>
      <link href="/2018/09/08/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/08/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>适配器模式是做什么的？用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。 </p><h3 id="一、适配器模式概述"><a href="#一、适配器模式概述" class="headerlink" title="一、适配器模式概述"></a>一、适配器模式概述</h3><p>与电源适配器相似，在适配器模式中引入了一个被称为适配器(Adapter)的包装类，而它所包装的对象称为适配者(Adaptee)，即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。</p><p>适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无须修改原来的适配者接口和抽象目标类接口。适配器模式定义如下：</p><p><strong>适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</strong> </p><h3 id="二、对象适配器模式"><a href="#二、对象适配器模式" class="headerlink" title="二、对象适配器模式"></a>二、对象适配器模式</h3><p>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，<strong>在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</strong>在实际开发中，对象适配器的使用频率更高，对象适配器模式结构如图所示： </p><img src="/2018/09/08/适配器模式/1.jpg"><p>在对象适配器模式结构图中包含如下几个角色：</p><ul><li>Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li></ul><ul><li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</li></ul><ul><li>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li></ul><p>下面利用具体代码详细说明适配器模式（例子为对象适配器模式）。</p><pre><code>//目标抽象接口public interface Target {    //这是适配者Adaptee有的方法    public void sampleOperation1();     //这是适配者Adaptee没有的方法    public void sampleOperation2(); }</code></pre><pre><code>//适配者Adaptee类，有目标类所需的sampleOperation1()方法public class Adaptee {    public void sampleOperation1(){}}</code></pre><pre><code>//适配器Adapter类，实现目标接口public class Adapter implements Target {    private Adaptee adaptee;    public Adapter(Adaptee adaptee) {        this.adaptee = adaptee;    }    /**     * 适配者Adaptee有方法sampleOperation1     * 因此适配器类直接委派即可     */    public void sampleOperation1(){        this.adaptee.sampleOperation1();    }    /**     * 适配者Adaptee没有方法sampleOperation2     * 因此由适配器类需要补充此方法     */    public void sampleOperation2(){        //写相关的代码    }}</code></pre><p>如果你理解了这个例子，这还有一个例子也解释了适配器模式<a href="http://www.runoob.com/design-pattern/adapter-pattern.html" target="_blank" rel="noopener">适配器模式|菜鸟教程</a>，比我上面的稍微复杂了一点，大家尽量理解。</p><h3 id="三、类适配器模式"><a href="#三、类适配器模式" class="headerlink" title="三、类适配器模式"></a>三、类适配器模式</h3><p>除了对象适配器模式之外，适配器模式还有一种形式，那就是类适配器模式，<strong>类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系</strong>，类适配器模式结构如图所示： </p><img src="/2018/09/08/适配器模式/2.jpg"><p>根据类适配器模式结构图，适配器类实现了抽象目标类接口Target，并继承了适配者类，在适配器类的request()方法中调用所继承的适配者类的specificRequest()方法，实现了适配。典型的类适配器代码如下所示：</p><pre><code>class Adapter extends Adaptee implements Target {      public void request() {          specificRequest();      }  }  </code></pre><p>由于Java、C#等语言不支持多重类继承，因此类适配器的使用受到很多限制，例如如果目标抽象类Target不是接口，而是一个类，就无法使用类适配器；此外，如果适配者Adapter为最终(Final)类，也无法使用类适配器。在Java等面向对象编程语言中，大部分情况下我们使用的是对象适配器，类适配器较少使用。 </p><h3 id="四、双向适配器模式"><a href="#四、双向适配器模式" class="headerlink" title="四、双向适配器模式"></a>四、双向适配器模式</h3><p>在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器，其结构示意图如图所示： </p><img src="/2018/09/08/适配器模式/3.jpg"><p>双向适配器的实现较为复杂，其典型代码如下所示： </p><pre><code>class Adapter implements Target,Adaptee {      //同时维持对抽象目标类和适配者的引用      private Target target;      private Adaptee adaptee;      public Adapter(Target target) {          this.target = target;      }      public Adapter(Adaptee adaptee) {          this.adaptee = adaptee;      }      public void request() {          adaptee.specificRequest();      }      public void specificRequest() {          target.request();      }  }  </code></pre><p>在实际开发中，我们很少使用双向适配器。 </p><h3 id="五、缺省适配器模式"><a href="#五、缺省适配器模式" class="headerlink" title="五、缺省适配器模式"></a>五、缺省适配器模式</h3><img src="/2018/09/08/适配器模式/4.jpg"><p>缺省适配器模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。当原接口中定义的方法太多，而其中大部分又不被需要时，这种模式非常实用。<strong>由缺省适配器类直接实现目标角色接口，并为所有方法提供缺省的空实现。用户类就只需要继承适配器类，只实现感兴趣的方法就行了。</strong> 作为适配器模式的一个特例，缺省适配器模式在JAVA语言中有着特殊的应用。 </p><p>以下是实例代码</p><pre><code>//目标接口，部分方法我们需要public interface SubjectTarget {    void learnChinese();    void learnEnglish();    void learnMath();    void learnBiological();}</code></pre><pre><code>//缺省适配器，为目标接口实现空方法public abstract class SubjectAdapter implements SubjectTarget {    @Override    public void learnChinese() {    }    @Override    public void learnEnglish() {    }    @Override    public void learnMath() {    }    @Override    public void learnBiological() {    }}</code></pre><pre><code>//用户类public class StudentA extends SubjectAdapter {    @Override    public void learnMath() {        super.learnMath();        System.out.println(&quot;just learn Math&quot;);    }}public class StudentB extends SubjectAdapter {    @Override    public void learnChinese() {        super.learnChinese();        System.out.println(&quot;just lear Chinese&quot;);    }}</code></pre><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。</p><p>(1)主要优点</p><p>无论是对象适配器模式还是类适配器模式都具有如下优点：</p><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li></ul><ul><li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li></ul><ul><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><p>具体来说，类适配器模式还有如下优点：</p><p>由于适配器类是适配者类的子类，因此<strong>可以在适配器类中置换一些适配者的方法</strong>，使得适配器的灵活性更强。</p><p>对象适配器模式还有如下优点：</p><ul><li>一个对象适配器<strong>可以把多个不同的适配者适配到同一个目标</strong>；</li></ul><ul><li><strong>可以适配一个适配者的子类</strong>，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li></ul><p>(2)主要缺点</p><p><strong>类适配器模式</strong>的缺点如下：</p><ul><li>对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，<strong>不能同时适配多个适配者</strong>；</li></ul><ul><li><strong>适配者类不能为最终类</strong>，如在Java中不能为final类，C#中不能为sealed类；</li></ul><ul><li>在Java、C#等语言中，<strong>类适配器模式中的目标抽象类只能为接口，不能为类</strong>，其使用有一定的局限性。</li></ul><p><strong>对象适配器模式</strong>的缺点如下：</p><p>​与类适配器模式相比，<strong>要在适配器中置换适配者类的某些方法比较麻烦。</strong>如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p><p>(3)适用场景</p><p>在以下情况下可以考虑使用适配器模式：</p><ul><li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li></ul><ul><li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring AOP总结</title>
      <link href="/2018/09/02/Spring%20AOP%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/02/Spring%20AOP%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>关于Spring AOP，我在准备这篇博文的时候发现了一篇讲得非常全面的帖子<a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">关于 Spring AOP (AspectJ) 你该知晓的一切</a>，相信大家好好读完肯定会对Spring AOP有所领悟。基于这篇帖子实在是写得太优秀，所以我这篇博文对Spring AOP也不再解释什么，主要就是自己记下易忘的知识点。 </p><p>静态代理是编译阶段生成AOP代理类，也就是说生成的字节码就织入了增强后的AOP对象；动态代理则不会修改字节码，而是在内存中临时生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。 </p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。 如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的，诸如private的方法也是不可以作为切面的。</p><h3 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、<strong>静态代理</strong></h3><p>由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。 </p><pre><code>public interface PersonDao {    void savePerson();}</code></pre><pre><code>public class PersonDaoImpl implements PersonDao {    @Override    public void savePerson() {        System.out.println(&quot;save person&quot;);    }}</code></pre><pre><code>public class Transaction {    void beginTransaction() {        System.out.println(&quot;begin Transaction&quot;);    }    void commit() {        System.out.println(&quot;commit&quot;);    }}</code></pre><p>接下来编写静态代理类—实现PersonDao接口 </p><pre><code>/** * 静态代理类 */public class PersonDaoProxy implements PersonDao{    PersonDao personDao;    Transaction transaction;    public PersonDaoProxy(PersonDao personDao, Transaction transaction) {        this.personDao = personDao;        this.transaction = transaction;    }    @Override    public void savePerson() {        this.transaction.beginTransaction();        this.personDao.savePerson();        this.transaction.commit();    }}</code></pre><pre><code>/** * 测试静态代理 */public class TestPersonProxy {    @Test    public void testSave(){        PersonDao personDao = new PersonDaoImpl();        Transaction transaction = new Transaction();        PersonDaoProxy proxy = new PersonDaoProxy(personDao, transaction);        proxy.savePerson();    }}</code></pre><p>总结：</p><p>(1)静态代理模式并没有做到事务的重用。</p><p>(2)假设dao有100个类，100个proxy，接口中有多少方法，在proxy层就得实现多少方法，有多少方法就要开启和提交多少事务。</p><p>(3)如果一个proxy实现了多个接口，如果其中的一个接口发生变化（添加了一个方法），那么proxy也要做相应改变。</p><h3 id="二、JDK动态代理"><a href="#二、JDK动态代理" class="headerlink" title="二、JDK动态代理"></a>二、JDK动态代理</h3><p>动态代理类：在程序运行时，运用反射机制动态创建而成。</p><p>JDK的动态代理必须具备四个条件：1、目标接口 2、目标类 3、拦截器 4、代理类</p><p>使用上个例子的PersonDao接口、PersonDaoImpl类及Transaction类</p><p>编写拦截器</p><pre><code>import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * 拦截器  *         1、目标类导入进来  *         2、事物导入进来  *         3、invoke完成：开启事务、调用目标对象的方法、事务提交 */public class Interceptor implements InvocationHandler {    private Object target; // 目标类    private Transaction transaction;    public Interceptor(Object target, Transaction transaction) {        this.target = target;        this.transaction = transaction;    }    /**     * @param proxy 目标对象的代理类实例     * @param method 对应于在代理实例上调用接口方法的Method实例     * @param args 传入到代理实例上方法参数值的对象数组     * @return 方法的返回值，没有返回值是null     * @throws Throwable     */    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        String methodName = method.getName();        if (&quot;savePerson&quot;.equals(methodName) || &quot;deletePerson&quot;.equals(methodName) || &quot;updatePerson&quot;.equals(methodName)) {            this.transaction.beginTransaction(); // 开启事务            method.invoke(target); // 调用目标方法            this.transaction.commit(); // 提交事务        } else {            method.invoke(target);        }        return null;    }}</code></pre><p>测试 </p><pre><code>/** * 测试jdk动态代理 */public class TestJDKProxy {    @Test    public void testSave(){        /**         * 1、创建一个目标对象         * 2、创建一个事务         * 3、创建一个拦截器         * 4、动态产生一个代理对象         */        Object target = new PersonDaoImpl();        Transaction transaction = new Transaction();        Interceptor interceptor = new Interceptor(target, transaction);        /**         * 参数一：设置代码使用的类加载器，一般采用跟目标类相同的类加载器         * 参数二：设置代理类实现的接口，跟目标类使用相同的接口         * 参数三：设置回调对象，当代理对象的方法被调用时，会调用该参数指定对象的invoke方法         */        PersonDao personDao = (PersonDao) Proxy.newProxyInstance(                target.getClass().getClassLoader(),                target.getClass().getInterfaces(),                interceptor);        personDao.savePerson();    }}</code></pre><p>总结：</p><p>(1)因为利用JDKProxy生成的代理类实现了接口，所以目标类中所有的方法在代理类中都有。</p><p>(2)生成的代理类的所有的方法都拦截了目标类的所有的方法。而拦截器中invoke方法的内容正好就是代理类的各个方法的组成体。</p><p>(3)利用JDKProxy方式必须有接口的存在。</p><p>(4)invoke方法中的三个参数可以访问目标类的被调用方法的API、被调用方法的参数、被调用方法的返回类型。</p><p>缺点：</p><p>(1)在拦截器中除了能调用目标对象的目标方法以外，功能是比较单一的，在这个例子中只能处理事务。<br>(2)拦截器中的invoke方法的if判断语句在真实的开发环境下是不靠谱的，因为一旦方法很多if语句需要写很多。</p><h3 id="三、CGLIB动态代理"><a href="#三、CGLIB动态代理" class="headerlink" title="三、CGLIB动态代理"></a>三、CGLIB动态代理</h3><p>使用上个例子的PersonDaoImpl类和Transaction类（不用接口）</p><p>编写拦截器类</p><pre><code>import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * CGLIB代理 拦截器  */public class Interceptor  implements MethodInterceptor {    private Object target; // 代理的目标类    private Transaction transaction;    public Interceptor(Object target, Transaction transaction) {        this.target = target;        this.transaction = transaction;    }    /**     * 创建目标对象的代理对象     *      * @return     */    public Object createProxy() {        // 代码增强        Enhancer enhancer = new Enhancer(); // 该类用于生成代理对象        enhancer.setCallback(this); // 参数为拦截器        enhancer.setSuperclass(target.getClass());// 设置父类        return enhancer.create(); // 创建代理对象    }    /**     * @param obj 目标对象代理类的实例     * @param method 代理实例上 调用父类方法的Method实例     * @param args 传入到代理实例上方法参数值的对象数组     * @param methodProxy 使用它调用父类的方法     * @return     * @throws Throwable     */    public Object intercept(Object obj, Method method, Object[] args,            MethodProxy methodProxy) throws Throwable {        this.transaction.beginTransaction();        method.invoke(target);        this.transaction.commit();        return null;    }}</code></pre><p>测试 </p><pre><code>/** * 测试cglib动态代理 * 通过cglib产生的代理对象，代理类是目标类的子类 */public class TestCglibProxy {    @Test    public void testSave(){        Object target = new PersonDaoImpl();        Transaction transaction = new Transaction();        Interceptor interceptor = new Interceptor(target, transaction);        PersonDaoImpl personDaoImpl = (PersonDaoImpl) interceptor.createProxy();        personDaoImpl.savePerson();    }}</code></pre><p>总结：</p><p>(1)CGLIB是一个强大的,高性能,高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。</p><p>(2)用CGLIB生成代理类是目标类的子类。</p><p>(3)用CGLIB生成 代理类不需要接口。</p><p>(4)用CGLIB生成的代理类重写了父类的各个方法。</p><p>(5)拦截器中的intercept方法内容正好就是代理类中的方法体。</p><h3 id="四、CGLIB和JDK动态代理区别"><a href="#四、CGLIB和JDK动态代理区别" class="headerlink" title="四、CGLIB和JDK动态代理区别"></a>四、CGLIB和JDK动态代理区别</h3><p>JDK:</p><p>(1)目标类和代理类实现了共同的接口。</p><p>(2)拦截器必须实现InvocationHandler接口，而这个接口中invoke方法体的内容就是代理对象方法体的内容。</p><p>CGLIB:</p><p>(1)目标类是代理类的父类。</p><p>(2)拦截器必须实现MethodInterceptor接口，而接口中的intercept方法就是代理类的方法体，使用字节码增强机制创建代理对象的。</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>建造者模式</title>
      <link href="/2018/08/23/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/23/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>今天更下创建性模式的最后一种，也是不那么常见但难度较高的一种设计模式–建造者模式。这篇更完这个暑假大概就不更了，还剩一周多时间我打算放松放松，再完成下学校的作业。拾掇拾掇准备开学，下篇更Spring AOP。废话不说，开始吧。</p><p>没有人买车会只买一个轮胎或者方向盘，大家买的都是一辆包含轮胎、方向盘和发动机等多个部件的完整汽车。如何将这些部件组装成一辆完整的汽车并返回给用户，这是建造者模式需要解决的问题。建造者模式又称为生成器模式，它是一种较为复杂、使用频率也相对较低的创建型模式。建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。</p><h3 id="一、建造者模式概述"><a href="#一、建造者模式概述" class="headerlink" title="一、建造者模式概述"></a>一、建造者模式概述</h3><p>建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。</p><p><strong>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</strong> </p><p> 建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式结构如图所示： </p><img src="/2018/08/23/建造者模式/建造者模式.png"><p>在建造者模式结构图中包含如下几个角色：</p><ul><li><p>Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p></li><li><p>ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</p></li><li><p>Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</p></li><li><p>Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</p></li></ul><p>在建造者模式的定义中提到了复杂对象，那么什么是复杂对象？简单来说，复杂对象是指那些包含多个成员属性的对象，这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件，一个典型的复杂对象类代码示例如下：</p><pre><code>class Product {       private String partA; //定义部件，部件可以是任意类型，包括值类型和引用类型       private String partB;       private String partC;       //partA的Getter方法和Setter方法省略       //partB的Getter方法和Setter方法省略       //partC的Getter方法和Setter方法省略}</code></pre><p>在抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下： </p><pre><code>abstract class Builder {    //创建产品对象    protected Product product = new Product();    public abstract void buildPartA();    public abstract void buildPartB();    public abstract void buildPartC();    //返回产品对象    public Product getResult() {        return product;    }}</code></pre><p>在抽象类Builder中声明了一系列抽象的buildPartX()方法用于创建复杂产品的各个部件，具体建造过程在ConcreteBuilder中实现，此外还提供了工厂方法getResult()，用于返回一个建造好的完整产品。</p><p>在ConcreteBuilder中实现了buildPartX()方法，通过调用Product的setPartX()方法可以给产品对象的成员属性设值。不同的具体建造者在实现buildPartX()方法时将有所区别，如setPartX()方法的参数可能不一样，在有些具体建造者类中某些setPartX()方法无须实现（提供一个空实现）。而这些对于客户端来说都无须关心，客户端只需知道具体建造者类型即可。</p><pre><code>public class ConcreteBuilder extends Builder {    /**     * 产品零件建造方法A     */    @Override    public void buildPartA() {        //构建产品的第一个零件 　　　　product.setPartA(&quot;编号：0001&quot;);    }    /**     * 产品零件建造方法B     */    @Override    public void buildPartB() {        //构建产品的第二个零件 　　　　product.setPartB(&quot;名称：firstTool&quot;);    }    /**     * 产品零件建造方法C     */    @Override    public void buildPartC() {        //构建产品的第三个零件 　　　　product.setPartC(&quot;日期：20180823&quot;);    }    /**     * 产品返还方法     */    public Product getResult() {        return product;    }}</code></pre><p>在建造者模式的结构中还引入了一个指挥者类Director，该类主要有两个作用：一方面它隔离了客户与创建过程；另一方面它控制产品的创建过程，包括某个buildPartX()方法是否被调用以及多个buildPartX()方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。在实际生活中也存在类似指挥者一样的角色，如一个客户去购买电脑，电脑销售人员相当于指挥者，只要客户确定电脑的类型，电脑销售人员可以通知电脑组装人员给客户组装一台电脑。指挥者类的代码示例如下：</p><pre><code>class Director {    private Builder builder;    public Director(Builder builder) {        this.builder = builder;    }    public void setBuilder(Builder builder) {        this.builder = builer;    }    //产品构建与组装方法    public Product construct() {        builder.buildPartA();        builder.buildPartB();         builder.buildPartC();         return builder.getResult();    }}</code></pre><p>客户端类Client</p><pre><code>public class Client {    public static void main(String []args) {        Builder builder = new ConcreteBuilder();        Director director = new Director(builder);        Product product = director.construct();        System.out.println(product.getPartA());        System.out.println(product.getPartB());        System.out.println(product.getPartC());    }}</code></pre><p>客户端负责创建导演者和具体建造者对象。然后，客户端把具体建造者对象交给导演者，导演者操作具体建造者，开始创建产品。当产品完成后，建造者把产品返还给客户端。把创建具体建造者对象的任务交给客户端而不是导演者对象，是为了将导演者对象与具体建造者对象的耦合变成动态的，从而使导演者对象可以操纵数个具体建造者对象中的任何一个。</p><p>建造者模式分成两个很重要的部分：</p><ul><li><p>一个部分是Builder接口，这里是定义了如何构建各个部件，也就是知道每个部件功能如何实现，以及如何装配这些部件到产品中去；</p></li><li><p>另外一个部分是Director，Director是知道如何组合来构建产品，也就是说Director负责整体的构建算法，而且通常是分步骤地来执行。</p></li></ul><p>不管如何变化，<strong>建造者模式都存在这么两个部分，一个部分是部件构造和产品装配，另一个部分是整体构建的算法</strong>。认识这点是很重要的，因为在建造者模式中，强调的是固定整体构建的算法，而灵活扩展和切换部件的具体构造和产品装配的方式。</p><p>再直白点说，建造者模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用。具体的构造实现可以很方便地扩展和切换，从而可以灵活地组合来构造出不同的产品对象。</p><h3 id="二、建造者模式总结"><a href="#二、建造者模式总结" class="headerlink" title="二、建造者模式总结"></a>二、建造者模式总结</h3><p>建造者模式的核心在于如何一步步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品，在软件开发中，如果我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式。</p><h5 id="1-主要优点"><a href="#1-主要优点" class="headerlink" title="1.主要优点"></a>1.主要优点</h5><p>建造者模式的主要优点如下：</p><p>(1)在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><p>(2)每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”。</p><p>(3)可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p><h5 id="2-主要缺点"><a href="#2-主要缺点" class="headerlink" title="2.主要缺点"></a>2.主要缺点</h5><p>建造者模式的主要缺点如下：</p><p>(1)建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p>(2)如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</p><h5 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h5><p>在以下情况下可以考虑使用建造者模式：</p><p>(1)需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</p><p>(2)需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</p><p>(3)对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</p><p>(4)隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原型模式</title>
      <link href="/2018/08/20/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/20/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>在开发过程中，有时会遇到为一个类创建多个实例的情况，这些实例内部成员往往完全相同或有细微的差异，而且实例的创建开销比较大或者需要输入较多参数，如果能通过复制一个已创建的对象实例来重复创建多个相同的对象，这就可以大大减少创建对象的开销，这个时候就需要原型模式。 </p><h3 id="一、原型模式概述"><a href="#一、原型模式概述" class="headerlink" title="一、原型模式概述"></a>一、原型模式概述</h3><p>在使用原型模式时，我们需要首先创建一个原型对象，再通过复制这个原型对象来创建更多同类型的对象。原型模式的定义如下：</p><p><strong>原型模式(Prototype  Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</strong> </p><p>原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p><p>需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p><p>原型模式的结构如图所示： </p><img src="/2018/08/20/原型模式/原型模式.png"><p>在原型模式结构图中包含如下几个角色：</p><p>Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</p><p>ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p><p>Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</p><p>原型模式的核心在于如何实现克隆方法，下面将介绍两种在Java语言中常用的克隆实现方法：</p><h5 id="1-通用实现方法"><a href="#1-通用实现方法" class="headerlink" title="1.通用实现方法"></a>1.通用实现方法</h5><p>通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传入新创建的对象中，保证它们的成员属性相同。示意代码如下所示： </p><pre><code>//接口Prototype不写了，它声明了个clone()方法class ConcretePrototype implements Prototype {    private String attr; //成员属性    public void setAttr(String attr) {        this.attr = attr;    }    public String  getAttr() {        return this.attr;    }    //实现父接口Prototype方法    public Prototype clone() {        Prototype prototype = new ConcretePrototype(); //创建新对象        prototype.setAttr(this.attr);        return prototype;    }}</code></pre><p>在客户类中我们只需要创建一个ConcretePrototype对象作为原型对象，然后调用其clone()方法即可得到对应的克隆对象，如下代码所示： </p><pre><code>Prototype obj1 = new ConcretePrototype();obj1.setAttr(&quot;Sunny&quot;);Prototype obj2 = obj1.clone();</code></pre><p>这种方法可作为原型模式的通用实现，它与编程语言特性无关，任何面向对象语言都可以使用这种形式来实现对原型的克隆。 </p><h5 id="2-Java语言提供的clone-方法"><a href="#2-Java语言提供的clone-方法" class="headerlink" title="2.Java语言提供的clone()方法"></a>2.Java语言提供的clone()方法</h5><p>学过Java语言的人都知道，所有的Java类都继承自java.lang.Object。事实上，Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。</p><p>需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。如下代码所示：</p><pre><code>class ConcretePrototype implements Cloneable {    ……    public Prototype clone() {        Object object = null;        try {            object = super.clone();        } catch (CloneNotSupportedException exception) {            System.err.println(&quot;Not support cloneable&quot;);        }        return (Prototype)object;        }    ……}</code></pre><p> 在客户端创建原型对象和克隆对象也很简单，如下代码所示： </p><pre><code>Prototype obj1 = new ConcretePrototype();Prototype obj2 = obj1.clone();</code></pre><p>一般而言，Java语言中的clone()方法满足：</p><p>(1)对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；</p><p>(2)对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；</p><p>(3)如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</p><p>为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：</p><p>(1)在派生类中覆盖基类的clone()方法，并声明为public；</p><p>(2)在派生类的clone()方法中，调用super.clone()；</p><p>(3)派生类需实现Cloneable接口。</p><p>此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</p><h3 id="二、浅克隆和深克隆"><a href="#二、浅克隆和深克隆" class="headerlink" title="二、浅克隆和深克隆"></a>二、浅克隆和深克隆</h3><p>浅克隆和深克隆，在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制，下面将对两者进行详细介绍。 </p><h5 id="1-浅克隆"><a href="#1-浅克隆" class="headerlink" title="1.浅克隆"></a>1.浅克隆</h5><p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p><img src="/2018/08/20/原型模式/浅克隆.png"><p><strong>在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆</strong>，即上述的第二种方法，下面举例</p><pre><code>//普通Author类public class Author {    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><pre><code>//Book类实现Cloneable接口class Book implements Cloneable {    private String title;    //Author类成员变量    private Author author;    public Book clone() {        Book book = null;        try {            book = (Book)super.clone();        } catch (CloneNotSupportedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        return book;    }    public String getTitle() {        return title;    }    public void setTitle(String title) {        this.title = title;    }    public Author getAuthor() {        return author;    }    public void setAuthor(Author author) {        this.author = author;    }}</code></pre><pre><code>//测试类public class PrototypeTest {    public static void main(String[] args) {        Book book1 = new Book();        Author author = new Author();        author.setName(&quot;stormjie&quot;);        book1.setAuthor(author);        book1.setTitle(&quot;stormjie&#39;s blog&quot;);        Book book2 = book1.clone();        System.out.println(book1 == book2);  // false        System.out.println(book1.getTitle() == book2.getTitle());  // true        System.out.println(book1.getAuthor() == book2.getAuthor());  // true                    }}</code></pre><p>由输出的结果可以验证说到的结论。由此我们发现：虽然克隆出来的对象重新在堆上开辟了内存空间，但是，对象中各属性确保持相等。对于基本数据类型很好理解，但对于引用数据类型来说，则意味着此引用类型的属性所指向的对象本身是相同的， 并没有重新开辟内存空间存储。换句话说，引用类型的属性所指向的对象并没有克隆。<br>由此，我们将其称之为浅克隆。当克隆后的对象的引用类型的属性所指向的对象也重新得以克隆，此时，称之为深克隆。</p><h5 id="2-深克隆"><a href="#2-深克隆" class="headerlink" title="2.深克隆"></a>2.深克隆</h5><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p><img src="/2018/08/20/原型模式/深克隆.png"><p>在Java语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。 下面我们使用深克隆技术来实现上述Book对象和Author对象的复制，由于要将Book对象和Author对象都写入流中，因此两个类均需要实现Serializable接口。</p><pre><code>class Author implements Serializable{    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><pre><code>class Book implements Serializable {    private String title;    private Author author;    public Book deepClone() throws IOException,ClassNotFoundException {        // 写入当前对象的二进制流         ByteArrayOutputStream bos = new ByteArrayOutputStream();          ObjectOutputStream oos = new ObjectOutputStream(bos);          oos.writeObject(this);        // 读出二进制流产生的新对象          ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());          ObjectInputStream ois = new ObjectInputStream(bis);          return (Book)ois.readObject();    }    public String getTitle() {        return title;    }    public void setTitle(String title) {        this.title = title;    }    public Author getAuthor() {        return author;    }    public void setAuthor(Author author) {        this.author = author;    }}</code></pre><pre><code>//测试类public class PrototypeTest {    public static void main(String[] args) throws ClassNotFoundException,IOException {        Book book1 = new Book();        Author author = new Author();        author.setName(&quot;stormjie&quot;);        book1.setAuthor(author);        book1.setTitle(&quot;stormjie&#39;s blog&quot;);        Book book2 = book1.deepClone();        System.out.println(book1 == book2);  // false        System.out.println(book1.getTitle() == book2.getTitle());  // true        System.out.println(book1.getAuthor() == book2.getAuthor());  // false        }}</code></pre><p>从输出结果中可以看出，深克隆不仅在堆内存上开辟了空间以存储克隆出的对象，甚至连对象中的引用类型的属性所指向的对象也得以克隆，重新开辟了堆空间存储。深克隆技术实现了原型对象和克隆对象的完全独立，对任意克隆对象的修改都不会给其他对象产生影响，是一种更为理想的克隆实现方式。 </p><p>扩展：Java语言提供的Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。</p><h3 id="三、原型模式总结"><a href="#三、原型模式总结" class="headerlink" title="三、原型模式总结"></a>三、原型模式总结</h3><p>原型模式的优点：</p><p>(1)当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</p><p>(2)扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</p><p>(3)原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</p><p>(4)可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p><p>原型模式的缺点：</p><p>(1)需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p><p>(2)在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</p><p>参考资料：《设计模式的艺术软件开发人员内功修炼之道》</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring的Bean与IoC实现</title>
      <link href="/2018/08/18/Spring%E7%9A%84Bean%E4%B8%8EIoC%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/18/Spring%E7%9A%84Bean%E4%B8%8EIoC%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="一、传统JavaBean与Spring的Bean的区别"><a href="#一、传统JavaBean与Spring的Bean的区别" class="headerlink" title="一、传统JavaBean与Spring的Bean的区别"></a>一、传统JavaBean与Spring的Bean的区别</h3><p>JavaBean现在很少人使用，Spring的Bean可以说是JavaBean的发展，但已经完全不是一样了。</p><p>规范：Spring容器对Bean 没有特殊要求，不像JavaBean 一样遵循一些规范（为每个属性提供相应的setter 和 getter 方法），不过对于设值注入的Bean，一定要提供setter 方法。</p><p>作用：Spring中的Bean是Java 实例、Java组件，它的作用几乎无所不包，任何应用组件都被称为Bean，而传统的Java应用中的JavaBean通常作为DTO（数据传输对象），来封装值对象，在各层之间传递数据。</p><p>生命周期：传统的JavaBean作为值对象传递，不接受任何容器管理其生命周期，Spring中的Bean有Spring管理其生命周期行为。</p><h3 id="二、Bean的实例化"><a href="#二、Bean的实例化" class="headerlink" title="二、Bean的实例化"></a>二、Bean的实例化</h3><p>在Spring中实例化Bean有三种方式，分别为构造器实例化、静态工厂方式实例化和实例工厂方式实例化，其中最常用的是<strong>构造器实例化</strong>，下面我就对构造器实例化做详解。</p><p>首先写一个普通的Bean，我们不写它的构造函数，使用它默认的无参构造函数</p><pre><code>package com.spring.demo;public class myBean {    public void print(){        System.out.println(&quot;myBean......&quot;);    }}</code></pre><p>接着在相同目录下配置Bean的xml文件bean.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 关键部分 --&gt;    &lt;bean id=&quot;bean1&quot; class=&quot;com.spring.demo.myBean&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>&lt;bean id = “bean1” class=”com.spring.demo.myBean”&gt;&lt;/bean&gt;：</p><p>id为在xml文件里的这个bean的标识，class为xml文件里的这个bean绑定的Java类(bean)的全路径(包名+类名)。</p><p>这个标签会自动寻找myBean类中的无参数构造函数来创建对象。</p><p>最后我们测试一下，在相同目录下编写一个测试类</p><pre><code>package com.spring.demo;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Text {    @Test    public void textUser() {        //Spring容器ApplicationContext在加载配置文件时对Bean进行实例化        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);         //由配置文件返回对象         myBean b = (myBean)context.getBean(&quot;bean1&quot;);         System.out.println(b);         b.print();    }}</code></pre><p>好了，上面就是Bean实例化中最常用的构造器实例化的一个例子，关于Bean配置中常用的标签和属性，不熟的话可以看看这篇<a href="https://www.cnblogs.com/V1haoge/p/5859556.html" target="_blank" rel="noopener">Spring中Bean的配置</a>，还想深入了解其他两种实例化方式的话可以看看这篇<a href="https://www.cnblogs.com/leihuazhe/p/7719539.html" target="_blank" rel="noopener">Spring学习之实例化bean的三种方式</a>。</p><h3 id="三、Bean的作用域"><a href="#三、Bean的作用域" class="headerlink" title="三、Bean的作用域"></a>三、Bean的作用域</h3><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p><ul><li><p>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例。</p></li><li><p>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例。</p></li><li><p>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效。</p></li><li><p>session：对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效。</p></li><li><p>globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效。</p></li></ul><p>用法举例：<code>&lt;bean id=&quot;bean1&quot; class=&quot;com.spring.demo&quot; scope=&quot;singleton&quot;/&gt;</code> </p><p>其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。也就是说，初始化生命周期回调方法在所有作用域的Bean是都会调用的，但是销毁生命周期回调方法在prototype作用域的Bean是不会调用的。 </p><p><strong>如果不指定Bean的作用域，Spring默认使用singleton作用域。</strong>Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p><p><em>这是基于线程安全性的考虑，如果使用有状态的Bean对象用singleton作用域，而无状态的Bean对象用prototype作用域。</em></p><h3 id="四、Bean的生命周期"><a href="#四、Bean的生命周期" class="headerlink" title="四、Bean的生命周期"></a>四、Bean的生命周期</h3><img src="/2018/08/18/Spring的Bean与IoC实现/springbean.png"><p>1.Spring对Bean进行实例化（相当于程序中的new Xx()） </p><p>2.Spring将值和Bean的引用注入进Bean对应的属性中</p><p>3.如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()方法（实现BeanNameAware清主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的）</p><p>4.如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。（实现BeanFactoryAware 主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等）</p><p>5.如果Bean实现了ApplicationContextAwaer接口，Spring容器将调用setApplicationContext(ApplicationContext ctx)方法，把y应用上下文作为参数传入<br>（作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext 的参数传入，而Spring容器在调用setBeanDactory前需要程序员自己指定（注入）setBeanDactory里的参数BeanFactory ）</p><p>6.如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessBeforeInitialization（预初始化）方法（作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能）</p><p>7.如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法，作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法。</p><p>8.如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessAfterInitialization（后初始化）方法（作用与6的一样，只不过6是在Bean初始化前执行的，而这个是在Bean初始化后执行的，时机不同 )</p><p>9.经过以上的工作后，Bean如果定义作用范围为prototype，则该Bean交给调用者，调用者管理Bean的生命周期，Spring不再管理该Bean，否则Bean交给Spring IoC的缓冲池，将触发Spring对该Bean的生命周期管理。</p><p>10.如果Bean实现了DispostbleBean接口，Spring将调用它的destory方法，作用与在配置文件中对Bean使用destory-method属性的作用一样，都是在Bean实例销毁前执行的方法。</p><h3 id="五、IoC实现"><a href="#五、IoC实现" class="headerlink" title="五、IoC实现"></a>五、IoC实现</h3><p>IoC的实现即Bean依赖注入的方式，也就是Bean的装配方式。Spring容器支持多种形式的Bean的装配方式，我想讲三种主要的装配方式。</p><h5 id="1-基于XML的装配"><a href="#1-基于XML的装配" class="headerlink" title="1.基于XML的装配"></a>1.基于XML的装配</h5><p>Spring提供了两种基于XML的装配方式：设值注入和构造注入。下面就讲解下如何在XML配置文件中使用这两种注入方式来实现基于XML的装配。</p><p>在Spring实例化Bean的过程中，Spring首先会调用Bean的默认构造方法来实例化Bean对象，然后通过反射的方式调用setter方法来注入属性值。因此，设值注入一个Bean必须满足以下两点要求。</p><ul><li><p>Bean类必须提供一个默认的无参构造方法。</p></li><li><p>Bean类必须为需要注入的属性提供对应的setter方法。</p></li></ul><p>使用设值注入时，在Spring配置文件中，需要使用&lt;bean&gt;元素的子元素&lt;property&gt;来为每个属性注入值；而使用构造注入时，在配置文件里，需要使用&lt;bean&gt;元素的子元素&lt;constructor-arg&gt;来定义构造方法的参数，可以使用其value属性（或子元素）来设置该参数的值。下面通过一个案例来演示基于XML方式的Bean的装配。</p><pre><code>//接口就不写了，下同package dao;public class UserDaoImpl implements UserDao {    private String username;    private String password;    /**     *1.使用构造注入     *提供带所有参数的有参构造方法     */    public UserDaoImpl(String username,String password) {        super();        this.username = username;        this.password = password;    }    /**     *2.使用设值注入     *提供默认无参构造方法     *为所有属性提供setter方法     */    public UserDaoImpl() {        }    public void setUsername(String username) {        this.username = username;    }    public void setPassword(String password) {        this.password = password;    }    @Override    public void save() {        System.out.println(&quot;hello,User Dao...My name is &quot;+username+&quot; password is &quot;+password);            } }</code></pre><p>UserDaoImpl的对象作为UserServiceImpl成员变量</p><pre><code>package service;import dao.UserDao;public class UserServiceImpl implements UserService {    private UserDao userDao;    /**     *1.使用构造注入     *提供带所有参数的有参构造方法     */    public UserServiceImpl(UserDao userDao) {        this.userDao = userDao;    }    /**     *2.使用设值注入     *提供默认无参构造方法     *为所有属性提供setter方法     */    public UserServiceImpl() {        }    public void setUserDao(UserDao userDao) {        this.userDao = userDao;    }    //实现了UserService中的方法    @Override    public void addUser() {        userDao.save();        System.out.println(&quot;hello,User Service...&quot;);    } }</code></pre><p>bean.xml文件中使用set方式装配普通成员变量与对象成员变量 </p><pre><code>&lt;!-- 将指定对象配置给spring，让spring创建实例 --&gt;&lt;bean id=&quot;userDao&quot; class=&quot;dao.UserDaoImpl&quot;&gt;     &lt;!-- 通过设值注入装配Bean --&gt;     &lt;property name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;     &lt;!-- 通过构造注入装配Bean --&gt;     &lt;constructor-arg index=&quot;0&quot; value=&quot;jack&quot;&gt;&lt;/constructor-arg&gt;     &lt;constructor-arg index=&quot;1&quot; value=&quot;1234&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;service.UserServiceImpl&quot;&gt;     &lt;!-- 设值注入方式 将userDao实例注入到userService实例中(使用setter方法) 与userDao实例装配Bean方式一样不过这里成员变量是对象 value改为ref --&gt;    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;    &lt;!-- 使用构造方法注入 --&gt;    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><p>测试方法</p><pre><code>@Test public void testUserDao() {     String xmlPath = &quot;beans.xml&quot;;     //初始化spring容器，加载配置文件     ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);     //通过容器获取userDao实例     UserDao userDao = (UserDao)applicationContext.getBean(&quot;userDao&quot;);     userDao.save(); }@Test public void testService() {     String xmlPath=&quot;beans.xml&quot;;     ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);     UserService userService = (UserServiceImpl)applicationContext.getBean(&quot;userService&quot;);                     userService.addUser(); }</code></pre><h5 id="2-基于注解的装配"><a href="#2-基于注解的装配" class="headerlink" title="2.基于注解的装配"></a>2.基于注解的装配</h5><p>为了防止有过多的Bean导致配置文件繁琐，可使用注解的功能进行Bean的装配，提供3个@Component注解衍生注解（功能一样）<br>@Repository ：Dao层 （数据访问层）<br>@Service：Service层 （业务层）<br>@Controller：Constroller层 （控制层）<br>这三个注解和@Component一样，但能使标注类的本身用途更加清晰。 </p><p>除了上面四个类注解，Spring还提供了@Value取代xml中的普通字段值，提供@Resource取代xml中的字段引用值（实现相同功能的注解还有@Autowired和@Autowired与@Qualifier的配合使用）。</p><p>上面的例子使用注解方式配置如下：</p><p>xml配置 context:component-scan标签</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://www.springframework.org/schema/beans/spring-beans.xsd             http://www.springframework.org/schema/context             http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 使用注解的方式装配Bean --&gt;    &lt;!-- 通知Spring扫描指定包下的所有Bean类，进行注解解析 --&gt;    &lt;context:component-scan base-package=&quot;annotation&quot;/&gt;&lt;/beans&gt;</code></pre><p>UserDaoimpl（数据访问层）类中使用@Repository注解 </p><pre><code>@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao {    @Override    public void save() {        // TODO Auto-generated method stub        System.out.println(&quot;userDao...save...&quot;);    }}</code></pre><p>UserServiceImpl（业务逻辑层）使用@Service注解，有引用字段userDao </p><pre><code>@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService{    @Resource(name=&quot;userDao&quot;)    private UserDao userDao;    public void setUserDao(UserDao userDao) {        this.userDao = userDao;    }    @Override    public void save() {        // TODO Auto-generated method stub        userDao.save();        System.out.println(&quot;userService...save...&quot;);    }}</code></pre><p>UserAction（业务流程控制层）使用@Controller注解，有引用字段userService </p><pre><code>@Controller(&quot;userAction&quot;)public class UserAction {    @Resource(name=&quot;userService&quot;)    private UserService userService;    public void setUserService(UserService userService) {        this.userService = userService;    }    public void save() {        userService.save();        System.out.println(&quot;userAction...save...&quot;);    }}</code></pre><p>测试方法</p><pre><code>    @Test    public void testAnnotation() {        //文件配置路径        String xmlPath=&quot;annotation/beans2.xml&quot;;        //加载配置文件，获得应用上下文实例        ApplicationContext context =                 new ClassPathXmlApplicationContext(xmlPath);        UserAction userAction = (UserAction)context.getBean(&quot;userAction&quot;);        System.out.println(userAction);        userAction.save();    }</code></pre><h5 id="3-自动装配"><a href="#3-自动装配" class="headerlink" title="3.自动装配"></a>3.自动装配</h5><p>需配置bean元素的autowire属性，该属性有五个值：byName、byType、constructor、autodetect、no 。</p><p>可将上例中beans.xml配置文件改成如下（类不需使用注解）： </p><pre><code>    &lt;!-- 使用自动装配方式,类中不需使用注解，装配引用字段直接通过id自动装配 --&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;annotation.UserDaoImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;annotation.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userAction&quot; class=&quot;annotation.UserAction&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</code></pre><p>输出结果与使用注解一致。 </p><p>这种方式不是很常用，感兴趣的自行了解<a href="https://www.jb51.net/article/106856.htm" target="_blank" rel="noopener">Spring的自动装配Bean的三种方式</a>、<a href="https://www.cnblogs.com/longshiyVip/p/4575563.html" target="_blank" rel="noopener">spring实战二之Bean的自动装配(非注解方式)</a>。</p><p>好了，这就是今天我要说的全部内容，主要对Spring中Bean和依赖注入的实现进行了详细讲解，内容是经过我自己理解及网上资料的总结，如果有什么疑惑或者错误欢迎联系我。</p><p>参考资料：《JavaEE企业级应用开发教程》</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring IoC与Spring容器</title>
      <link href="/2018/08/17/Spring%20IoC%E4%B8%8ESpring%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/08/17/Spring%20IoC%E4%B8%8ESpring%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="一、IoC与DI概念"><a href="#一、IoC与DI概念" class="headerlink" title="一、IoC与DI概念"></a>一、IoC与DI概念</h3><p>控制反转(Inversion of Control ,简称IoC）与依赖注入(Dependency Injection,简称DI)的含义相同，只不过这两个称呼是从两个角度描述的同一概念。对于一个Spring初学者来说，这两个称呼很难理解，下面我们将通过简单语言来描述这两个概念。</p><p>当某个Java对象（调用者）需要调用另一个Java对象（被调用者，即被依赖对象）时，在传统模式下，调用者通常会采用new关键字来创建对象，这种方式会导致调用者与被调用者之间的耦合性增加，不利于后期项目的升级和维护。</p><p>在使用Spring框架之后，对象的实例不再由调用者来创建，而是由Spring容器来创建，Spring容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制。这样，控制权由应用代码转移到了Spring容器，控制权发生了反转，这就是Spring的控制反转。</p><p>从Spring容器的角度看，Spring容器负责将被依赖对象赋值给调用者的成员变量，这相当于为调用者注入了它依赖的实例，这就是Spring的依赖注入。</p><p><em>提示：以下内容可能对初学者不太友好，可以大概看看，建议有基础后再来看。</em></p><h3 id="二、Spring容器"><a href="#二、Spring容器" class="headerlink" title="二、Spring容器"></a>二、Spring容器</h3><p>Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化 Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。</p><ul><li>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身； </li><li>ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。</li></ul><h5 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1.BeanFactory"></a>1.BeanFactory</h5><p>BeanFactory体系架构： </p><img src="/2018/08/17/Spring%20IoC与Spring容器/beanfactory.jpg"> <p>BeanFactory 接口位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展：</p><ul><li><p>ListableBeanFactory：该接口定义了访问容器中 Bean 基本信息的若干方法，如查看Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法； </p></li><li><p>HierarchicalBeanFactory：父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</p></li><li><p>ConfigurableBeanFactory：是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法； </p></li><li><p>AutowireCapableBeanFactory：定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法； </p></li><li><p>SingletonBeanRegistry：定义了允许在运行期间向容器注册单实例 Bean 的方法；</p></li><li><p>BeanDefinitionRegistry： Spring 配置文件中每一个&lt;bean&gt;节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。</p></li></ul><h5 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2.ApplicationContext"></a>2.ApplicationContext</h5><p>ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。</p><p>在BeanFactory 中，很多功能需要以编程的方式实现，而在 ApplicationContext 中则可以通过配置的方式实现。</p><img src="/2018/08/17/Spring%20IoC与Spring容器/ApplicationContext.jpg"><p>ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能： </p><ul><li>ClassPathXmlApplicationContext：默认从类路径加载配置文件</li><li>FileSystemXmlApplicationContext：默认从文件系统中装载配置文件</li><li>ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件 ， 并对事件进行响应处理 。 在 ApplicationContext 抽象实现类AbstractApplicationContext 中，我们可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。 </li><li>MessageSource：为应用提供 i18n 国际化消息访问的功能； </li><li>ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。 </li><li>LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</li><li>ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。</li></ul><p>使用：</p><p>如果配置文件放置在类路径下，用户可以优先使用 ClassPathXmlApplicationContext 实现类：</p><pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext(String configLocation);</code></pre><p>如果配置文件放置在文件系统的路径下，则可以优先考虑使用 FileSystemXmlApplicationContext 实现类：</p><pre><code>ApplicationContext ctx = new FileSystemXmlApplicationContext(String configLocation);</code></pre><p>Spring 3.0 支持基于类注解的配置方式，主要功能来自于 Spring 的一个名为 JavaConfig 子项目，目前 JavaConfig已经升级为 Spring核心框架的一部分。</p><p>ApplicationContext 在初始化应用上下文时就实例化所有单实例的 Bean。</p><h5 id="3-WebApplicationContext"><a href="#3-WebApplicationContext" class="headerlink" title="3.WebApplicationContext"></a>3.WebApplicationContext</h5><p>WebApplication体系架构： </p><img src="/2018/08/17/Spring%20IoC与Spring容器/WebApplicationContext.jpg"><p>WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext 中可以获得 ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext 中，以便 Web 应用环境可以访问 Spring 应用上下文。 WebApplicationContext 定义了一个常量ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，在上下文启动时， WebApplicationContext 实例即以此为键放置在 ServletContext 的属性列表中，因此我们可以直接通过以下语句从 Web 容器中获取WebApplicationContext： </p><pre><code>WebApplicationContext wac = (WebApplicationContext)servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</code></pre><p>Spring 和 Web 应用的上下文融合：</p><img src="/2018/08/17/Spring%20IoC与Spring容器/web.jpg"><p>WebApplicationContext 的初始化方式：WebApplicationContext 需要 ServletContext 实例，它必须在拥有 Web 容器的前提下才能完成启动的工作。可以在 web.xml 中配置自启动的 Servlet 或定义 Web 容器监听器（ ServletContextListener），借助这两者中的任何一个就可以完成启动 Spring Web 应用上下文的工作。Spring 分别提供了用于启动 WebApplicationContext 的 Servlet 和 Web 容器监听器： </p><ul><li>org.springframework.web.context.ContextLoaderServlet；</li><li>org.springframework.web.context.ContextLoaderListener；</li><li>由于 WebApplicationContext 需要使用日志功能，比如日志框架使用Log4J，用户可以将 Log4J 的配置文件放置到类路径 WEB-INF/classes 下，这时 Log4J 引擎即可顺利启动。如果 Log4J 配置文件放置在其他位置，用户还必须在 web.xml 指定 Log4J 配置文件位置。</li></ul><h3 id="三、Spring容器高层视图"><a href="#三、Spring容器高层视图" class="headerlink" title="三、Spring容器高层视图"></a>三、Spring容器高层视图</h3><p>Spring 启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。 </p><img src="/2018/08/17/Spring%20IoC与Spring容器/Spring.jpg"><p>Bean缓存池：HashMap实现 </p><h3 id="四、容器启动过程"><a href="#四、容器启动过程" class="headerlink" title="四、容器启动过程"></a>四、容器启动过程</h3><p>web环境下Spring容器、SpringMVC容器启动过程：</p><p>首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；</p><p>其次，在web.xml中会提供有contextLoaderListener（或ContextLoaderServlet）。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring容器以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；</p><p>再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例（Spring MVC），这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文容器，用以持有spring mvc相关的bean，这个servlet自己持有的上下文默认实现类也是XmlWebApplicationContext。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文（即第2步中初始化的XmlWebApplicationContext作为自己的父容器）。有了这个parent上下文之后，再初始化自己持有的上下文（这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等）。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，而是通过一些转换)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文定义的那些bean。</p><p>好了，关于Spring知识点有点多，这篇理论我知道让人懵懵的，建议和下篇博文一起食用，以上是经过我自己理解及网上资料对Spring控制反转和容器的总结，如果有什么疑惑或者错误欢迎联系我。</p><p>参考资料：《JavaEE企业级应用开发教程》《Spring 3.x企业应用开发实战》 </p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring入门</title>
      <link href="/2018/08/15/Spring%E5%85%A5%E9%97%A8/"/>
      <url>/2018/08/15/Spring%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>如果你看完我分类中JavaEE的所有内容并且能完成两三个Servlet+JSP+JDBC小项目，你可以正式开始后端框架的学习了。<strong>以后路还很长，我们慢慢走吧。</strong>不过首先我想先让你看看这个帖子<a href="https://zhuanlan.zhihu.com/p/34985791" target="_blank" rel="noopener">Spring核心技术原理(1)–为什么要有Spring?</a>，这个帖子详细说明了JavaWeb的发展历程以及为何我们要使用Spring，整理得很好，（其中涉及的设计模式不理解的话可以去我博客里找相关博文）。然后我们就开始吧。</p><h3 id="一、Spring概述"><a href="#一、Spring概述" class="headerlink" title="一、Spring概述"></a>一、Spring概述</h3><h5 id="1-什么是Spring"><a href="#1-什么是Spring" class="headerlink" title="1.什么是Spring"></a>1.什么是Spring</h5><p>Spring是由Rod Johnson组织开发的一个分层的JavaEE轻量级开源框架，它以IoC(Inversion of Control ,控制反转)和AOP(Aspect Oriented Programming ,面向切面编程)为内核，使用基本的JavaBean来完成以前只能由<a href="https://baike.baidu.com/item/EJB" target="_blank" rel="noopener">EJB</a>完成的工作，取代了<a href="https://baike.baidu.com/item/EJB" target="_blank" rel="noopener">EJB</a>臃肿低效的开发模式。</p><p>Spring致力于JavaEE应用各层的解决方案，在表现层它提供了Spring MVC以及与Struts框架的整合功能；在业务逻辑层可以管理事务、记录日志等；在持久层可以整合Mybatis、Hibernate、JdbcTemplate等技术。因此，可以说Spring是企业应用开发很好的“一站式”选择。虽然Spring贯穿于表现层、业务逻辑层和持久层，但它并不想取代那些已有的框架，而是以高度的开放性与它们进行无缝整合。</p><h5 id="2-Spring的特点"><a href="#2-Spring的特点" class="headerlink" title="2.Spring的特点"></a>2.Spring的特点</h5><p>(1)方便解耦，简化开发</p><p>通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p><p>(2)AOP编程的支持</p><p>通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</p><p>(3)声明式事务的支持</p><p>在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</p><p>(4)方便程序的测试</p><p>可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p><p>(5)方便集成各种优秀框架</p><p>Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts、Hibernate、Mybatis）等的直接支持。</p><p>(6)降低JavaEE API的使用难度</p><p>Spring对很多难用的JavaEE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些JavaEE API的使用难度大为降低。</p><p>(7)Java 源码是经典学习范例</p><p>Spring的源码设计精妙、结构清晰、匠心独运，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。</p><h5 id="3-Spring体系结构"><a href="#3-Spring体系结构" class="headerlink" title="3.Spring体系结构"></a>3.Spring体系结构</h5><img src="/2018/08/15/Spring入门/spring.jpg"><p>从中可以看到Spring Framework差不多有20个模块组成，这些模块分为核心容器，数据访问/集成，Web，AOP（面向方面的编程），Instrumentation，消息传递和测试，如上图所示。</p><p>Core Container模块，包含spring-beans、spring-core、spring-context、spring-expression四个方面。</p><ul><li>spring-core和spring-beans：提供了框架的基础部分，包括反转控制和依赖注入功能。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。</li></ul><ul><li>spring-context：<strong>这个模块建立在core和bean模块提供坚实的基础上，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等；</strong>核心接口是ApplicationContext。</li></ul><ul><li>spring-expression：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</li></ul><p>AOP and Instrumentation模块，包含spring-aop、spring-instrument两个方面。</p><ul><li>spring-aop：Spring AOP模块提供了符合 <em>AOP Alliance</em>规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。</li></ul><ul><li>spring-instrument：在特定的应用程序服务器中支持类和类加载器的实现，比如Tomcat。</li></ul><p>Messaging，从Spring  Framework  4开始集成了MessageChannel, MessageHandler等，用于消息传递的基础。</p><p>Data Access/Integration，包括了JDBC、ORM、OXM、JMS和事务管理。</p><p>事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。</p><ul><li>spring-jdbc：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</li></ul><ul><li>spring-orm：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。</li></ul><ul><li>spring-oxm：提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。</li></ul><ul><li>spring-jms：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li></ul><p>Web，包含了spring-web, spring-webmvc, spring-websocket, and spring-webmvc-portlet几个模块。</p><ul><li>spring-web：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。</li></ul><ul><li>spring-webmvc：提供了一个Spring MVC Web框架和REST Web服务的实现。Spring的MVC框架提供了领域模型代码和Web表单之间分离，并与Spring框架的所有其他功能集成。</li></ul><ul><li>spring-webmvc-portlet：提供了在Portlet环境中使用MVC实现，并且反映了spring-webmvc模块的功能。</li></ul><h3 id="二、入门例子"><a href="#二、入门例子" class="headerlink" title="二、入门例子"></a>二、入门例子</h3><p>(1)导入Spring框架中的相关jar包，这里只导入Spring的Core模块（Core模块是框架的核心类库）下的jar包（使用IoC的基本操作，并不需要导入Spring的所有jar包，只导入<code>spring-beans</code>、<code>spring-core</code>、<code>spring-context</code>、<code>spring-expression</code>这4个jar包），以及 支持日志输出的 commons-logging 和 log4j 的jar包。<br>(2)创建一个普通的Java类，并在该类中创建方法，如下：<br>User.java</p><pre><code>package com.spring;public class User {    public void add() {        System.out.println(&quot;User Add Method.&quot;);    }    @Override    public String toString() {        return &quot;This is a user object.&quot;;    }}</code></pre><p>(3)创建Spring的配置文件，进行Bean的配置<br>Spring的核心配置文件名称和位置不是固定的。但官方件建议将该核心配置文件放在src目录下，且命名为 applicationContext.xml。这里为了方便，将核心配置文件放在src目录下，并命名为 applicationContext.xml，内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.spring.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>(4)编写测试类进行测试，通过配置文件创建类对象<br>TestIoC.java</p><pre><code>package com.spring;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestIoc {    @Test    public void runUser() {        //加载Spring配置文件，根据创建对象        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //得到配置创建的对象        User user = (User) context.getBean(&quot;user&quot;);        System.out.println(user);        user.add();    }}</code></pre><p> 以上是个简单应用Spring实例化Bean的入门例子，可以看到在TestIoC中我们创建User类对象并不是通过new实例化，而是Spring容器通过无参构造方法实例化。</p><p>好了，Spring入门就到这里，下篇我会具体说说Spring的IoC，关于Spring的使用我不会讲很细，因为内容真的很多，我只会挑出重点来进行讲解，望理解。</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单例模式</title>
      <link href="/2018/08/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="一、单例模式动机"><a href="#一、单例模式动机" class="headerlink" title="一、单例模式动机"></a>一、单例模式动机</h3><p>对于系统中的某些类来说，只有一个实例很重要， 如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。 </p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。 </p><h3 id="二、单例模式概述"><a href="#二、单例模式概述" class="headerlink" title="二、单例模式概述"></a>二、单例模式概述</h3><p>让我们来用单例模式的思想模拟实现任务管理器，下面是具体代码</p><pre><code>public class TaskManager {    //TaskManager提供的唯一实例    private static TaskManager tm = null;    //私有构造方法使外部类无法使用new关键字创建TaskManager实例    private TaskManager() {        ...    }    //该方法用于给外部类返回TaskManager唯一实例    public static TaskManager getInstance() {        if(tm == null) {            tm = new TaskManager();        }        return tm;    }     //任务管理器功能方法    public void display() {        ...    }} </code></pre><p>为什么getInstance()方法要定义为静态方法？因为外部类需要调用getInstance()方法得到唯一TaskManager实例，而调用非成员方法只有两种方式，通过对象调用或者类调用，对象调用肯定不行（我们调用getInstance()方法目的就是要得到对象，就是缺对象），所以只能通过TaskManager类调用，而类只能调用静态成员方法，所以必须将getInstance()定义为静态。</p><p>上述代码是单例模式的一种典型实现方式，理解之后我们再来看看单例模式的定义：<strong>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个类实例，这个类称为单例类，它提供全局访问的方法。</strong></p><p>单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 </p><h3 id="三、饿汉式单例与懒汉式单例"><a href="#三、饿汉式单例与懒汉式单例" class="headerlink" title="三、饿汉式单例与懒汉式单例"></a>三、饿汉式单例与懒汉式单例</h3><h5 id="1-饿汉式单例类"><a href="#1-饿汉式单例类" class="headerlink" title="1.饿汉式单例类"></a>1.饿汉式单例类</h5><p>饿汉式单例类是实现起来最简单的单例类，在定义静态变量的时候马上实例化，因此类加载时候就已经创建单例对象，代码如下：</p><pre><code>public class EagerSingleton {    //唯一实例    private static EagerSingleton instance = new EagerSingleton();    //私有构造方法    private EagerSingleton(){}    //静态工厂方法    public static EagerSingleton getInstance() {        return instance;    }}</code></pre><p>在这个类被加载时，静态变量instance会被初始化，此时类的私有构造方法会被调用。这时候，单例类的唯一实例就被创建出来了。</p><p>饿汉式是典型的空间换时间，当类装载的时候就会创建类实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断了，节省了运行时间。 </p><h5 id="2-懒汉式单例类"><a href="#2-懒汉式单例类" class="headerlink" title="2.懒汉式单例类"></a>2.懒汉式单例类</h5><p>懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。 </p><pre><code>public class LazySingleton {    //唯一实例    private static LazySingleton instance = null;    //私有构造方法     private LazySingleton(){}    // 静态工厂方法    public static synchronized LazySingleton getInstance() {        if(instance == null){            instance = new LazySingleton();        }        return instance;    }}</code></pre><p>上面的懒汉式单例类实现里对静态工厂方法使用了同步化，以处理多线程环境。 由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。所以对比饿汉式，懒汉式是时间换空间，那么有没有更好的方式实现呢？ </p><h5 id="3-双重检查加锁"><a href="#3-双重检查加锁" class="headerlink" title="3.双重检查加锁"></a>3.双重检查加锁</h5><p>可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。那么什么是“双重检查加锁”机制呢？</p><p>所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance()方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</p><p>“双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</p><pre><code>public class Singleton {    //唯一实例    private volatile static Singleton instance = null;    //私有构造方法    private Singleton(){}    // 静态工厂方法    public static Singleton getInstance(){        //先检查实例是否存在，如果不存在才进入下面的同步块        if(instance == null){            //同步块，线程安全的创建实例            synchronized (Singleton.class) {                //再次检查实例是否存在，如果不存在才真正的创建实例                if(instance == null){                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre><p>这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。 </p><p>提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。 </p><h5 id="4-饿汉式单例类与懒汉式单例类的比较"><a href="#4-饿汉式单例类与懒汉式单例类的比较" class="headerlink" title="4.饿汉式单例类与懒汉式单例类的比较"></a>4.饿汉式单例类与懒汉式单例类的比较</h5><p>饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长(考虑简单，性能略低)。</p><p>懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响(考虑复杂，资源利用效率高)。</p><h3 id="三、更好的实现方式"><a href="#三、更好的实现方式" class="headerlink" title="三、更好的实现方式"></a>三、更好的实现方式</h3><p>根据上面的分析，常见的两种单例实现方式都存在小小的缺陷，那么有没有一种方案，既能实现延迟加载，又能实现线程安全呢？ </p><h5 id="1-Lazy-initialization-holder-class模式"><a href="#1-Lazy-initialization-holder-class模式" class="headerlink" title="1.Lazy initialization holder class模式"></a>1.Lazy initialization holder class模式</h5><p>大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括：</p><p>(1)由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</p><p>(2)访问final字段时</p><p>(3)在创建线程之前创建对象时</p><p>(4)线程可以看见它将要处理的对象时</p><p>要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。</p><p>如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。示例代码如下：</p><pre><code>public class Singleton {    private Singleton(){}    /**     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。     */    private static class SingletonHolder{        // 静态初始化器，由JVM来保证线程安全        private static Singleton instance = new Singleton();    }    public static Singleton getInstance() {        return SingletonHolder.instance;    }}</code></pre><p>当getInstance()方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。</p><p>这个模式的优势在于，getInstance()方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。</p><h5 id="2-单元素枚举单例"><a href="#2-单元素枚举单例" class="headerlink" title="2.单元素枚举单例"></a>2.单元素枚举单例</h5><p>单例的枚举实现在《Effective Java》中有提到，因为其功能完整、使用简洁、无偿地提供了序列化机制、在面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化等优点，单元素的枚举类型被作者认为是实现单例模式的最佳方法。 </p><p> 用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。 </p><pre><code>public enum Singleton {    // 定义一个枚举的元素，它就代表了Singleton的一个实例    uniqueInstance;    // 单例可以有自己的操作    public void singletonOperation(){        //功能处理    }}</code></pre><p>使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 </p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVC模式与三层架构</title>
      <link href="/2018/08/11/MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/08/11/MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>很多基础不好的人总是把MVC和三层架构混为一谈，并不了解它们的区别是什么，甚至以为是一种东西，现在我就具体讲讲，也复习一下。</p><h3 id="一、MVC模式"><a href="#一、MVC模式" class="headerlink" title="一、MVC模式"></a>一、MVC模式</h3><h5 id="1-Model1-JSP-JavaBean"><a href="#1-Model1-JSP-JavaBean" class="headerlink" title="1.Model1(JSP + JavaBean)"></a>1.Model1(JSP + JavaBean)</h5><p>之前说了JSP，我们知道在JSP中可以写Java代码，那仔细想想，这JSP不是很棒棒，一方面可以负责界面显示，一方面又可以负责处理业务逻辑和流程控制 。那项目只写JSP和JavaBean不就好了，还有Servlet什么事，实际上在早期的JavaWeb应用中， 开发人员也是这么做的。这就是Model1模型。</p><img src="/2018/08/11/MVC模式与三层架构/model1.png"><p>上面是Model1的流程图，在Model1模型中，是以JSP为中心，它既要做页面显示，又要负责业务逻辑处理和流程控制，对于单一职责的原则来说，这显然不符合，JSP的职责太重，就显得中间部分有些臃肿 。因此Model1不适合开发复杂的大型应用程序。 </p><h5 id="2-Model2-Servlet-JSP-JavaBean"><a href="#2-Model2-Servlet-JSP-JavaBean" class="headerlink" title="2.Model2(Servlet + JSP + JavaBean)"></a>2.Model2(Servlet + JSP + JavaBean)</h5><p>因为Model1的缺点太过明显，在Model1的基础上，Model2对JSP的任务进行分离，将获取参数，流程控制这些和页面显示无关的转到Servlet处理，JSP只做显示即可。</p><img src="/2018/08/11/MVC模式与三层架构/model2.png"><p>在Model2中，JSP只负责界面显示，Servlet负责应用的处理过程控制 ，JavaBean负责对数据库操作的类。但是相对于Model1，Model2对程序员的要求要高，各部分之间分工明确，各司其职。结果是开发的粒度较细，代码的复用性提高了，后期维护也容易了，所以Model2比较适合大型项目的开发。 </p><h5 id="3-MVC模式是什么"><a href="#3-MVC模式是什么" class="headerlink" title="3.MVC模式是什么"></a>3.MVC模式是什么</h5><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。最典型的MVC就是上面说的Model2模型，其实究起来，Model1也实现了MVC模式，只不过view和controller两个角色都由JSP来扮演，实现得并不彻底。</p><p>model:常用JavaBean去实现，通过各种类来对数据库的数据进行获取，并封装在对象当中。</p><p>view:常用JSP来实现，通过可直接观察的JSP页面来展示我们从数据库中获取的数据。</p><p>controller:常用Servlet来实现，用来接收用户提交的请求，然后获取请求中的数据，将之转换为业务模型需要的数据模型，然后调用业务模型相应的业务方法进行更新，同时根据业务执行结果来选择要返回的视图。</p><h3 id="二、三层架构"><a href="#二、三层架构" class="headerlink" title="二、三层架构"></a>二、三层架构</h3><h5 id="1-三层架构是什么"><a href="#1-三层架构是什么" class="headerlink" title="1.三层架构是什么"></a>1.三层架构是什么</h5><p>通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层、表现层，如图所示</p><img src="/2018/08/11/MVC模式与三层架构/三层架构.jpg"><h5 id="2-各层次的任务"><a href="#2-各层次的任务" class="headerlink" title="2.各层次的任务"></a>2.各层次的任务</h5><p>表现层（UI）：表现层可以说是距离用户最近的层，主要是用于接收用户输入的数据和显示处理后用户需要的数据。一般表现为界面，用户通过界面输入查询数据和得到需要的数据。</p><p>业务逻辑层（BLL）：业务逻辑层是处于表现层和数据访问层之间，主要是从数据库中得到数据然后对数据进行逻辑处理。</p><p>数据访问层（DAL）：数据访问层是直接和数据库打交道的，对数据进行“增、删、改、查”等基本的操作。</p><h5 id="3-与MVC模式的区别与联系"><a href="#3-与MVC模式的区别与联系" class="headerlink" title="3.与MVC模式的区别与联系"></a>3.与MVC模式的区别与联系</h5><p>(1)区别：首先，它们根本不是一个概念。三层架构是一个分层式的软件体系架构设计，它可适用于任何一个项目。MVC是一个架构模式，可以用它来创建在域对象和UI表示层对象之间的区分。在三层架构中没有定义Controller的概念，这是最不同的地方 。</p><p>(2)联系：网上谈到三层架构与MVC模式的联系时，主要有两种说法，我看了他们的观点，发现主要区别在于对MVC模式中model的功能的理解。</p><p>一种观点认为三层架构中每一层都有不同的架构模式，表示层最常用的架构模式就是MVC，而MVC中的model只是一些简单实体类。下面是基于这种观点的一个常见的J2EE项目结构（我一般也是这种结构）</p><ul><li>users.jsp (V)</li><li>UserController.java (C)</li><li>UserService.java (业务逻辑层)</li><li>UserDao.java (数据访问层)</li><li>User.java (M)</li></ul><p>另一种观点认为MVC模式内的view和controller组成了三层架构的表现层，而model的功能分业务逻辑层和数据访问层来实现，这时的model就不能只是简单实体类了，还必须包括逻辑处理类和数据访问类，如下图所示<br><img src="/2018/08/11/MVC模式与三层架构/mvc与三层架构.jpg"></p><p>发现没，刚刚提到的model2模型就是基于这个观点。</p><p>具体哪种正确我认为没有绝对的答案，两种观点我都理解，具体情况具体分析，况且实际开发中对这些理念也没纠结那么多，代码敲出来就完事了！以上是经过我自己理解及网上资料对MVC模式和三层架构的总结，如果有什么疑惑或者错误欢迎联系我。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVC模式 </tag>
            
            <tag> 三层架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSP总结</title>
      <link href="/2018/08/08/JSP%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/08/JSP%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>感觉自己三分钟热度要过去了，不想更博想偷懒了，以后不知道能不能做到一周二更，果然做个快乐肥宅太舒服了。。。废话不说，今天讲JSP，下面就开始吧。</p><h3 id="一、什么是JSP"><a href="#一、什么是JSP" class="headerlink" title="一、什么是JSP"></a>一、什么是JSP</h3><p>掌握了编写Servlet程序后，我们有能力让网页“动”起来——根据不同的输入（URL参数、Session等）生成不同的页面内容。但由于Web中大量用到HTML作为展示语言，在Servlet中去拼接HTML代码显然不是一个好办法。Java EE里制定的JSP标准，就是帮助开发者基于HTML/XML来动态生成Web页面内容。 </p><p>JSP全名为Java Server Pages，中文名叫Java服务器页面，其根本是一个简化的Servlet设计，它是由Sun提出的一种动态网页技术标准。在传统的网页HTML（标准通用标记语言的子集）文件中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件。  </p><p>本质上来说，JSP是Servlet的一个更高层的抽象。<strong>Servlet容器会将JSP在运行时转化为Servlet程序</strong>，接下来的处理流程就和Servlet完全一样了。</p><p>下面是一个最简单的一段jsp代码： </p><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;    &lt;title&gt;First Jsp&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;%        out.print(&quot;Hello Jsp&quot;);    %&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p> 对应的，Servlet容器将上面的JSP转化为Servlet如下：</p><pre><code>package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;import java.util.*;public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase    implements org.apache.jasper.runtime.JspSourceDependent {  private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();  private static java.util.List _jspx_dependants;  private javax.el.ExpressionFactory _el_expressionfactory;  private org.apache.AnnotationProcessor _jsp_annotationprocessor;  public Object getDependants() {    return _jspx_dependants;  }  public void _jspInit() {    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();    _jsp_annotationprocessor = (org.apache.AnnotationProcessor) getServletConfig().getServletContext().getAttribute(org.apache.AnnotationProcessor.class.getName());  }  public void _jspDestroy() {  }  public void _jspService(HttpServletRequest request, HttpServletResponse response)        throws java.io.IOException, ServletException {    PageContext pageContext = null;    HttpSession session = null;    ServletContext application = null;    ServletConfig config = null;    JspWriter out = null;    Object page = this;    JspWriter _jspx_out = null;    PageContext _jspx_page_context = null;    try {      response.setContentType(&quot;text/html;charset=UTF-8&quot;);      pageContext = _jspxFactory.getPageContext(this, request, response,                  null, true, 8192, true);      _jspx_page_context = pageContext;      application = pageContext.getServletContext();      config = pageContext.getServletConfig();      session = pageContext.getSession();      out = pageContext.getOut();      _jspx_out = out;      out.write(&#39;\r&#39;);      out.write(&#39;\n&#39;);String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;      out.write(&quot;\r\n&quot;);      out.write(&quot;\r\n&quot;);      out.write(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;\r\n&quot;);      out.write(&quot;&lt;html&gt;\r\n&quot;);      out.write(&quot;  &lt;head&gt;\r\n&quot;);      out.write(&quot;    &lt;base href=\&quot;&quot;);      out.print(basePath);      out.write(&quot;\&quot;&gt;\r\n&quot;);      out.write(&quot;    \r\n&quot;);      out.write(&quot;    &lt;title&gt;First Jsp&lt;/title&gt;\r\n&quot;);      out.write(&quot;\t\r\n&quot;);      out.write(&quot;  &lt;/head&gt;\r\n&quot;);      out.write(&quot;  \r\n&quot;);      out.write(&quot;  &lt;body&gt;\r\n&quot;);      out.write(&quot;    &quot;);        out.print(&quot;Hello Jsp&quot;);      out.write(&quot;\r\n&quot;);      out.write(&quot;  &lt;/body&gt;\r\n&quot;);      out.write(&quot;&lt;/html&gt;\r\n&quot;);    } catch (Throwable t) {      if (!(t instanceof SkipPageException)){        out = _jspx_out;        if (out != null &amp;&amp; out.getBufferSize() != 0)          try { out.clearBuffer(); } catch (java.io.IOException e) {}        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);      }    } finally {      _jspxFactory.releasePageContext(_jspx_page_context);    }  }}</code></pre><h3 id="二、JSP运行原理"><a href="#二、JSP运行原理" class="headerlink" title="二、JSP运行原理"></a>二、JSP运行原理</h3><p>当客户端浏览器向服务器发出访问一个JSP页面的请求时，服务器根据该请求加载相应的JSP页面，并对该页面进行编译，然后执行。JSP页面的执行过程如下图所示：</p><img src="/2018/08/08/JSP总结/JSP1.png"><p>1.当用户访问一个JSP页面时，会向一个Servlet容器（Tomcat等）发出请求。</p><p>2.服务器根据接收到的客户端的请求来加载相应的JSP文件。</p><p>3.Web服务器中的JSP引擎会将被加载的JSP文件转化为Servlet(.java文件)。</p><p>4.JSP引擎将生成的Servlet代码编译成.class文件。</p><p>5.服务器执行这个.class文件， 将执行结果发送给浏览器进行显示。 </p><p>并不是每次请求都需要重复进行这样的处理。当服务器第一次接收到对某个页面的请求时，JSP引擎就开始按照上述的处理过程来将被请求的JSP文件编译成.class文件。当再次对该页面进行请求时，如果该页面没有任何改动，服务器就会直接调用对应的.class文件来执行，因此当某个JSP页面第一次被请求时，会有一些延迟，而再次访问时会感觉速度快了很多。如果被请求的页面经过了修改，那么服务器会重新编译这个文件，然后再执行。 </p><h3 id="三、JSP基础语法"><a href="#三、JSP基础语法" class="headerlink" title="三、JSP基础语法"></a>三、JSP基础语法</h3><h5 id="1-JSP表达式"><a href="#1-JSP表达式" class="headerlink" title="1.JSP表达式"></a>1.JSP表达式</h5><p>JSP表达式用于向页面中输出信息，其语法格式如下：</p><p><code>&lt;%= expression %&gt;</code></p><p>参数说明：</p><p>expression：可以是任何Java语言的完整表达式，该表达式的最终运算结果将被转换为字符串。</p><p>需要注意 : </p><p>(1)JSP 的表达式中没有分号 !</p><p>(2)”%=” 间不能有空格</p><p>程序示例： </p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;   今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; </code></pre><h5 id="2-JSP脚本片断"><a href="#2-JSP脚本片断" class="headerlink" title="2.JSP脚本片断"></a>2.JSP脚本片断</h5><p>JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码，其语法格式如下：</p><pre><code>&lt;%         　　　    多行java代码  　　　%&gt;</code></pre><p>需要注意 : </p><p>(1)在&lt;% %&gt;中可以定义变量，编写语句，不能定义方法。</p><p>(2)JSP脚本片断中只能出现java代码，不能出现其它模板元素，JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。</p><p>(3)在一个JSP页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。</p><p>(4)JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须用分号结束。</p><p>程序示例：</p><pre><code>&lt;%    int sum=0;     for(int i=1;i&lt;=100;i++) {        sum+=i;    }    out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);%&gt;</code></pre><h5 id="3-JSP声明"><a href="#3-JSP声明" class="headerlink" title="3.JSP声明"></a>3.JSP声明</h5><p>JSP页面中编写的所有代码，默认会翻译到Servlet的service方法中， 而JSP声明中的Java代码被翻译到_jspService方法的外面，其语法格式如下：</p><pre><code>&lt;% !        　　　    Java代码  　　　%&gt;</code></pre><p>需要注意 : </p><p>(1)声明以 “&lt;%!” 开头 , 以 “%&gt;” 结尾 , “%!” 必须紧挨。</p><p>(2)多个静态代码块，变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。JSP隐式对象的作用范围仅限于Servlet的_jspService方法，所以在JSP声明中不能使用这些隐式对象。</p><p>程序示例：</p><pre><code>&lt;%! int i = 0; %&gt; &lt;%! int a, b, c; %&gt; &lt;%! Circle a = new Circle(2.0); %&gt;</code></pre><h5 id="4-JSP注释"><a href="#4-JSP注释" class="headerlink" title="4.JSP注释"></a>4.JSP注释</h5><p>JSP 程序的注释有隐藏注释、HTML 注释、Java 语言注释</p><p>(1)隐藏注释是 JSP 的标准注释 , 在编写 JSP 程序中 , 在发布网页时完全被忽略, 不发送至客户端。</p><p>语法格式如下 :</p><p><code>&lt;%-- comment --%&gt;</code> </p><p>comment 为被注释内容</p><p>(2)HTML 注释在发布网页时可以在浏览器文件窗口中看到 HTML 注释 , 在这种注释中 , 也可以使用 JSP 的表达式。</p><p>语法格式如下 :</p><p><code>&lt;!-- comment [&lt;%=expression%&gt;]--&gt;</code>　　</p><p>comment 为被注释内容</p><p>(3)Java 注释和隐藏注释相似 , 在浏览器的源文件窗口中也看不到注释内容。</p><p>语法格式如下:</p><p><code>&lt;%// 单行注释 %&gt;</code></p><p><code>&lt;%/* 多行注释 */%&gt;</code></p><h5 id="5-JSP指令"><a href="#5-JSP指令" class="headerlink" title="5.JSP指令"></a>5.JSP指令</h5><p>JSP指令用来设置与整个JSP页面相关的属性。</p><p>JSP指令语法格式：</p><p><code>&lt;%@ directive attribute=&quot;value&quot; %&gt;</code></p><p>这里有三种指令标签：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>&lt;%@ page … %&gt;</td><td>定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td></tr><tr><td>&lt;%@ include … %&gt;</td><td>包含其他文件</td></tr><tr><td>&lt;%@ taglib … %&gt;</td><td>引入标签库的定义，可以是自定义标签</td></tr></tbody></table><h5 id="6-JSP行为"><a href="#6-JSP行为" class="headerlink" title="6.JSP行为"></a>6.JSP行为</h5><p>JSP行为标签使用XML语法结构来控制Servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。</p><p>行为标签只有一种语法格式，它严格遵守XML标准：</p><p><code>&lt;jsp:action_name attribute=&quot;value&quot; /&gt;</code></p><p>行为标签基本上是一些预先就定义好的函数，下表罗列出了一些可用的JSP行为标签：</p><table><thead><tr><th><strong>语法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>jsp:include</td><td>用于在当前页面中包含静态或动态资源</td></tr><tr><td>jsp:useBean</td><td>寻找和初始化一个JavaBean组件</td></tr><tr><td>jsp:setProperty</td><td>设置 JavaBean组件的值</td></tr><tr><td>jsp:getProperty</td><td>将 JavaBean组件的值插入到 output中</td></tr><tr><td>jsp:forward</td><td>从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td></tr><tr><td>jsp:plugin</td><td>用于在生成的HTML页面中包含Applet和JavaBean对象</td></tr><tr><td>jsp:element</td><td>动态创建一个XML元素</td></tr><tr><td>jsp:attribute</td><td>定义动态创建的XML元素的属性</td></tr><tr><td>jsp:body</td><td>定义动态创建的XML元素的主体</td></tr><tr><td>jsp:text</td><td>用于封装模板数据</td></tr></tbody></table><h5 id="7-JSP隐含对象"><a href="#7-JSP隐含对象" class="headerlink" title="7.JSP隐含对象"></a>7.JSP隐含对象</h5><p>JSP支持九个自动定义的变量，江湖人称隐含对象。这九个隐含对象的简介见下表：</p><table><thead><tr><th><strong>对象</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>request</td><td><strong>HttpServletRequest</strong>类的实例</td></tr><tr><td>response</td><td><strong>HttpServletResponse</strong>类的实例</td></tr><tr><td>out</td><td><strong>PrintWriter</strong>类的实例，用于把结果输出至网页上</td></tr><tr><td>session</td><td><strong>HttpSession</strong>类的实例</td></tr><tr><td>application</td><td><strong>ServletContext</strong>类的实例，与应用上下文有关</td></tr><tr><td>config</td><td><strong>ServletConfig</strong>类的实例</td></tr><tr><td>pageContext</td><td><strong>PageContext</strong>类的实例，提供对JSP页面所有对象以及命名空间的访问</td></tr><tr><td>page</td><td>类似于Java类中的this关键字</td></tr><tr><td>Exception</td><td><strong>Exception</strong>类的对象，代表发生错误的JSP页面中对应的异常对象</td></tr></tbody></table><p>好了，JSP的内容有点多，我就先介绍到这里了，理论知识很多，记不住就多敲多看，有兴趣的可以再去网上看看EL表达式和自定义标签，但是我不建议花太多时间。以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p><p>参考文章：<a href="http://www.runoob.com/jsp/jsp-syntax.html" target="_blank" rel="noopener">菜鸟教程–JSP语法</a></p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java会话管理：Cookie和Session</title>
      <link href="/2018/08/07/Java%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9ACookie%E5%92%8CSession/"/>
      <url>/2018/08/07/Java%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9ACookie%E5%92%8CSession/</url>
      <content type="html"><![CDATA[<p>http是<strong>无状态</strong>的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。 </p><p>具体解释一下这个“无状态”：</p><ol><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li><p>人生若只如初见</p><p>这有个具体的生活例子说明了无状态http的不便性：</p></li></ol><p>当我们在一个购物网站上登陆自己的帐号后，我们便开始浏览商品，这时我们发现了心仪的商品，点进去打算看商品详情，发现竟然又要我们登陆帐号，为什么？因为无状态http请求无法保存我们用户信息，点击商品是一个请求，刚刚进入网站主页也是一个请求，这两个请求没有上下文联系，服务器无法判断这是同一个用户的请求，所以我们不得不再输入我们的账号密码，点击添加购物车，这也是一个请求，我们还是得输入帐号密码，还有其它商品操作，还有结算按钮。。。</p><p>没有会话管理技术会给我们生活带来多大不便从上个例子就可以略知一二，Java中我们有Cookie和Session来帮助我们解决这个麻烦。</p><h3 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h3><h5 id="1-什么是Cookie"><a href="#1-什么是Cookie" class="headerlink" title="1.什么是Cookie"></a>1.什么是Cookie</h5><p>“Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从： [系统盘]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。 ”这是百度百科上关于Cookie的解释，说得很明了也很详细，下图是利用Cookie与服务器交流的简图：</p><img src="/2018/08/07/Java会话管理：Cookie和Session/Cookie.png"><h5 id="2-Cookie的使用"><a href="#2-Cookie的使用" class="headerlink" title="2.Cookie的使用"></a>2.Cookie的使用</h5><p>如何使用Cookie？Java API关于Cookie提供了很多方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Cookie(String name, String value)</td><td>实例化<code>Cookie</code>对象，传入<code>Cookie</code>名称和<code>Cookie</code>的值</td></tr><tr><td>public String getName()</td><td>取得<code>Cookie</code>的名字</td></tr><tr><td>public String getValue()</td><td>取得<code>Cookie</code>的值</td></tr><tr><td>public void setValue(String newValue)</td><td>设置<code>Cookie</code>的值</td></tr><tr><td>public void setMaxAge(int expiry)</td><td>设置<code>Cookie</code>的最大保存时间，即<code>Cookie</code>的有效期</td></tr><tr><td>public int getMaxAge()</td><td>获取<code>Cookie</code>的有效期</td></tr><tr><td>public void setPath(String uri)</td><td>设置<code>Cookie</code>的有效路径</td></tr><tr><td>public String getPath()</td><td>获取<code>Cookie</code>的有效路径</td></tr><tr><td>public void setDomain(String pattern)</td><td>设置<code>Cookie</code>的有效域</td></tr><tr><td>public String getDomain()</td><td>获取<code>Cookie</code>的有效域</td></tr></tbody></table><p>已下是Cookie使用的一个例子，记录用户访问网站信息</p><pre><code>public class CookieServlet extends HttpServlet {    public void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        //设置服务器端以UTF-8编码进行输出        response.setCharacterEncoding(&quot;UTF-8&quot;);        //设置浏览器以UTF-8编码进行接收,解决中文乱码问题        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter out = response.getWriter();        //获取浏览器访问访问服务器时传递过来的cookie数组        Cookie[] cookies = request.getCookies();        //如果用户是第一次访问，那么得到的cookies将是null        if (cookies!=null) {            out.write(&quot;您上次访问的时间是：&quot;);            for (int i = 0; i &lt; cookies.length; i++) {                Cookie cookie = cookies[i];                if (cookie.getName().equals(&quot;lastAccessTime&quot;)) {                    Long lastAccessTime =Long.parseLong(cookie.getValue());                    Date date = new Date(lastAccessTime);                    out.write(date.toLocaleString());                }            }        }else {            out.write(&quot;这是您第一次访问本站！&quot;);        }        //用户访问过之后重新设置用户的访问时间，存储到cookie中，然后发送到客户端浏览器        Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis()+&quot;&quot;);//创建一个cookie，cookie的名字是lastAccessTime        //将cookie对象添加到response对象中，这样服务器在输出response对象中的内容时就会把cookie也输出到客户端浏览器        response.addCookie(cookie);    }    public void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doGet(request, response);    }}</code></pre><h5 id="3-Cookie的安全性"><a href="#3-Cookie的安全性" class="headerlink" title="3.Cookie的安全性"></a>3.Cookie的安全性</h5><p>Cookie的目的是为用户带来方便，为网站带来增值，一般情况下不会造成严重的安全威胁。Cookie文件不能作为代码执行，也不会传送病毒，它为用户所专有并只能由创建它的服务器来读取。另外，浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为3KB，因此，Cookie不会塞满硬盘，更不会被用作”拒绝服务”攻击手段。</p><p>但是，Cookie作为用户身份的替代，其安全性有时决定了整个系统的安全性，Cookie的安全性问题不容忽视。</p><p>(1)Cookie欺骗</p><p>Cookie记录了用户的帐户ID、密码之类的信息，通常使用MD5方法加密后在网上传递。经过加密处理后的信息即使被网络上一些别有用心的人截获也看不懂。然而，现在存在的问题是，截获Cookie的人不需要知道这些字符串的含义，只要把别人的Cookie向服务器提交，并且能够通过验证，就可以冒充受害人的身份登陆网站，这种行为叫做Cookie欺骗。<br>非法用户通过Cookie欺骗获得相应的加密密钥，从而访问合法用户的所有个性化信息，包括用户的E-mail甚至帐户信息，对个人信息造成严重危害。<br>(2)Cookie截获<br>Cookie以纯文本的形式在浏览器和服务器之间传送，很容易被他人非法截获和利用。任何可以截获Web通信的人都可以读取Cookie。<br>Cookie被非法用户截获后，然后在其有效期内重放，则此非法用户将享有合法用户的权益。例如，对于在线阅读，非法用户可以不支付费用即可享受在线阅读电子杂志。</p><h3 id="二、Session"><a href="#二、Session" class="headerlink" title="二、Session"></a>二、Session</h3><h5 id="1-什么是Session"><a href="#1-什么是Session" class="headerlink" title="1.什么是Session"></a>1.什么是Session</h5><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个Session的时候，服务器首先检查这个客户端的请求里是否已包含了一个Session标识，称为SessionId，如果已包含一个SessionId则说明以前已经为此客户端创建过Session，服务器就按照SessionId把这个Session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含SessionId，则为此客户端创建一个Session并且生成一个与此Session相关联的SessionId，SessionId的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个SessionId将被在本次响应中返回给客户端保存。 保存这个SessionId的方式可以采用Cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。 </p><h5 id="2-Session的使用"><a href="#2-Session的使用" class="headerlink" title="2.Session的使用"></a>2.Session的使用</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String getId()</td><td>获取<code>SessionID</code>值</td></tr><tr><td>public void setAttribute()</td><td>设置属性</td></tr><tr><td>public Object getAttribute()</td><td>获取属性</td></tr><tr><td>public void removeAttribute()</td><td>移除属性</td></tr><tr><td>public []String getAllAttributeNames()</td><td>获取所有的属性名</td></tr><tr><td>public int getMaxInactiveInterval()</td><td>获取最长到期时间</td></tr><tr><td>public void setMaxInactiveInterval()</td><td>设置最长到期事件</td></tr><tr><td>public void  invalidate()</td><td>使该<code>Session</code>对象失效</td></tr><tr><td>public long getCreationTime()</td><td>获取创建时间</td></tr><tr><td>public long getLastAccessedTime()</td><td>获取上次访问时间</td></tr></tbody></table><p>已下是Session使用的一个例子</p><pre><code>//使用Session保存数据public class Demo01 extends HttpServlet {        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            response.setContentType(&quot;text/html;charset=UTF-8&quot;);            request.setCharacterEncoding(&quot;UTF-8&quot;);            // 获取参数            String username = request.getParameter(&quot;username&quot;);            // 获取session对象            HttpSession session = request.getSession();            // 保存数据            session.setAttribute(&quot;username&quot;, username);            // 打印SessionID            System.out.println(session.getId());        }        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            doGet(request, response);        }}//测试获取Session域中的数据public class Demo02 extends HttpServlet {        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            response.setContentType(&quot;text/html;charset=UTF-8&quot;);            request.setCharacterEncoding(&quot;UTF-8&quot;);            HttpSession session = request.getSession();            String username = (String)session.getAttribute(&quot;username&quot;);            // 响应到网页上            response.getWriter().write(username + &quot; &quot; + session.getId());        }        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            doGet(request, response);        }}</code></pre><h3 id="三、Cookie和Session的区别"><a href="#三、Cookie和Session的区别" class="headerlink" title="三、Cookie和Session的区别"></a>三、Cookie和Session的区别</h3><p>1.Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie是把用户的数据写在用户本地浏览器上, 其他网站也可以扫描使用你的Cookie，容易泄露自己网站用户的隐私，而且一般浏览器对单个网站站点有Cookie数量与大小的限制，Cookie也是实现Session的一种方式。 </p><p>2.Session 的运行依赖SessionId，而SessionId 是存在Cookie中的，也就是说，如果浏览器禁用了Cookie ，同时 Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 SessionId） 。</p><p>3.一般情况，登录信息等重要信息存储在Session中，其他信息存储在Cookie中 。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂方法模式&amp;抽象工厂模式</title>
      <link href="/2018/08/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F&amp;%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F&amp;%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>先介绍工厂方法模式和抽象工厂模式，这是23种设计模式的其中两种。不过在此之前我想先说说简单工厂模式，它不属于23种设计模式，却是今天要说的两种设计模式的入门。</p><h3 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h3><p>我们刚开始写代码的时候，如果需要一个类的对象，我们习惯利用关键字new把它直接创建出来，其实这并不是一个好习惯，因为这样不得已把对象的创建和使用绑定在一起，造成对象类和客户端代码非常高的耦合度，这无疑是我们不想看到的结果，那应该怎么办？简单工厂模式在一定程度上能解决这个问题。</p><p>简单工厂模式是<strong>由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。 </p><p>上面是定义，现在看不懂没关系，下面我来举例。市面上手机有各种各样的品牌，华为，小米，oppo等，不同场景下我们需要的手机品牌不同，那我们要怎么定义这个手机类？有些人可能觉得直接根据品牌定义类就好，华为一个类小米一个类这样，但仔细思考后会发现这样并不可取，因为手机品牌虽然不同，但很多功能都是类似的，重复的代码尽量不要写，这也是我们编码的原则之一，比较好的方法是定义一个抽象的手机类，如下</p><pre><code>abstract class Phone {    //所有手机都有的功能，这里我举打电话这个例子    public void call() {        //具体实现省略    }    //不同品牌手机不同的功能    public abstract void method();}</code></pre><p>然后在根据具体手机品牌定义各自的类</p><pre><code>//华为class HUAWEI extends Phone {    public void method() {    //具体实现    }}//小米class XiaoMi extends Phone {    public void method() {    //具体实现    }}...</code></pre><p>这样定义结束后，如果我们需要使用不同品牌的手机对象，根据简单工厂模式我们还需要定义一个工厂类</p><pre><code>class Factory {    //静态工厂方法，返回不同手机品牌对象    public static Phone getPhone(String type) {        Phone phone = null;        if(type.equals(&quot;HUAWEI&quot;)) {            phone = new HUAWEI();        } else if(type.equals(&quot;XiaoMi&quot;)) {            phone = new XiaoMi();        } else {            //...        }        return phone;    }}</code></pre><p>有了这个工厂类我们创建对象就方便了，以下是客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        Phone myPhone1 = Factory.getPhone(&quot;XiaoMi&quot;);        Phone myPhone2 = Factory.getPhone(&quot;HUAWEI&quot;);    }}</code></pre><p>这就是简单工厂模式的常用场景，你发现没，利用简单工厂模式我们很自然地将对象的创建与使用分开（创建交给工厂类，使用在客户端代码中），看完这个例子再看它的定义，会清楚很多，如果你理解了，那恭喜你可以继续学习工厂方法模式了，如果还是不懂的话不建议继续往下看，请多看相关的其他文章。</p><h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p>简单工厂模式固然简单，但是也有问题，如果我们需要一个手机品牌（例如三星），而工厂类中没有相应的创建代码怎么办？我们就不得不修改我们的工厂类，但是这样就违背了我们的开闭原则，如何在新增手机品牌的情况下而不修改源代码？这时候工厂方法模式就出现了。</p><p>工厂方法模式在简单工厂模式上做出了改进，意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 </p><p>按照上面说的我们只要将Factory类做些改动，把它变成一个接口</p><pre><code>interface Factory {    public Phone getPhone();}</code></pre><p>然后根据不同手机品牌编写对应的品牌工厂类</p><pre><code>//小米class XiaoMiFactory implements Factory {    public Phone getPhone() {        return new XiaoMi();    }}//三星class SAMSUNGFactory implements Factory {    public Phone getPhone() {        return new SAMSUNG();    }}...</code></pre><p>把工厂类改写成接口，将实际创建工作推迟到子类当中，这样我们需要什么手机品牌的对象，写个品牌工厂实现工厂类接口就行了，不就解决了新手机品牌的问题。不得不说早期提出设计模式的大牛们是多厉害，仰望一下。好了，下面是使用工厂方法模式后的客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        Factory factory = null;        factory = new SAMSUNGFactory();        Phone myPhone = factory.getPhone();    }}</code></pre><h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p>接着我们上面的例子，手机有各式的品牌，然而每个手机品牌也不止只生产手机，比如小米还有充电宝，空气净化器等等，如果都为它们创建工厂类可能会导致系统中存在大量工厂类，这样势必会产生系统开销，此时我们的抽象工厂模式运营而生。</p><h5 id="1-产品等级结构与产品族"><a href="#1-产品等级结构与产品族" class="headerlink" title="1.产品等级结构与产品族"></a>1.产品等级结构与产品族</h5><p>要理解抽象工厂模式，我们就要先来学习一下产品等级结构与产品族是什么。</p><img src="/2018/08/05/工厂方法模式&抽象工厂模式/抽象工厂模式-产品族与产品等级.jpg"><p>上图是产品族与产品等级结构示意图，产品等级结构是产品的继承结构，如我们的抽象类Phone，其子类有XiaoMi，HUAWEI，SAMSUNG，则Phone与XiaoMi,HUAWEI,SAMSUNG之间构成了一个产品等级结构。产品族是指由同一个工厂生产的，位于不同产品等级结构的同一组产品，如小米的手机，充电宝，空气净化器，它们各自属于不同的产品等级结构，因此它们属于一个产品族，即小米。</p><h5 id="2-抽象工厂模式举例"><a href="#2-抽象工厂模式举例" class="headerlink" title="2.抽象工厂模式举例"></a>2.抽象工厂模式举例</h5><p>如果利用工厂方法模式为小米华为的手机，充电宝和空气净化器都创建对象，一共需要6个工厂类，而抽象工厂模式简单许多，我们先为产品族新建一个抽象类（接口也行）</p><pre><code>abstract class AbstractFactory {    //为一个产品族创建不同产品等级结构的方法    public abstract Phone getPhone();    public abstract PowerBank getPowerBank();    public abstract AirPurifier getAirPurifier();}</code></pre><p>对于每个品牌，其代码如下</p><pre><code>//小米class XiaoMiFactory extends AbstractFactory {    public abstract Phone getPhone() {        return new XiaoMi();    }    public abstract PowerBank getPowerBank() {        return new XiaoMiPowerBank();    }    public abstract AirPurifier getAirPurifier() {        return new XiaoMiAirPurifier();    }}//华为class HUAWEIFactory extends AbstractFactory {    public abstract Phone getPhone() {        return new HUAWEI();    }    public abstract PowerBank getPowerBank() {        return new HUAWEIPowerBank();    }    public abstract AirPurifier getAirPurifier() {        return new HUAWEIAirPurifier();    }}</code></pre><p>做到这样就可以了，两个产品族我们只要两个具体工厂类，一个抽象工厂类，是不是比工厂方法模式简单？下面是客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        AbstractFactory factory = null;        factory = new XiaoMiFactory();        Phone myPhone = factory.getPhone();        PowerBank myPower = factory.getPowerBank();    }}</code></pre><h5 id="3-与工厂方法模式的对比"><a href="#3-与工厂方法模式的对比" class="headerlink" title="3.与工厂方法模式的对比"></a>3.与工厂方法模式的对比</h5><p>抽象工厂模式的使用就是上面这样，下面我们来将它与工厂方法模式做个对比</p><table><thead><tr><th>工厂方法模式</th><th>抽象工厂模式</th></tr></thead><tbody><tr><td>针对的是一个产品等级结构</td><td>针对的是多个产品等级结构</td></tr><tr><td>一个抽象产品类</td><td>多个抽象产品类</td></tr><tr><td>每个抽象产品类可以派生出多个具体产品类</td><td>每个抽象产品类可以派生出多个具体产品类</td></tr><tr><td>一个抽象工厂类，可以派生出多个具体工厂类</td><td>一个抽象工厂类，可以派生出多个具体工厂类</td></tr><tr><td>每个具体工厂类只能创建一个具体产品类的实例</td><td>每个具体工厂类可以创建多个具体产品类的实例</td></tr></tbody></table><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。 </p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式起篇</title>
      <link href="/2018/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E7%AF%87/"/>
      <url>/2018/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>今天挖坑，来讲讲我们23种设计模式，设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。虽然如此，但是滥用设计模式很可能会造成与自己预期相反的结果，所以我在起篇先给自己和大家提个醒，<strong>设计模式是经验总结，不是公理公式 ，要为实现需求而编码，而不是为使用设计模式而编码 ！</strong></p><h3 id="一、设计模式的六大原则"><a href="#一、设计模式的六大原则" class="headerlink" title="一、设计模式的六大原则"></a>一、设计模式的六大原则</h3><p>总原则：开闭原则，即对扩展开放，对修改关闭。 </p><h5 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h5><p>每个类应该实现单一的职责，否则应该把类拆分。 </p><h5 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2.里氏替换原则"></a>2.里氏替换原则</h5><p>任何基类可以出现的地方，子类一定可以出现。它是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 </p><h5 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h5><p>这是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。 </p><h5 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4.接口隔离原则"></a>4.接口隔离原则</h5><p>使用多个隔离的接口，比使用单个接口要好。每个接口不存在子类用不到却必须实现的方法，否则要将接口拆分。 </p><h5 id="5-迪米特法则（最少知道原则）"><a href="#5-迪米特法则（最少知道原则）" class="headerlink" title="5.迪米特法则（最少知道原则）"></a>5.迪米特法则（最少知道原则）</h5><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统的功能模块相对独立。 </p><h5 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6.合成复用原则"></a>6.合成复用原则</h5><p>尽量使用合成/聚合方式，而不是使用继承。</p><h3 id="二、设计模式的三大类"><a href="#二、设计模式的三大类" class="headerlink" title="二、设计模式的三大类"></a>二、设计模式的三大类</h3><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>好了，起篇就先有这么多，下一篇开始正式讲我们的23种设计模式，以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p><p>参考文章：<a href="https://my.oschina.net/tiancai/blog/224624" target="_blank" rel="noopener">Java开发中的23种设计模式详解</a></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Servlet总结</title>
      <link href="/2018/08/03/Servlet/"/>
      <url>/2018/08/03/Servlet/</url>
      <content type="html"><![CDATA[<p>这几天忙着玩忙着睡都没有更博，不过也稍微计划了下大概要写些什么，具体就不说了，我不画大饼，没做到尴尬。。</p><p>写技术博客也不是想给谁看，就是个人总结和复习，也当做笔记，以后忘了什么知识点可以来看看，仅此而已。行了，废话也不说了，来说说我们的Servlet。</p><h3 id="一、什么是Servlet"><a href="#一、什么是Servlet" class="headerlink" title="一、什么是Servlet"></a>一、什么是Servlet</h3><p>Servlet是什么？”狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。“这是百度上说的，以我的理解，Servlet就是一个Java接口，是一套处理网络请求的规范 ，我们平时写的Servlet必须实现刚刚那个接口，按它的规范完成我们的编写，这样完成的Java类我们管它叫自己的Servlet。</p><p>好的，Servelt既然是一个接口，那具体是怎样的接口呢，下图详细地解释了Servlet体系与各自的方法。</p><img src="/2018/08/03/Servlet/servlet1.png"><p>每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是的init()，service()，destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet，它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet()方法，如为Post请求，则调用doPost()方法。所以我们在编写Servlet时，通常只需要覆写doGet()或doPost()方法。 </p><h3 id="二、Servlet生命周期"><a href="#二、Servlet生命周期" class="headerlink" title="二、Servlet生命周期"></a>二、Servlet生命周期</h3><p>说到Servlet不提它的生命周期显然是不行的，要掌握Servlet这个是重点，那么Servlet工作流程分为以下几个阶段：</p><h5 id="1-加载和实例化"><a href="#1-加载和实例化" class="headerlink" title="1.加载和实例化"></a>1.加载和实例化</h5><p>当检测到需要Servlet的第一个请求时，读取xml文件找到要加载的servlet类，创建Servlet实例。 加载一般是在运行Servlet容器时来完成，将servlet类加载到tomcat中，或者是客户端发来请求时也可以。</p><h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h5><p>初始化信息一般是读取配置信息、读取初始化参数等，对于每一个servlet实例，init()方法值被调用一次。</p><h5 id="3-请求处理"><a href="#3-请求处理" class="headerlink" title="3.请求处理"></a>3.请求处理</h5><p>调用Servlet的service()方法对请求进行处理，在调用该方法之前，init()方法必须先成功执行。根据请求的到来，service()方法决定请求的请求，常用的是doGet()或doPost()。</p><h5 id="4-销毁"><a href="#4-销毁" class="headerlink" title="4.销毁"></a>4.销毁</h5><p>销毁一般是Servlet的卸载是由容器本身定义和实现，在destroy()方法调用后，容器释放对应的Servlet请求。实例随后会被Java的垃圾收集器所回收，整个Servlet的生命周期结束。一般tomcat关闭，servlet就会被销毁。</p><p>Servlet没有main方法，所有行为由Servlet容器控制，我们最常见的Servlet容器就是Tomcat了。整个流程如下图：</p><img src="/2018/08/03/Servlet/servlet2.jpg"><p>（图来自《Head First Servlets &amp; JSP》，逸夫有，是本入门经典 ，推荐！ ）</p><h3 id="三、servlet配置及其含义"><a href="#三、servlet配置及其含义" class="headerlink" title="三、servlet配置及其含义"></a>三、servlet配置及其含义</h3><p>servlet配置在项目的web.xml下，这里其实最想说的是配置中各节点的含义： </p><pre><code>&lt;!-- 配置一个servlet --&gt;&lt;!-- servlet的配置 --&gt;&lt;servlet&gt;    &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!-- servlet的类全名： 包名+简单类名 --&gt;    &lt;servlet-class&gt;lm.practice.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt;    &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!-- servlet的映射路径（访问servlet的名称） --&gt;    &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p> 可以看到，在配置Servlet时，有两个地方需要配置，一个是&lt;servlet&gt;,另一个是&lt;servlet-Mapping&gt;，这两个一个是配置Servlet，一个是配置其映射信息，其中&lt;servlet&gt;中的&lt;servlet-name&gt;可以随意指定，但要有一定的意义，一般取为类的名称，例如我的类名为ServletDemo，这里取名为ServletDemo,下面的&lt;servlet-class&gt;是类的全路径 ，一定要是全路径！ </p><p>&lt;servlet-Mapping&gt;是映射信息，它也有一个&lt;servlet-name&gt;，里面的名字是对应的Servlet名，也就是我们上面配置的Servlet名字，这里是ServletDemo，下面的是映射路径，也就是访问Servlet的名称，这里也是以方便和有意义为前提的，是我们在访问Servlet在浏览器地址栏后面输入的那个信息。</p><p>注意：这里的映射路径一定不是丢掉/，否则就会出错了，一定要写成/servlet，不能是servlet。</p><p>行了，关于Servlet的知识点目前就想到这么多，其实还有九大内置对象，四个作用域什么的，大家想了解可以参考这个帖子，<a href="https://www.cnblogs.com/sunli0205/p/5896980.html" target="_blank" rel="noopener">了解一下</a>。以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/28/Hello%20World/"/>
      <url>/2018/07/28/Hello%20World/</url>
      <content type="html"><![CDATA[<p>搭建个人博客的想法一直都有，算起来断断续续也有一年了吧。</p><p>今天心血来潮说做就做了，想起来会很难，但实际做完了才知道其实也挺简单的。东拼西凑，如你所见，博客的雏形大概就出来了。也算完成一个小目标？</p><p>今天是18年7月28日，我的大二暑假快要过半了，而我现在还在整合ssm框架，争取在这个暑假结束时熟悉ssm项目的结构，建立流程以及Maven的使用，能顺便了解一下SpringCloud或者SpringBoot最好，这样我也不算虚度这一个多月。</p><p>很惭愧，还要继续完善这个博客，所以第一篇就写得简单了些，只想再努力些，再加油些，Hello World！</p>]]></content>
      
      <categories>
          
          <category> 个人日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
