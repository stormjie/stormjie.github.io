<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>单例模式</title>
      <link href="/2018/08/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="一、单例模式动机"><a href="#一、单例模式动机" class="headerlink" title="一、单例模式动机"></a>一、单例模式动机</h3><p>对于系统中的某些类来说，只有一个实例很重要， 如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。 </p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。 </p><h3 id="二、单例模式概述"><a href="#二、单例模式概述" class="headerlink" title="二、单例模式概述"></a>二、单例模式概述</h3><p>让我们来用单例模式的思想模拟实现任务管理器，下面是具体代码</p><pre><code>public class TaskManager {    //TaskManager提供的唯一实例    private static TaskManager tm = null;    //私有构造方法使外部类无法使用new关键字创建TaskManager实例    private TaskManager() {        ...    }    //该方法用于给外部类返回TaskManager唯一实例    public static TaskManager getInstance() {        if(tm == null) {            tm = new TaskManager();        }        return tm;    }     //任务管理器功能方法    public void display() {        ...    }} </code></pre><p>为什么getInstance()方法要定义为静态方法？因为外部类需要调用getInstance()方法得到唯一TaskManager实例，而调用非成员方法只有两种方式，通过对象调用或者类调用，对象调用肯定不行（我们调用getInstance()方法目的就是要得到对象，就是缺对象），所以只能通过TaskManager类调用，而类只能调用静态成员方法，所以必须将getInstance()定义为静态。</p><p>上述代码是单例模式的一种典型实现方式，理解之后我们再来看看单例模式的定义：<strong>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个类实例，这个类称为单例类，它提供全局访问的方法。</strong></p><p>单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 </p><h3 id="三、饿汉式单例与懒汉式单例"><a href="#三、饿汉式单例与懒汉式单例" class="headerlink" title="三、饿汉式单例与懒汉式单例"></a>三、饿汉式单例与懒汉式单例</h3><h5 id="1-饿汉式单例类"><a href="#1-饿汉式单例类" class="headerlink" title="1.饿汉式单例类"></a>1.饿汉式单例类</h5><p>饿汉式单例类是实现起来最简单的单例类，在定义静态变量的时候马上实例化，因此类加载时候就已经创建单例对象，代码如下：</p><pre><code>public class EagerSingleton {    //唯一实例    private static EagerSingleton instance = new EagerSingleton();    //私有构造方法    private EagerSingleton(){}    //静态工厂方法    public static EagerSingleton getInstance() {        return instance;    }}</code></pre><p>在这个类被加载时，静态变量instance会被初始化，此时类的私有构造方法会被调用。这时候，单例类的唯一实例就被创建出来了。</p><p>饿汉式是典型的空间换时间，当类装载的时候就会创建类实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断了，节省了运行时间。 </p><h5 id="2-懒汉式单例类"><a href="#2-懒汉式单例类" class="headerlink" title="2.懒汉式单例类"></a>2.懒汉式单例类</h5><p>懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。 </p><pre><code>public class LazySingleton {    //唯一实例    private static LazySingleton instance = null;    //私有构造方法     private LazySingleton(){}    // 静态工厂方法    public static synchronized LazySingleton getInstance() {        if(instance == null){            instance = new LazySingleton();        }        return instance;    }}</code></pre><p>上面的懒汉式单例类实现里对静态工厂方法使用了同步化，以处理多线程环境。 由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。所以对比饿汉式，懒汉式是时间换空间，那么有没有更好的方式实现呢？ </p><h5 id="3-双重检查加锁"><a href="#3-双重检查加锁" class="headerlink" title="3.双重检查加锁"></a>3.双重检查加锁</h5><p>可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。那么什么是“双重检查加锁”机制呢？</p><p>所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance()方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</p><p>“双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</p><pre><code>public class Singleton {    //唯一实例    private volatile static Singleton instance = null;    //私有构造方法    private Singleton(){}    // 静态工厂方法    public static Singleton getInstance(){        //先检查实例是否存在，如果不存在才进入下面的同步块        if(instance == null){            //同步块，线程安全的创建实例            synchronized (Singleton.class) {                //再次检查实例是否存在，如果不存在才真正的创建实例                if(instance == null){                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre><p>这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。 </p><p>提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。 </p><h5 id="4-饿汉式单例类与懒汉式单例类的比较"><a href="#4-饿汉式单例类与懒汉式单例类的比较" class="headerlink" title="4.饿汉式单例类与懒汉式单例类的比较"></a>4.饿汉式单例类与懒汉式单例类的比较</h5><p>饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长(考虑简单，性能略低)。</p><p>懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响(考虑复杂，资源利用效率高)。</p><h3 id="三、更好的实现方式"><a href="#三、更好的实现方式" class="headerlink" title="三、更好的实现方式"></a>三、更好的实现方式</h3><p>根据上面的分析，常见的两种单例实现方式都存在小小的缺陷，那么有没有一种方案，既能实现延迟加载，又能实现线程安全呢？ </p><h5 id="1-Lazy-initialization-holder-class模式"><a href="#1-Lazy-initialization-holder-class模式" class="headerlink" title="1.Lazy initialization holder class模式"></a>1.Lazy initialization holder class模式</h5><p>大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括：</p><p>(1)由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</p><p>(2)访问final字段时</p><p>(3)在创建线程之前创建对象时</p><p>(4)线程可以看见它将要处理的对象时</p><p>要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。</p><p>如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。示例代码如下：</p><pre><code>public class Singleton {    private Singleton(){}    /**     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。     */    private static class SingletonHolder{        // 静态初始化器，由JVM来保证线程安全        private static Singleton instance = new Singleton();    }    public static Singleton getInstance() {        return SingletonHolder.instance;    }}</code></pre><p>当getInstance()方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。</p><p>这个模式的优势在于，getInstance()方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。</p><h5 id="2-单元素枚举单例"><a href="#2-单元素枚举单例" class="headerlink" title="2.单元素枚举单例"></a>2.单元素枚举单例</h5><p>单例的枚举实现在《Effective Java》中有提到，因为其功能完整、使用简洁、无偿地提供了序列化机制、在面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化等优点，单元素的枚举类型被作者认为是实现单例模式的最佳方法。 </p><p> 用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。 </p><pre><code>public enum Singleton {    // 定义一个枚举的元素，它就代表了Singleton的一个实例    uniqueInstance;    // 单例可以有自己的操作    public void singletonOperation(){        //功能处理    }}</code></pre><p>使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 </p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVC模式与三层架构</title>
      <link href="/2018/08/11/MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/08/11/MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>很多基础不好的人总是把MVC和三层架构混为一谈，并不了解它们的区别是什么，甚至以为是一种东西，现在我就具体讲讲，也复习一下。</p><h3 id="一、MVC模式"><a href="#一、MVC模式" class="headerlink" title="一、MVC模式"></a>一、MVC模式</h3><h5 id="1-Model1-JSP-JavaBean"><a href="#1-Model1-JSP-JavaBean" class="headerlink" title="1.Model1(JSP + JavaBean)"></a>1.Model1(JSP + JavaBean)</h5><p>之前说了JSP，我们知道在JSP中可以写Java代码，那仔细想想，这JSP不是很棒棒，一方面可以负责界面显示，一方面又可以负责处理业务逻辑和流程控制 。那项目只写JSP和JavaBean不就好了，还有Servlet什么事，实际上在早期的JavaWeb应用中， 开发人员也是这么做的。这就是Model1模型。</p><img src="/2018/08/11/MVC模式与三层架构/model1.png"><p>上面是Model1的流程图，在Model1模型中，是以JSP为中心，它既要做页面显示，又要负责业务逻辑处理和流程控制，对于单一职责的原则来说，这显然不符合，JSP的职责太重，就显得中间部分有些臃肿 。因此Model1不适合开发复杂的大型应用程序。 </p><h5 id="2-Model2-Servlet-JSP-JavaBean"><a href="#2-Model2-Servlet-JSP-JavaBean" class="headerlink" title="2.Model2(Servlet + JSP + JavaBean)"></a>2.Model2(Servlet + JSP + JavaBean)</h5><p>因为Model1的缺点太过明显，在Model1的基础上，Model2对JSP的任务进行分离，将获取参数，流程控制这些和页面显示无关的转到Servlet处理，JSP只做显示即可。</p><img src="/2018/08/11/MVC模式与三层架构/model2.png"><p>在Model2中，JSP只负责界面显示，Servlet负责应用的处理过程控制 ，JavaBean负责对数据库操作的类。但是相对于Model1，Model2对程序员的要求要高，各部分之间分工明确，各司其职。结果是开发的粒度较细，代码的复用性提高了，后期维护也容易了，所以Model2比较适合大型项目的开发。 </p><h5 id="3-MVC模式是什么"><a href="#3-MVC模式是什么" class="headerlink" title="3.MVC模式是什么"></a>3.MVC模式是什么</h5><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。最典型的MVC就是上面说的Model2模型，其实究起来，Model1也实现了MVC模式，只不过view和controller两个角色都由JSP来扮演，实现得并不彻底。</p><p>model:常用JavaBean去实现，通过各种类来对数据库的数据进行获取，并封装在对象当中。</p><p>view:常用JSP来实现，通过可直接观察的JSP页面来展示我们从数据库中获取的数据。</p><p>controller:常用Servlet来实现，用来接收用户提交的请求，然后获取请求中的数据，将之转换为业务模型需要的数据模型，然后调用业务模型相应的业务方法进行更新，同时根据业务执行结果来选择要返回的视图。</p><h3 id="二、三层架构"><a href="#二、三层架构" class="headerlink" title="二、三层架构"></a>二、三层架构</h3><h5 id="1-三层架构是什么"><a href="#1-三层架构是什么" class="headerlink" title="1.三层架构是什么"></a>1.三层架构是什么</h5><p>通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层、表现层，如图所示</p><img src="/2018/08/11/MVC模式与三层架构/三层架构.jpg"><h5 id="2-各层次的任务"><a href="#2-各层次的任务" class="headerlink" title="2.各层次的任务"></a>2.各层次的任务</h5><p>表现层（UI）：表现层可以说是距离用户最近的层，主要是用于接收用户输入的数据和显示处理后用户需要的数据。一般表现为界面，用户通过界面输入查询数据和得到需要的数据。</p><p>业务逻辑层（BLL）：业务逻辑层是处于表现层和数据访问层之间，主要是从数据库中得到数据然后对数据进行逻辑处理。</p><p>数据访问层（DAL）：数据访问层是直接和数据库打交道的，对数据进行“增、删、改、查”等基本的操作。</p><h5 id="3-与MVC模式的区别与联系"><a href="#3-与MVC模式的区别与联系" class="headerlink" title="3.与MVC模式的区别与联系"></a>3.与MVC模式的区别与联系</h5><p>(1)区别：首先，它们根本不是一个概念。三层架构是一个分层式的软件体系架构设计，它可适用于任何一个项目。MVC是一个架构模式，可以用它来创建在域对象和UI表示层对象之间的区分。在三层架构中没有定义Controller的概念，这是最不同的地方 。</p><p>(2)联系：网上谈到三层架构与MVC模式的联系时，主要有两种说法，我看了他们的观点，发现主要区别在于对MVC模式中model的功能的理解。</p><p>一种观点认为三层架构中每一层都有不同的架构模式，表示层最常用的架构模式就是MVC，而MVC中的model只是一些简单实体类。下面是基于这种观点的一个常见的J2EE项目结构（我一般也是这种结构）</p><ul><li>users.jsp (V)</li><li>UserController.java (C)</li><li>UserService.java (业务逻辑层)</li><li>UserDao.java (数据访问层)</li><li>User.java (M)</li></ul><p>另一种观点认为MVC模式内的view和controller组成了三层架构的表现层，而model的功能分业务逻辑层和数据访问层来实现，这时的model就不能只是简单实体类了，还必须包括逻辑处理类和数据访问类，如下图所示<br><img src="/2018/08/11/MVC模式与三层架构/mvc与三层架构.jpg"></p><p>发现没，刚刚提到的model2模型就是基于这个观点。</p><p>具体哪种正确我认为没有绝对的答案，两种观点我都理解，具体情况具体分析，况且实际开发中对这些理念也没纠结那么多，代码敲出来就完事了！以上是经过我自己理解及网上资料对MVC模式和三层架构的总结，如果有什么疑惑或者错误欢迎联系我。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVC模式 </tag>
            
            <tag> 三层架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSP总结</title>
      <link href="/2018/08/08/JSP%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/08/JSP%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>感觉自己三分钟热度要过去了，不想更博想偷懒了，以后不知道能不能做到一周二更，果然做个快乐肥宅太舒服了。。。废话不说，今天讲JSP，下面就开始吧。</p><h3 id="一、什么是JSP"><a href="#一、什么是JSP" class="headerlink" title="一、什么是JSP"></a>一、什么是JSP</h3><p>掌握了编写Servlet程序后，我们有能力让网页“动”起来——根据不同的输入（URL参数、Session等）生成不同的页面内容。但由于Web中大量用到HTML作为展示语言，在Servlet中去拼接HTML代码显然不是一个好办法。Java EE里制定的JSP标准，就是帮助开发者基于HTML/XML来动态生成Web页面内容。 </p><p>JSP全名为Java Server Pages，中文名叫Java服务器页面，其根本是一个简化的Servlet设计，它是由Sun提出的一种动态网页技术标准。在传统的网页HTML（标准通用标记语言的子集）文件中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件。  </p><p>本质上来说，JSP是Servlet的一个更高层的抽象。<strong>Servlet容器会将JSP在运行时转化为Servlet程序</strong>，接下来的处理流程就和Servlet完全一样了。</p><p>下面是一个最简单的一段jsp代码： </p><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;    &lt;title&gt;First Jsp&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;%        out.print(&quot;Hello Jsp&quot;);    %&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p> 对应的，Servlet容器将上面的JSP转化为Servlet如下：</p><pre><code>package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;import java.util.*;public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase    implements org.apache.jasper.runtime.JspSourceDependent {  private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();  private static java.util.List _jspx_dependants;  private javax.el.ExpressionFactory _el_expressionfactory;  private org.apache.AnnotationProcessor _jsp_annotationprocessor;  public Object getDependants() {    return _jspx_dependants;  }  public void _jspInit() {    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();    _jsp_annotationprocessor = (org.apache.AnnotationProcessor) getServletConfig().getServletContext().getAttribute(org.apache.AnnotationProcessor.class.getName());  }  public void _jspDestroy() {  }  public void _jspService(HttpServletRequest request, HttpServletResponse response)        throws java.io.IOException, ServletException {    PageContext pageContext = null;    HttpSession session = null;    ServletContext application = null;    ServletConfig config = null;    JspWriter out = null;    Object page = this;    JspWriter _jspx_out = null;    PageContext _jspx_page_context = null;    try {      response.setContentType(&quot;text/html;charset=UTF-8&quot;);      pageContext = _jspxFactory.getPageContext(this, request, response,                  null, true, 8192, true);      _jspx_page_context = pageContext;      application = pageContext.getServletContext();      config = pageContext.getServletConfig();      session = pageContext.getSession();      out = pageContext.getOut();      _jspx_out = out;      out.write(&#39;\r&#39;);      out.write(&#39;\n&#39;);String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;      out.write(&quot;\r\n&quot;);      out.write(&quot;\r\n&quot;);      out.write(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;\r\n&quot;);      out.write(&quot;&lt;html&gt;\r\n&quot;);      out.write(&quot;  &lt;head&gt;\r\n&quot;);      out.write(&quot;    &lt;base href=\&quot;&quot;);      out.print(basePath);      out.write(&quot;\&quot;&gt;\r\n&quot;);      out.write(&quot;    \r\n&quot;);      out.write(&quot;    &lt;title&gt;First Jsp&lt;/title&gt;\r\n&quot;);      out.write(&quot;\t\r\n&quot;);      out.write(&quot;  &lt;/head&gt;\r\n&quot;);      out.write(&quot;  \r\n&quot;);      out.write(&quot;  &lt;body&gt;\r\n&quot;);      out.write(&quot;    &quot;);        out.print(&quot;Hello Jsp&quot;);      out.write(&quot;\r\n&quot;);      out.write(&quot;  &lt;/body&gt;\r\n&quot;);      out.write(&quot;&lt;/html&gt;\r\n&quot;);    } catch (Throwable t) {      if (!(t instanceof SkipPageException)){        out = _jspx_out;        if (out != null &amp;&amp; out.getBufferSize() != 0)          try { out.clearBuffer(); } catch (java.io.IOException e) {}        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);      }    } finally {      _jspxFactory.releasePageContext(_jspx_page_context);    }  }}</code></pre><h3 id="二、JSP运行原理"><a href="#二、JSP运行原理" class="headerlink" title="二、JSP运行原理"></a>二、JSP运行原理</h3><p>当客户端浏览器向服务器发出访问一个JSP页面的请求时，服务器根据该请求加载相应的JSP页面，并对该页面进行编译，然后执行。JSP页面的执行过程如下图所示：</p><img src="/2018/08/08/JSP总结/JSP1.png"><p>1.当用户访问一个JSP页面时，会向一个Servlet容器（Tomcat等）发出请求。</p><p>2.服务器根据接收到的客户端的请求来加载相应的JSP文件。</p><p>3.Web服务器中的JSP引擎会将被加载的JSP文件转化为Servlet(.java文件)。</p><p>4.JSP引擎将生成的Servlet代码编译成.class文件。</p><p>5.服务器执行这个.class文件， 将执行结果发送给浏览器进行显示。 </p><p>并不是每次请求都需要重复进行这样的处理。当服务器第一次接收到对某个页面的请求时，JSP引擎就开始按照上述的处理过程来将被请求的JSP文件编译成.class文件。当再次对该页面进行请求时，如果该页面没有任何改动，服务器就会直接调用对应的.class文件来执行，因此当某个JSP页面第一次被请求时，会有一些延迟，而再次访问时会感觉速度快了很多。如果被请求的页面经过了修改，那么服务器会重新编译这个文件，然后再执行。 </p><h3 id="三、JSP基础语法"><a href="#三、JSP基础语法" class="headerlink" title="三、JSP基础语法"></a>三、JSP基础语法</h3><h5 id="1-JSP表达式"><a href="#1-JSP表达式" class="headerlink" title="1.JSP表达式"></a>1.JSP表达式</h5><p>JSP表达式用于向页面中输出信息，其语法格式如下：</p><p><code>&lt;%= expression %&gt;</code></p><p>参数说明：</p><p>expression：可以是任何Java语言的完整表达式，该表达式的最终运算结果将被转换为字符串。</p><p>需要注意 : </p><p>(1)JSP 的表达式中没有分号 !</p><p>(2)”%=” 间不能有空格</p><p>程序示例： </p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;   今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; </code></pre><h5 id="2-JSP脚本片断"><a href="#2-JSP脚本片断" class="headerlink" title="2.JSP脚本片断"></a>2.JSP脚本片断</h5><p>JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码，其语法格式如下：</p><pre><code>&lt;%         　　　    多行java代码  　　　%&gt;</code></pre><p>需要注意 : </p><p>(1)在&lt;% %&gt;中可以定义变量，编写语句，不能定义方法。</p><p>(2)JSP脚本片断中只能出现java代码，不能出现其它模板元素，JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。</p><p>(3)在一个JSP页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。</p><p>(4)JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须用分号结束。</p><p>程序示例：</p><pre><code>&lt;%    int sum=0;     for(int i=1;i&lt;=100;i++) {        sum+=i;    }    out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);%&gt;</code></pre><h5 id="3-JSP声明"><a href="#3-JSP声明" class="headerlink" title="3.JSP声明"></a>3.JSP声明</h5><p>JSP页面中编写的所有代码，默认会翻译到Servlet的service方法中， 而JSP声明中的Java代码被翻译到_jspService方法的外面，其语法格式如下：</p><pre><code>&lt;% !        　　　    Java代码  　　　%&gt;</code></pre><p>需要注意 : </p><p>(1)声明以 “&lt;%!” 开头 , 以 “%&gt;” 结尾 , “%!” 必须紧挨。</p><p>(2)多个静态代码块，变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。JSP隐式对象的作用范围仅限于Servlet的_jspService方法，所以在JSP声明中不能使用这些隐式对象。</p><p>程序示例：</p><pre><code>&lt;%! int i = 0; %&gt; &lt;%! int a, b, c; %&gt; &lt;%! Circle a = new Circle(2.0); %&gt;</code></pre><h5 id="4-JSP注释"><a href="#4-JSP注释" class="headerlink" title="4.JSP注释"></a>4.JSP注释</h5><p>JSP 程序的注释有隐藏注释、HTML 注释、Java 语言注释</p><p>(1)隐藏注释是 JSP 的标准注释 , 在编写 JSP 程序中 , 在发布网页时完全被忽略, 不发送至客户端。</p><p>语法格式如下 :</p><p><code>&lt;%-- comment --%&gt;</code> </p><p>comment 为被注释内容</p><p>(2)HTML 注释在发布网页时可以在浏览器文件窗口中看到 HTML 注释 , 在这种注释中 , 也可以使用 JSP 的表达式。</p><p>语法格式如下 :</p><p><code>&lt;!-- comment [&lt;%=expression%&gt;]--&gt;</code>　　</p><p>comment 为被注释内容</p><p>(3)Java 注释和隐藏注释相似 , 在浏览器的源文件窗口中也看不到注释内容。</p><p>语法格式如下:</p><p><code>&lt;%// 单行注释 %&gt;</code></p><p><code>&lt;%/* 多行注释 */%&gt;</code></p><h5 id="5-JSP指令"><a href="#5-JSP指令" class="headerlink" title="5.JSP指令"></a>5.JSP指令</h5><p>JSP指令用来设置与整个JSP页面相关的属性。</p><p>JSP指令语法格式：</p><p><code>&lt;%@ directive attribute=&quot;value&quot; %&gt;</code></p><p>这里有三种指令标签：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>&lt;%@ page … %&gt;</td><td>定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td></tr><tr><td>&lt;%@ include … %&gt;</td><td>包含其他文件</td></tr><tr><td>&lt;%@ taglib … %&gt;</td><td>引入标签库的定义，可以是自定义标签</td></tr></tbody></table><h5 id="6-JSP行为"><a href="#6-JSP行为" class="headerlink" title="6.JSP行为"></a>6.JSP行为</h5><p>JSP行为标签使用XML语法结构来控制Servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。</p><p>行为标签只有一种语法格式，它严格遵守XML标准：</p><p><code>&lt;jsp:action_name attribute=&quot;value&quot; /&gt;</code></p><p>行为标签基本上是一些预先就定义好的函数，下表罗列出了一些可用的JSP行为标签：</p><table><thead><tr><th><strong>语法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>jsp:include</td><td>用于在当前页面中包含静态或动态资源</td></tr><tr><td>jsp:useBean</td><td>寻找和初始化一个JavaBean组件</td></tr><tr><td>jsp:setProperty</td><td>设置 JavaBean组件的值</td></tr><tr><td>jsp:getProperty</td><td>将 JavaBean组件的值插入到 output中</td></tr><tr><td>jsp:forward</td><td>从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td></tr><tr><td>jsp:plugin</td><td>用于在生成的HTML页面中包含Applet和JavaBean对象</td></tr><tr><td>jsp:element</td><td>动态创建一个XML元素</td></tr><tr><td>jsp:attribute</td><td>定义动态创建的XML元素的属性</td></tr><tr><td>jsp:body</td><td>定义动态创建的XML元素的主体</td></tr><tr><td>jsp:text</td><td>用于封装模板数据</td></tr></tbody></table><h5 id="7-JSP隐含对象"><a href="#7-JSP隐含对象" class="headerlink" title="7.JSP隐含对象"></a>7.JSP隐含对象</h5><p>JSP支持九个自动定义的变量，江湖人称隐含对象。这九个隐含对象的简介见下表：</p><table><thead><tr><th><strong>对象</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>request</td><td><strong>HttpServletRequest</strong>类的实例</td></tr><tr><td>response</td><td><strong>HttpServletResponse</strong>类的实例</td></tr><tr><td>out</td><td><strong>PrintWriter</strong>类的实例，用于把结果输出至网页上</td></tr><tr><td>session</td><td><strong>HttpSession</strong>类的实例</td></tr><tr><td>application</td><td><strong>ServletContext</strong>类的实例，与应用上下文有关</td></tr><tr><td>config</td><td><strong>ServletConfig</strong>类的实例</td></tr><tr><td>pageContext</td><td><strong>PageContext</strong>类的实例，提供对JSP页面所有对象以及命名空间的访问</td></tr><tr><td>page</td><td>类似于Java类中的this关键字</td></tr><tr><td>Exception</td><td><strong>Exception</strong>类的对象，代表发生错误的JSP页面中对应的异常对象</td></tr></tbody></table><p>好了，JSP的内容有点多，我就先介绍到这里了，理论知识很多，记不住就多敲多看，有兴趣的可以再去网上看看EL表达式和自定义标签，但是我不建议花太多时间。以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p><p>参考文章：<a href="http://www.runoob.com/jsp/jsp-syntax.html" target="_blank" rel="noopener">菜鸟教程–JSP语法</a></p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java会话管理：Cookie和Session</title>
      <link href="/2018/08/07/Java%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9ACookie%E5%92%8CSession/"/>
      <url>/2018/08/07/Java%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9ACookie%E5%92%8CSession/</url>
      <content type="html"><![CDATA[<p>http是<strong>无状态</strong>的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。 </p><p>具体解释一下这个“无状态”：</p><ol><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li><p>人生若只如初见</p><p>这有个具体的生活例子说明了无状态http的不便性：</p></li></ol><p>当我们在一个购物网站上登陆自己的帐号后，我们便开始浏览商品，这时我们发现了心仪的商品，点进去打算看商品详情，发现竟然又要我们登陆帐号，为什么？因为无状态http请求无法保存我们用户信息，点击商品是一个请求，刚刚进入网站主页也是一个请求，这两个请求没有上下文联系，服务器无法判断这是同一个用户的请求，所以我们不得不再输入我们的账号密码，点击添加购物车，这也是一个请求，我们还是得输入帐号密码，还有其它商品操作，还有结算按钮。。。</p><p>没有会话管理技术会给我们生活带来多大不便从上个例子就可以略知一二，Java中我们有Cookie和Session来帮助我们解决这个麻烦。</p><h3 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h3><h5 id="1-什么是Cookie"><a href="#1-什么是Cookie" class="headerlink" title="1.什么是Cookie"></a>1.什么是Cookie</h5><p>“Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从： [系统盘]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。 ”这是百度百科上关于Cookie的解释，说得很明了也很详细，下图是利用Cookie与服务器交流的简图：</p><img src="/2018/08/07/Java会话管理：Cookie和Session/Cookie.png"><h5 id="2-Cookie的使用"><a href="#2-Cookie的使用" class="headerlink" title="2.Cookie的使用"></a>2.Cookie的使用</h5><p>如何使用Cookie？Java API关于Cookie提供了很多方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Cookie(String name, String value)</td><td>实例化<code>Cookie</code>对象，传入<code>Cookie</code>名称和<code>Cookie</code>的值</td></tr><tr><td>public String getName()</td><td>取得<code>Cookie</code>的名字</td></tr><tr><td>public String getValue()</td><td>取得<code>Cookie</code>的值</td></tr><tr><td>public void setValue(String newValue)</td><td>设置<code>Cookie</code>的值</td></tr><tr><td>public void setMaxAge(int expiry)</td><td>设置<code>Cookie</code>的最大保存时间，即<code>Cookie</code>的有效期</td></tr><tr><td>public int getMaxAge()</td><td>获取<code>Cookie</code>的有效期</td></tr><tr><td>public void setPath(String uri)</td><td>设置<code>Cookie</code>的有效路径</td></tr><tr><td>public String getPath()</td><td>获取<code>Cookie</code>的有效路径</td></tr><tr><td>public void setDomain(String pattern)</td><td>设置<code>Cookie</code>的有效域</td></tr><tr><td>public String getDomain()</td><td>获取<code>Cookie</code>的有效域</td></tr></tbody></table><p>已下是Cookie使用的一个例子，记录用户访问网站信息</p><pre><code>public class CookieServlet extends HttpServlet {    public void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        //设置服务器端以UTF-8编码进行输出        response.setCharacterEncoding(&quot;UTF-8&quot;);        //设置浏览器以UTF-8编码进行接收,解决中文乱码问题        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter out = response.getWriter();        //获取浏览器访问访问服务器时传递过来的cookie数组        Cookie[] cookies = request.getCookies();        //如果用户是第一次访问，那么得到的cookies将是null        if (cookies!=null) {            out.write(&quot;您上次访问的时间是：&quot;);            for (int i = 0; i &lt; cookies.length; i++) {                Cookie cookie = cookies[i];                if (cookie.getName().equals(&quot;lastAccessTime&quot;)) {                    Long lastAccessTime =Long.parseLong(cookie.getValue());                    Date date = new Date(lastAccessTime);                    out.write(date.toLocaleString());                }            }        }else {            out.write(&quot;这是您第一次访问本站！&quot;);        }        //用户访问过之后重新设置用户的访问时间，存储到cookie中，然后发送到客户端浏览器        Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis()+&quot;&quot;);//创建一个cookie，cookie的名字是lastAccessTime        //将cookie对象添加到response对象中，这样服务器在输出response对象中的内容时就会把cookie也输出到客户端浏览器        response.addCookie(cookie);    }    public void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doGet(request, response);    }}</code></pre><h5 id="3-Cookie的安全性"><a href="#3-Cookie的安全性" class="headerlink" title="3.Cookie的安全性"></a>3.Cookie的安全性</h5><p>Cookie的目的是为用户带来方便，为网站带来增值，一般情况下不会造成严重的安全威胁。Cookie文件不能作为代码执行，也不会传送病毒，它为用户所专有并只能由创建它的服务器来读取。另外，浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为3KB，因此，Cookie不会塞满硬盘，更不会被用作”拒绝服务”攻击手段。</p><p>但是，Cookie作为用户身份的替代，其安全性有时决定了整个系统的安全性，Cookie的安全性问题不容忽视。</p><p>(1)Cookie欺骗</p><p>Cookie记录了用户的帐户ID、密码之类的信息，通常使用MD5方法加密后在网上传递。经过加密处理后的信息即使被网络上一些别有用心的人截获也看不懂。然而，现在存在的问题是，截获Cookie的人不需要知道这些字符串的含义，只要把别人的Cookie向服务器提交，并且能够通过验证，就可以冒充受害人的身份登陆网站，这种行为叫做Cookie欺骗。<br>非法用户通过Cookie欺骗获得相应的加密密钥，从而访问合法用户的所有个性化信息，包括用户的E-mail甚至帐户信息，对个人信息造成严重危害。<br>(2)Cookie截获<br>Cookie以纯文本的形式在浏览器和服务器之间传送，很容易被他人非法截获和利用。任何可以截获Web通信的人都可以读取Cookie。<br>Cookie被非法用户截获后，然后在其有效期内重放，则此非法用户将享有合法用户的权益。例如，对于在线阅读，非法用户可以不支付费用即可享受在线阅读电子杂志。</p><h3 id="二、Session"><a href="#二、Session" class="headerlink" title="二、Session"></a>二、Session</h3><h5 id="1-什么是Session"><a href="#1-什么是Session" class="headerlink" title="1.什么是Session"></a>1.什么是Session</h5><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个Session的时候，服务器首先检查这个客户端的请求里是否已包含了一个Session标识，称为SessionId，如果已包含一个SessionId则说明以前已经为此客户端创建过Session，服务器就按照SessionId把这个Session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含SessionId，则为此客户端创建一个Session并且生成一个与此Session相关联的SessionId，SessionId的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个SessionId将被在本次响应中返回给客户端保存。 保存这个SessionId的方式可以采用Cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。 </p><h5 id="2-Session的使用"><a href="#2-Session的使用" class="headerlink" title="2.Session的使用"></a>2.Session的使用</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String getId()</td><td>获取<code>SessionID</code>值</td></tr><tr><td>public void setAttribute()</td><td>设置属性</td></tr><tr><td>public Object getAttribute()</td><td>获取属性</td></tr><tr><td>public void removeAttribute()</td><td>移除属性</td></tr><tr><td>public []String getAllAttributeNames()</td><td>获取所有的属性名</td></tr><tr><td>public int getMaxInactiveInterval()</td><td>获取最长到期时间</td></tr><tr><td>public void setMaxInactiveInterval()</td><td>设置最长到期事件</td></tr><tr><td>public void  invalidate()</td><td>使该<code>Session</code>对象失效</td></tr><tr><td>public long getCreationTime()</td><td>获取创建时间</td></tr><tr><td>public long getLastAccessedTime()</td><td>获取上次访问时间</td></tr></tbody></table><p>已下是Session使用的一个例子</p><pre><code>//使用Session保存数据public class Demo01 extends HttpServlet {        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            response.setContentType(&quot;text/html;charset=UTF-8&quot;);            request.setCharacterEncoding(&quot;UTF-8&quot;);            // 获取参数            String username = request.getParameter(&quot;username&quot;);            // 获取session对象            HttpSession session = request.getSession();            // 保存数据            session.setAttribute(&quot;username&quot;, username);            // 打印SessionID            System.out.println(session.getId());        }        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            doGet(request, response);        }}//测试获取Session域中的数据public class Demo02 extends HttpServlet {        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            response.setContentType(&quot;text/html;charset=UTF-8&quot;);            request.setCharacterEncoding(&quot;UTF-8&quot;);            HttpSession session = request.getSession();            String username = (String)session.getAttribute(&quot;username&quot;);            // 响应到网页上            response.getWriter().write(username + &quot; &quot; + session.getId());        }        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            doGet(request, response);        }}</code></pre><h3 id="三、Cookie和Session的区别"><a href="#三、Cookie和Session的区别" class="headerlink" title="三、Cookie和Session的区别"></a>三、Cookie和Session的区别</h3><p>1.Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie是把用户的数据写在用户本地浏览器上, 其他网站也可以扫描使用你的Cookie，容易泄露自己网站用户的隐私，而且一般浏览器对单个网站站点有Cookie数量与大小的限制，Cookie也是实现Session的一种方式。 </p><p>2.Session 的运行依赖SessionId，而SessionId 是存在Cookie中的，也就是说，如果浏览器禁用了Cookie ，同时 Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 SessionId） 。</p><p>3.一般情况，登录信息等重要信息存储在Session中，其他信息存储在Cookie中 。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂方法模式&amp;抽象工厂模式</title>
      <link href="/2018/08/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F&amp;%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F&amp;%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>先介绍工厂方法模式和抽象工厂模式，这是23种设计模式的其中两种。不过在此之前我想先说说简单工厂模式，它不属于23种设计模式，却是今天要说的两种设计模式的入门。</p><h3 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h3><p>我们刚开始写代码的时候，如果需要一个类的对象，我们习惯利用关键字new把它直接创建出来，其实这并不是一个好习惯，因为这样不得已把对象的创建和使用绑定在一起，造成对象类和客户端代码非常高的耦合度，这无疑是我们不想看到的结果，那应该怎么办？简单工厂模式在一定程度上能解决这个问题。</p><p>简单工厂模式是<strong>由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。 </p><p>上面是定义，现在看不懂没关系，下面我来举例。市面上手机有各种各样的品牌，华为，小米，oppo等，不同场景下我们需要的手机品牌不同，那我们要怎么定义这个手机类？有些人可能觉得直接根据品牌定义类就好，华为一个类小米一个类这样，但仔细思考后会发现这样并不可取，因为手机品牌虽然不同，但很多功能都是类似的，重复的代码尽量不要写，这也是我们编码的原则之一，比较好的方法是定义一个抽象的手机类，如下</p><pre><code>abstract class Phone {    //所有手机都有的功能，这里我举打电话这个例子    public void call() {        //具体实现省略    }    //不同品牌手机不同的功能    public abstract void method();}</code></pre><p>然后在根据具体手机品牌定义各自的类</p><pre><code>//华为class HUAWEI extends Phone {    public void method() {    //具体实现    }}//小米class XiaoMi extends Phone {    public void method() {    //具体实现    }}...</code></pre><p>这样定义结束后，如果我们需要使用不同品牌的手机对象，根据简单工厂模式我们还需要定义一个工厂类</p><pre><code>class Factory {    //静态工厂方法，返回不同手机品牌对象    public static Phone getPhone(String type) {        Phone phone = null;        if(type.equals(&quot;HUAWEI&quot;)) {            phone = new HUAWEI();        } else if(type.equals(&quot;XiaoMi&quot;)) {            phone = new XiaoMi();        } else {            //...        }        return phone;    }}</code></pre><p>有了这个工厂类我们创建对象就方便了，以下是客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        Phone myPhone1 = Factory.getPhone(&quot;XiaoMi&quot;);        Phone myPhone2 = Factory.getPhone(&quot;HUAWEI&quot;);    }}</code></pre><p>这就是简单工厂模式的常用场景，你发现没，利用简单工厂模式我们很自然地将对象的创建与使用分开（创建交给工厂类，使用在客户端代码中），看完这个例子再看它的定义，会清楚很多，如果你理解了，那恭喜你可以继续学习工厂方法模式了，如果还是不懂的话不建议继续往下看，请多看相关的其他文章。</p><h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p>简单工厂模式固然简单，但是也有问题，如果我们需要一个手机品牌（例如三星），而工厂类中没有相应的创建代码怎么办？我们就不得不修改我们的工厂类，但是这样就违背了我们的开闭原则，如何在新增手机品牌的情况下而不修改源代码？这时候工厂方法模式就出现了。</p><p>工厂方法模式在简单工厂模式上做出了改进，意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 </p><p>按照上面说的我们只要将Factory类做些改动，把它变成一个接口</p><pre><code>interface Factory {    public Phone getPhone();}</code></pre><p>然后根据不同手机品牌编写对应的品牌工厂类</p><pre><code>//小米class XiaoMiFactory implements Factory {    public Phone getPhone() {        return new XiaoMi();    }}//三星class SAMSUNGFactory implements Factory {    public Phone getPhone() {        return new SAMSUNG();    }}...</code></pre><p>把工厂类改写成接口，将实际创建工作推迟到子类当中，这样我们需要什么手机品牌的对象，写个品牌工厂实现工厂类接口就行了，不就解决了新手机品牌的问题。不得不说早期提出设计模式的大牛们是多厉害，仰望一下。好了，下面是使用工厂方法模式后的客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        Factory factory = null;        factory = new SAMSUNGFactory();        Phone myPhone = factory.getPhone();    }}</code></pre><h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p>接着我们上面的例子，手机有各式的品牌，然而每个手机品牌也不止只生产手机，比如小米还有充电宝，空气净化器等等，如果都为它们创建工厂类可能会导致系统中存在大量工厂类，这样势必会产生系统开销，此时我们的抽象工厂模式运营而生。</p><h5 id="1-产品等级结构与产品族"><a href="#1-产品等级结构与产品族" class="headerlink" title="1.产品等级结构与产品族"></a>1.产品等级结构与产品族</h5><p>要理解抽象工厂模式，我们就要先来学习一下产品等级结构与产品族是什么。</p><img src="/2018/08/05/工厂方法模式&抽象工厂模式/抽象工厂模式-产品族与产品等级.jpg"><p>上图是产品族与产品等级结构示意图，产品等级结构是产品的继承结构，如我们的抽象类Phone，其子类有XiaoMi，HUAWEI，SAMSUNG，则Phone与XiaoMi,HUAWEI,SAMSUNG之间构成了一个产品等级结构。产品族是指由同一个工厂生产的，位于不同产品等级结构的同一组产品，如小米的手机，充电宝，空气净化器，它们各自属于不同的产品等级结构，因此它们属于一个产品族，即小米。</p><h5 id="2-抽象工厂模式举例"><a href="#2-抽象工厂模式举例" class="headerlink" title="2.抽象工厂模式举例"></a>2.抽象工厂模式举例</h5><p>如果利用工厂方法模式为小米华为的手机，充电宝和空气净化器都创建对象，一共需要6个工厂类，而抽象工厂模式简单许多，我们先为产品族新建一个抽象类（接口也行）</p><pre><code>abstract class AbstractFactory {    //为一个产品族创建不同产品等级结构的方法    public abstract Phone getPhone();    public abstract PowerBank getPowerBank();    public abstract AirPurifier getAirPurifier();}</code></pre><p>对于每个品牌，其代码如下</p><pre><code>//小米class XiaoMiFactory extends AbstractFactory {    public abstract Phone getPhone() {        return new XiaoMi();    }    public abstract PowerBank getPowerBank() {        return new XiaoMiPowerBank();    }    public abstract AirPurifier getAirPurifier() {        return new XiaoMiAirPurifier();    }}//华为class HUAWEIFactory extends AbstractFactory {    public abstract Phone getPhone() {        return new HUAWEI();    }    public abstract PowerBank getPowerBank() {        return new HUAWEIPowerBank();    }    public abstract AirPurifier getAirPurifier() {        return new HUAWEIAirPurifier();    }}</code></pre><p>做到这样就可以了，两个产品族我们只要两个具体工厂类，一个抽象工厂类，是不是比工厂方法模式简单？下面是客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        AbstractFactory factory = null;        factory = new XiaoMiFactory();        Phone myPhone = factory.getPhone();        PowerBank myPower = factory.getPowerBank();    }}</code></pre><h5 id="3-与工厂方法模式的对比"><a href="#3-与工厂方法模式的对比" class="headerlink" title="3.与工厂方法模式的对比"></a>3.与工厂方法模式的对比</h5><p>抽象工厂模式的使用就是上面这样，下面我们来将它与工厂方法模式做个对比</p><table><thead><tr><th>工厂方法模式</th><th>抽象工厂模式</th></tr></thead><tbody><tr><td>针对的是一个产品等级结构</td><td>针对的是多个产品等级结构</td></tr><tr><td>一个抽象产品类</td><td>多个抽象产品类</td></tr><tr><td>每个抽象产品类可以派生出多个具体产品类</td><td>每个抽象产品类可以派生出多个具体产品类</td></tr><tr><td>一个抽象工厂类，可以派生出多个具体工厂类</td><td>一个抽象工厂类，可以派生出多个具体工厂类</td></tr><tr><td>每个具体工厂类只能创建一个具体产品类的实例</td><td>每个具体工厂类可以创建多个具体产品类的实例</td></tr></tbody></table><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。 </p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式起篇</title>
      <link href="/2018/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E7%AF%87/"/>
      <url>/2018/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>今天挖坑，来讲讲我们23种设计模式，设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。虽然如此，但是滥用设计模式很可能会造成与自己预期相反的结果，所以我在起篇先给自己和大家提个醒，<strong>设计模式是经验总结，不是公理公式 ，要为实现需求而编码，而不是为使用设计模式而编码 ！</strong></p><h3 id="一、设计模式的六大原则"><a href="#一、设计模式的六大原则" class="headerlink" title="一、设计模式的六大原则"></a>一、设计模式的六大原则</h3><p>总原则：开闭原则，即对扩展开放，对修改关闭。 </p><h5 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h5><p>每个类应该实现单一的职责，否则应该把类拆分。 </p><h5 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2.里氏替换原则"></a>2.里氏替换原则</h5><p>任何基类可以出现的地方，子类一定可以出现。它是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 </p><h5 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h5><p>这是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。 </p><h5 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4.接口隔离原则"></a>4.接口隔离原则</h5><p>使用多个隔离的接口，比使用单个接口要好。每个接口不存在子类用不到却必须实现的方法，否则要将接口拆分。 </p><h5 id="5-迪米特法则（最少知道原则）"><a href="#5-迪米特法则（最少知道原则）" class="headerlink" title="5.迪米特法则（最少知道原则）"></a>5.迪米特法则（最少知道原则）</h5><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统的功能模块相对独立。 </p><h5 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6.合成复用原则"></a>6.合成复用原则</h5><p>尽量使用合成/聚合方式，而不是使用继承。</p><h3 id="二、设计模式的三大类"><a href="#二、设计模式的三大类" class="headerlink" title="二、设计模式的三大类"></a>二、设计模式的三大类</h3><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>好了，起篇就先有这么多，下一篇开始正式讲我们的23种设计模式，以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p><p>参考文章：<a href="https://my.oschina.net/tiancai/blog/224624" target="_blank" rel="noopener">Java开发中的23种设计模式详解</a></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Servlet总结</title>
      <link href="/2018/08/03/Servlet/"/>
      <url>/2018/08/03/Servlet/</url>
      <content type="html"><![CDATA[<p>这几天忙着玩忙着睡都没有更博，不过也稍微计划了下大概要写些什么，具体就不说了，我不画大饼，没做到尴尬。。</p><p>写技术博客也不是想给谁看，就是个人总结和复习，也当做笔记，以后忘了什么知识点可以来看看，仅此而已。行了，废话也不说了，来说说我们的Servlet。</p><h3 id="一、什么是Servlet"><a href="#一、什么是Servlet" class="headerlink" title="一、什么是Servlet"></a>一、什么是Servlet</h3><p>Servlet是什么？”狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。“这是百度上说的，以我的理解，Servlet就是一个Java接口，是一套处理网络请求的规范 ，我们平时写的Servlet必须实现刚刚那个接口，按它的规范完成我们的编写，这样完成的Java类我们管它叫自己的Servlet。</p><p>好的，Servelt既然是一个接口，那具体是怎样的接口呢，下图详细地解释了Servlet体系与各自的方法。</p><img src="/2018/08/03/Servlet/servlet1.png"><p>每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是的init()，service()，destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet，它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet()方法，如为Post请求，则调用doPost()方法。所以我们在编写Servlet时，通常只需要覆写doGet()或doPost()方法。 </p><h3 id="二、Servlet生命周期"><a href="#二、Servlet生命周期" class="headerlink" title="二、Servlet生命周期"></a>二、Servlet生命周期</h3><p>说到Servlet不提它的生命周期显然是不行的，要掌握Servlet这个是重点，那么Servlet工作流程分为以下几个阶段：</p><h5 id="1-加载和实例化"><a href="#1-加载和实例化" class="headerlink" title="1.加载和实例化"></a>1.加载和实例化</h5><p>当检测到需要Servlet的第一个请求时，读取xml文件找到要加载的servlet类，创建Servlet实例。 加载一般是在运行Servlet容器时来完成，将servlet类加载到tomcat中，或者是客户端发来请求时也可以。</p><h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h5><p>初始化信息一般是读取配置信息、读取初始化参数等，对于每一个servlet实例，init()方法值被调用一次。</p><h5 id="3-请求处理"><a href="#3-请求处理" class="headerlink" title="3.请求处理"></a>3.请求处理</h5><p>调用Servlet的service()方法对请求进行处理，在调用该方法之前，init()方法必须先成功执行。根据请求的到来，service()方法决定请求的请求，常用的是doGet()或doPost()。</p><h5 id="4-销毁"><a href="#4-销毁" class="headerlink" title="4.销毁"></a>4.销毁</h5><p>销毁一般是Servlet的卸载是由容器本身定义和实现，在destroy()方法调用后，容器释放对应的Servlet请求。实例随后会被Java的垃圾收集器所回收，整个Servlet的生命周期结束。一般tomcat关闭，servlet就会被销毁。</p><p>Servlet没有main方法，所有行为由Servlet容器控制，我们最常见的Servlet容器就是Tomcat了。整个流程如下图：</p><img src="/2018/08/03/Servlet/servlet2.jpg"><p>（图来自《Head First Servlets &amp; JSP》，逸夫有，是本入门经典 ，推荐！ ）</p><h3 id="三、servlet配置及其含义"><a href="#三、servlet配置及其含义" class="headerlink" title="三、servlet配置及其含义"></a>三、servlet配置及其含义</h3><p>servlet配置在项目的web.xml下，这里其实最想说的是配置中各节点的含义： </p><pre><code>&lt;!-- 配置一个servlet --&gt;&lt;!-- servlet的配置 --&gt;&lt;servlet&gt;    &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!-- servlet的类全名： 包名+简单类名 --&gt;    &lt;servlet-class&gt;lm.practice.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt;    &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!-- servlet的映射路径（访问servlet的名称） --&gt;    &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p> 可以看到，在配置Servlet时，有两个地方需要配置，一个是&lt;servlet&gt;,另一个是&lt;servlet-Mapping&gt;，这两个一个是配置Servlet，一个是配置其映射信息，其中&lt;servlet&gt;中的&lt;servlet-name&gt;可以随意指定，但要有一定的意义，一般取为类的名称，例如我的类名为ServletDemo，这里取名为ServletDemo,下面的&lt;servlet-class&gt;是类的全路径 ，一定要是全路径！ </p><p>&lt;servlet-Mapping&gt;是映射信息，它也有一个&lt;servlet-name&gt;，里面的名字是对应的Servlet名，也就是我们上面配置的Servlet名字，这里是ServletDemo，下面的是映射路径，也就是访问Servlet的名称，这里也是以方便和有意义为前提的，是我们在访问Servlet在浏览器地址栏后面输入的那个信息。</p><p>注意：这里的映射路径一定不是丢掉/，否则就会出错了，一定要写成/servlet，不能是servlet。</p><p>行了，关于Servlet的知识点目前就想到这么多，其实还有九大内置对象，四个作用域什么的，大家想了解可以参考这个帖子，<a href="https://www.cnblogs.com/sunli0205/p/5896980.html" target="_blank" rel="noopener">了解一下</a>。以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/28/Hello%20World/"/>
      <url>/2018/07/28/Hello%20World/</url>
      <content type="html"><![CDATA[<p>搭建个人博客的想法一直都有，算起来断断续续也有一年了吧。</p><p>今天心血来潮说做就做了，想起来会很难，但实际做完了才知道其实也挺简单的。东拼西凑，如你所见，博客的雏形大概就出来了。也算完成一个小目标？</p><p>今天是18年7月28日，我的大二暑假快要过半了，而我现在还在整合ssm框架，争取在这个暑假结束时熟悉ssm项目的结构，建立流程以及Maven的使用，能顺便了解一下SpringCloud或者SpringBoot最好，这样我也不算虚度这一个多月。</p><p>很惭愧，还要继续完善这个博客，所以第一篇就写得简单了些，只想再努力些，再加油些，Hello World！</p>]]></content>
      
      <categories>
          
          <category> 个人日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
