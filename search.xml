<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>计算机网络总结（二）-- TCP与UDP</title>
      <link href="/2018/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%932/"/>
      <url>/2018/11/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%932/</url>
      <content type="html"><![CDATA[<h3 id="一、TCP协议"><a href="#一、TCP协议" class="headerlink" title="一、TCP协议"></a>一、TCP协议</h3><h5 id="1-TCP首部格式"><a href="#1-TCP首部格式" class="headerlink" title="1.TCP首部格式"></a>1.TCP首部格式</h5><img src="/2018/11/20/计算机网络知识点总结2/tcp.png"><p>各个段位说明:</p><p>源端口和目的端口：各占 2 字节，端口是传输层与应用层的服务接口，传输层的复用和分用功能都要通过端口才能实现。<br>序号：占 4 字节，TCP 连接中传送的数据流中的每一个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。<br>确认号：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。<br>数据偏移/首部长度:占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字(以 4 字节为计算单位)。<br>保留：占 6 位，保留为今后使用，但目前应置为 0。<br>紧急URG：当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。<br>确认ACK：只有当 ACK=1 时确认号字段才有效，当 ACK=0 时，确认号无效。<br>PSH(PuSH)：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。<br>RST (ReSeT)：当 RST=1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。<br>同步 SYN：同步 SYN = 1 表示这是一个连接请求或连接接受报文。<br>终止 FIN：用来释放一个连接，FIN=1 表明此报文段的发送端的数据已发送完毕,并要求释放运输连接。<br>检验和：占 2 字节，检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。<br>紧急指针：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。<br>选项：长度可变，TCP 最初只规定了一种选项，即最大报文段长度 MSS.MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” [MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度.数据字段加上 TCP 首部才等于整个的 TCP 报文段]。<br>填充：这是为了使整个首部长度是 4 字节的整数倍。<br>其他选项:<br>窗口扩大：占 3 字节，其中有一个字节表示移位值 S，新的窗口值等于TCP 首部中的窗口位数增大到(16 + S)，相当于把窗口值向左移动 S 位后获得实际的窗口大小。<br>时间戳：占10 字节，其中最主要的字段时间戳值字段(4字节)和时间戳回送回答字段(4字节)。<br>选择确认：接收方收到了和前面的字节流不连续的两2字节，如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方,使发送方不要再重复发送这些已收到的数据。</p><h5 id="2-连接管理机制"><a href="#2-连接管理机制" class="headerlink" title="2.连接管理机制"></a>2.连接管理机制</h5><p>(1)三次握手</p><img src="/2018/11/20/计算机网络知识点总结2/tcp1.png"><p>客户端需要与服务器建立TCP可靠连接时向服务器发起三次握手，下面是具体流程：</p><ul><li>第一次握手：客户端向服务器发出连接请求报文，这时报文首部中的同部位SYN=1，同时随机生成初始序列号 seq=x，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。这个三次握手中的开始。表示客户端想要和服务端建立连接。</li><li>第二次握手：TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己随机初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。这个报文带有SYN(建立连接)和ACK(确认)标志，询问客户端是否准备好。</li><li>第三次握手：TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。 </li></ul><blockquote><p>面试题1：为什么需要三次握手，两次握手不行吗？</p><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p></blockquote><blockquote><p>面试题2：什么是SYN攻击？</p><p>在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect)。此时服务器处于SYN-RCVD状态。当收到ACK后，服务器转入ESTABLISHED状态。SYN攻击就是 攻击客户端，在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。 </p><p>SYN攻击是一个典型的<a href="https://www.centos.bz/tag/ddos/" target="_blank" rel="noopener">DDOS</a>攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。主要防御方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等。但是不能完全防范SYN攻击。 </p></blockquote><p>(2)四次挥手</p><img src="/2018/11/20/计算机网络知识点总结2/tcp2.png"><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。 </p><ul><li><p>第一次挥手：客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p></li><li><p>第二次挥手：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p><p>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p></li><li><p>第三次挥手：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p></li><li><p>第四次挥手：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。<strong>注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</strong></p><p>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p></li></ul><blockquote><p>面试题1：为什么客户端最后还要等待2MSL？</p><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p></blockquote><blockquote><p>面试题2：为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 </p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p></blockquote><blockquote><p>面试题3：如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 </p></blockquote><h5 id="3-TCP拥塞控制机制与滑动窗口"><a href="#3-TCP拥塞控制机制与滑动窗口" class="headerlink" title="3.TCP拥塞控制机制与滑动窗口"></a>3.TCP拥塞控制机制与滑动窗口</h5><p>(1)拥塞控制机制</p><p>TCP的拥塞控制机制有四个阶段，分别为慢开始、拥塞避免以及快重传和快恢复。</p><p>这里我贴个博文，上面写的非常详细，<a href="https://blog.csdn.net/shuxnhs/article/details/80644531" target="_blank" rel="noopener">TCP拥塞控制机制（附面试题</a>。</p><p>(2)滑动窗口</p><p>偷懒了，滑动窗口内容也很多，就不说了。。</p><p><a href="https://blog.csdn.net/qq_34501940/article/details/51180268" target="_blank" rel="noopener">TCP协议的学习（六）滑动窗口 停止等待 退后N帧 选择重传</a></p><h3 id="二、UDP协议"><a href="#二、UDP协议" class="headerlink" title="二、UDP协议"></a>二、UDP协议</h3><p>UDP（User Datagram Protocol），用户数据报协议，是OSI(Open System Interconnection，开放式系统互联) 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP提供了无连接通信，且不对传送数据包进行可靠性保证，适合于一次传输少量数据，UDP传输的可靠性由应用层负责。</p><h5 id="1-UDP首部格式"><a href="#1-UDP首部格式" class="headerlink" title="1.UDP首部格式"></a>1.UDP首部格式</h5><img src="/2018/11/20/计算机网络知识点总结2/udp.png"><p>UDP协议分为首部字段和数据字段，其中首部字段只占用8个字节，分别是个占用两个字节的源端口、目的端口、长度和检验和。 </p><h3 id="三、TCP与UDP的区别以及适用场景"><a href="#三、TCP与UDP的区别以及适用场景" class="headerlink" title="三、TCP与UDP的区别以及适用场景"></a>三、TCP与UDP的区别以及适用场景</h3><ul><li>TCP是面向连接的，UDP是无连接的；</li><li>TCP是可靠的，UDP是不可靠的；</li><li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</li><li>TCP是面向字节流的，UDP是面向报文的；</li><li>TCP有拥塞控制机制；UDP没有拥塞控制，适合媒体通信；</li><li>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</li></ul><p>什么时候应该使用TCP：<br>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。<br>在日常生活中，常见使用TCP协议的应用如下：</p><ul><li><p>浏览器，用的HTTP</p></li><li><p>FlashFXP，用的FTP</p></li><li>Outlook，用的POP、SMTP</li><li>Putty，用的Telnet、SSH</li><li>QQ文件传输</li></ul><p>什么时候应该使用UDP：</p><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。</p><p>比如，日常生活中，常见使用UDP协议的应用如下：</p><ul><li><p>QQ语音</p></li><li><p>QQ视频</p></li><li>TFTP</li></ul><hr><p> 参考资料：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">TCP的三次握手与四次挥手（详解+动图）</a></p>]]></content>
      
      <categories>
          
          <category> 基础与进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络总结（一）-- OSI七层模型与TCP/IP五层模型</title>
      <link href="/2018/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%931/"/>
      <url>/2018/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%931/</url>
      <content type="html"><![CDATA[<p>距离上次更博过去好几天了，最近忙着做项目，说起来也是太懒了，检讨下。</p><p>接下去几篇会总结计算机网络常被问到的知识点，尽量写全。</p><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><h5 id="1-OSI的来源"><a href="#1-OSI的来源" class="headerlink" title="1.OSI的来源"></a>1.OSI的来源</h5><p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。</p><p>ISO为了更好的使网络应用更为普及，推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。</p><h5 id="2-OSI七层模型的划分和对应的网络协议"><a href="#2-OSI七层模型的划分和对应的网络协议" class="headerlink" title="2.OSI七层模型的划分和对应的网络协议"></a>2.OSI七层模型的划分和对应的网络协议</h5><p>OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。如下图。</p><img src="/2018/11/09/计算机网络知识点总结1/OSI.png"><p>（图片来自<a href="http://www.colasoft.com.cn/download/protocols_map.php" target="_blank" rel="noopener">科来网络通讯协议图2019版</a> )</p><p>每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p><p>下面我来列举几个各层的功能和常用的协议：</p><ul><li><p>应用层：直接向用户提供服务，完成用户希望在网络上完成的各种工作。<br>HTTP-超文本传输协议     FTP-文件传输协议     SMTP-简单邮件传输协议</p></li><li><p>表示层：处理用户信息的表示问题，如编码、数据格式转换和加密解密。<br>LPP-轻量级表示协议</p></li><li><p>会话层：组织和协调两个会话进程之间的通信，并对数据交换进行管理。<br>SSL-安全套接字层协议</p></li><li><p>传输层：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。<br>TCP-传输控制协议     UDP-用户数据报协议</p></li><li><p>网络层：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。<br>IGMP-互联网组管理协议     EGP-外部网关协议</p></li><li><p>数据链路层：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br>ARP-地址解析协议     PPTP-点对点隧道协议</p></li><li><p>物理层：为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。 </p><p>Internetwork</p></li></ul><p>  还有总结一下网络中常用端口号：</p><table><thead><tr><th style="text-align:center">端口号</th><th style="text-align:center">协议</th></tr></thead><tbody><tr><td style="text-align:center">20/21</td><td style="text-align:center">FTP</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">Telnet远程登录</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">SMTP</td></tr><tr><td style="text-align:center">53</td><td style="text-align:center">DNS域名服务器</td></tr><tr><td style="text-align:center">80</td><td style="text-align:center">HTTP</td></tr><tr><td style="text-align:center">443</td><td style="text-align:center">HTTPS</td></tr></tbody></table><h5 id="3-与TCP-IP五层模型的关系"><a href="#3-与TCP-IP五层模型的关系" class="headerlink" title="3.与TCP/IP五层模型的关系"></a>3.与TCP/IP五层模型的关系</h5><p>TCP/IP五层协议和OSI的七层协议对应关系如下 </p><img src="/2018/11/09/计算机网络知识点总结1/tcpip.jpg"><hr><p>今天内容比较少，下次会更新传输层协议TCP与UDP相关的内容。</p>]]></content>
      
      <categories>
          
          <category> 基础与进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入分析HashMap</title>
      <link href="/2018/10/28/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90HashMap/"/>
      <url>/2018/10/28/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90HashMap/</url>
      <content type="html"><![CDATA[<p>HashMap大家都会用，说起特点可能也会说出个一二三，但是凭这点想拿offer是远远不能够的，今天我就详细说说这个常用的集合类。</p><h3 id="一、HashMap概述"><a href="#一、HashMap概述" class="headerlink" title="一、HashMap概述"></a>一、HashMap概述</h3><p>HashMap是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>HashMap继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。</p><p>HashMap的实现不是同步的，这意味着它不是线程安全的。如果想要线程安全的HashMap，可以通过Collections类的静态方法synchronizedMap获得线程安全的HashMap。（看过Java并发编程的同学应该很熟悉）</p><p><code>Map map = Collections.synchronizedMap(new HashMap());</code></p><p>它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>主要关注点在下表格：</p><table><thead><tr><th>关  注  点</th><th>结      论</th></tr></thead><tbody><tr><td>HashMap是否允许null</td><td>key和value都允许为null</td></tr><tr><td>HashMap是否允许重复数据</td><td>key重复会覆盖、value允许重复</td></tr><tr><td>HashMap是否有序</td><td>无序，特别说明这个无序指的是遍历HashMap的时候，得到的元素的顺序基本不可能是put的顺序</td></tr><tr><td>HashMap是否线程安全</td><td>非线程安全</td></tr></tbody></table><h3 id="二、HashMap的数据结构"><a href="#二、HashMap的数据结构" class="headerlink" title="二、HashMap的数据结构"></a>二、HashMap的数据结构</h3><p>先贴一个HashMap定义的成员变量：</p><pre><code>//HashMap是基于hash表来实现Map接口的，HashMap维护了下面几个变量：    //HashMap默认的初始化大小为16    static final int DEFAULT_INITIAL_CAPACITY = 16;    //HashMap包含键值对的最大容量为2^30,HashMap的容量一定要是2的整数次幂    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    //默认的加载因子为0.75    static final float DEFAULT_LOAD_FACTOR = 0.75f;    //装载键值对的内部容器Entry数组，长度一定得是2的幂    transient Entry[] table;    //HashMap中包含的键值对的个数    transient int size;    //HashMap的极限 当键值对的个数达到threshold时，数组table要扩容的    int threshold;    //加载因子    final float loadFactor;    //HashMap结构上被改变的次数，结构上的改变包括：键值对的大小的改变，修改HashMap的内部结构（比较进行了rehash操作），此属性用来保持fail-fast    transient volatile int modCount;</code></pre><p>HashMap实际上是一个“链表的数组”的数据结构，每个元素存放链表头结点的数组，即数组和链表的结合体。 （在数据结构中，一般称之为“散列表”） </p><img src="/2018/10/28/深入分析HashMap/1.png"><p>如上图所示，这就是HashMap底层的数据结构。可以发现，HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。 </p><p>下面我们看一下Entry的实现，Entry&lt;K,V&gt;是HashMap的一个静态内部类 </p><pre><code>/***Entry是HashMap里面承载键值对数据的数据结构，实现了Map接口里面的Entry接口，除了方法recordAccess(HashMap&lt;K,V&gt; m),recordRemoval(HashMap&lt;K,V&gt; m)外，其他方法均为final方法，表示即使是子类也不能覆写这些方法。*/static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    //键值,被final修饰，表明一旦赋值，不可修改    final K key;    //value值    V value;    //下一个键值对的引用    Entry&lt;K,V&gt; next;    //当前键值对中键值的hash值    final int hash;    //构造方法    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {        value = v;          next = n;        key = k;        hash = h;    }    public final K getKey() {        return key;    }    public final V getValue() {        return value;    }    //设置value值，返回原来的value值    public final V setValue(V newValue) {        V oldValue = value;        value = newValue;        return oldValue;    }    //比较键值对是否equals相等，只有键、值都相等的情况下，才equals相等    public final boolean equals(Object o) {        if (!(o instanceof Map.Entry))            return false;        Map.Entry e = (Map.Entry)o;        Object k1 = getKey();        Object k2 = e.getKey();        //若k1 == k2(k1,k2引用同一个对象),或者k1.equals(k2)为true时，进而判断value值是否相等        if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {        Object v1 = getValue();        Object v2 = e.getValue();        //若v1 == v2(v1,v2引用同一个对象)，或者v1.equals(v2)为true时，此时才能说当前的键值对和指定的的对象equals相等        if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))            return true;        }        //其他均为false         return false;    }    public final int hashCode() {        return (key==null ? 0 : key.hashCode()) ^         (value==null ? 0 : value.hashCode());    }    public final String toString() {        return getKey() + &quot;=&quot; + getValue();    }    //此方法只有在key已存在的时候调用m.put(key,value)方法时，才会被调用，即覆盖原来key所对应的value值时被调用    void recordAccess(HashMap&lt;K,V&gt; m) {}    //此方法在当前键值对被remove时调用    void recordRemoval(HashMap&lt;K,V&gt; m) {}}</code></pre><h3 id="三、容量-capacity-和负载因子-loadFactor"><a href="#三、容量-capacity-和负载因子-loadFactor" class="headerlink" title="三、容量(capacity)和负载因子(loadFactor)"></a>三、容量(capacity)和负载因子(loadFactor)</h3><p>简单的说，capacity就是Entry数组的大小，loadFactor就是Entry数组填满程度的最大比例。当Entry数组中的键值对数目（而不是已占用的位置数）大于capacity*loadFactor（即threshold）时就需要扩容，调整Entry数组的大小为当前的2倍。同时，初始化容量的大小也是2的次幂（大于等于设定容量的最小次幂），则Entry数组的大小在扩容前后都将是2的次幂（非常重要，HashMap访问的性能最高，且resize时能带来极大便利）。 </p><p><strong>默认的capacity为16，loadFactor为0.75，</strong>但如果需要优化的话，要考量具体的使用场景。</p><ul><li><p>如果对迭代性能要求高，不要把capacity设置过大，也不要把loadFactor设置过小，否则会导致Entry数组中的空位置过多，浪费性能。</p></li><li><p>如果对随机访问的性能要求很高的话，不要把loadFactor设置的过大，否则会导致访问时频繁碰撞，时间复杂度向O(n)退化。</p></li><li><p>如果数据增长很快的话，或数据规模可预知，可以在创建HashMap时主动设置capacity。</p></li></ul><h3 id="四、HashMap的存取实现"><a href="#四、HashMap的存取实现" class="headerlink" title="四、HashMap的存取实现"></a>四、HashMap的存取实现</h3><p>HashMap在get和put计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，所以我们先看看这个hash方法是如何实现的以及下标的计算过程。</p><h5 id="1-hash的实现和定位"><a href="#1-hash的实现和定位" class="headerlink" title="1.hash的实现和定位"></a>1.hash的实现和定位</h5><p>作为API的设计者，不能假定用户实现了良好的hashCode方法，所以通常会对hashCode再计算一次hash，以下是hash方法源码： </p><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>前面已经说过，在get和put计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示： </p><img src="/2018/10/28/深入分析HashMap/hash-01.png"><p>回顾hash方法的源码可知，hash方法大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。（两者相等为0，不等为1）</p><p>经过hash方法得到的hash值还要通过indexFor方法进一步处理来获取实际的存储位置，以下是indexFor方法源码：  </p><pre><code>static int indexFor(int h, int length) {        return h &amp; (length-1);}</code></pre><p>因为目前的table长度n为2的次幂，所以计算下标的时候，取模<code>%</code>运算等价于按位与<code>&amp;</code>运算，但是&amp;比%具有更高的效率。</p><p>另外，前面说了初始化容量的大小是2的次幂，Entry数组的大小在扩容前后都将是2的次幂，下面说明理由。</p><p>看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hash值均为8和9，但是很明显，当右边和1110（15二进制-1）按位与的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hash值会与14（1110）进行按位与，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！  </p><img src="/2018/10/28/深入分析HashMap/3.jpg"><p>所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。  </p><h5 id="2-put的实现"><a href="#2-put的实现" class="headerlink" title="2.put的实现"></a>2.put的实现</h5><p>把hash方法以及下标计算方法讲完，这部分就简单许多，以下是HashMap的put方法实现：</p><pre><code>/***将指定的键key,值value放到HashMap中*/public V put(K key, V value) {    //首先判断键key是否为null,若为null,则调用putForNullKey(V v)方法完成put    if (key == null)        return putForNullKey(value);    //程序走到这，说明key不为null了，先调用hash(int)方法，计算key.hashCode的hash值    int hash = hash(key.hashCode());    //再调用indexFor(int,int)方法求出此hash值对应在table数组的哪个下标i上 (bucket桶)    int i = indexFor(hash, table.length);    //遍历bucket桶上面的链表元素，找出HashMap中是否有相同的key存在，若存在，则替换其value值，返回原来的value值    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {        Object k;        //若元素e.hash值和上面计算的hash值相等，并且(e.key == 入参key,或者入参key equals 相等 e.key)，则说明HashMap中存在了和入参相同的key了，执行替换操作        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {            V oldValue = e.value;            e.value = value;            //在执行替换操作的时候，调用Entry对象的recordAccess(HashMap&lt;K,V&gt; m)方法，这个上面说过了            e.recordAccess(this);            return oldValue;        }    }    //程序走到这，说明原来HashMap中不存在key,则直接将键值对插入即可，由于插入元素，修改了HashMap的结构，因此将modeCount+1    modCount++;    //调用addEntry(int,K,V,int)方法进行键值对的插入    addEntry(hash, key, value, i);    //由于原来HashMap中不存在key，则不存在替换value值问题，因此返回null    return null;}</code></pre><p>当key为null时，HashMap是这样进行数据插入的： </p><pre><code>//先看看HashMap中原先是否有key为null的键值对存在，若存在，则替换原来的value值；若不存在，则将key为null的键值对插入到Entry数组的第一个位置table[0]private V putForNullKey(V value) {    //获取Entry数组的第一个元素:table[0],然后通过e.next进行链表的遍历，若遍历过程中有元素e.key为null,则替换该元素的值    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {        //说明原来之前HashMap中就已经存在key问null的键值对了，现在又插入了一个key为null的新元素，则替换掉原来的key为null的value值        if (e.key == null) {            V oldValue = e.value;            e.value = value;            //在执行替换操作的时候，调用Entry对象的recordAccess(HashMap&lt;K,V&gt; m)方法，这个上面说过了            e.recordAccess(this);            return oldValue;        }    }    //程序走到这，说明HashMap中原来没有key为null的键值对，需要直接插入元素，由于插入元素，修改了HashMap的结构，因此将modeCount+1    modCount++;    //调用addEntry(int,K,V,int)方法进行键值对的插入,这里将入参hash设置为0，K为null,插入的位置index也为0，说明key为null的元素插入在bucket[0]第一个桶上    addEntry(0, null, value, 0);    return null;}</code></pre><p>通过上述源码我们可以清楚知到，HashMap 中可以保存key为null的键值对，且该键值对是唯一的。若再次向其中添加键为null的键值对，将覆盖其原值。此外，如果HashMap中存在键为null的键值对，那么一定在第一个桶中。 </p><p>下面我们看一看实际进行数据添加的操作addEntry方法：</p><pre><code>/***将指定的key,value,hash,bucketIndex 插入键值对，若此时size大于极限threshold,则将Entry数组table扩容到原来容量的两倍*/void addEntry(int hash, K key, V value, int bucketIndex) {    //取出原来bucketIndex处的键值对e    Entry&lt;K,V&gt; e = table[bucketIndex];    //创建一个新的键值对，使用给定的hash、key、value,并将新键值对的next属性指向e,最后将新键值对放在bucketIndex处    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);    //将size+1,若此时size 大于极限threshold,则将Entry数组table扩容到原来容量的两倍    if (size++ &gt;= threshold)        //调用resize(int)方法，进行数组的扩容        resize(2 * table.length);}</code></pre><p>这就是HashMap基本存键值对的操作，其实在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树，实际并非这么简单，下图是完整操作：</p><img src="/2018/10/28/深入分析HashMap/2.png"><ol><li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； </li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向6，如果table[i]不为空，转向3； </li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向4，这里的相同指的是hashCode以及equals； </li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5； </li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； </li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 </li></ol><h5 id="3-get的实现"><a href="#3-get的实现" class="headerlink" title="3.get的实现"></a>3.get的实现</h5><pre><code>//获取指定key所对应的value值public V get(Object key) {    //若key==null,则直接调用getForNullKey()方法    if (key == null)        return getForNullKey();    //到这说明key != null,先获取key的hash值    int hash = hash(key.hashCode());    //在indexFor(int hash,int length)获取key落在Entry数组的哪个bucket桶上，获取该bucket桶上的元素e,进而遍历e的链表，找相对应的key,若找到则返回key所对应的value值，找不到则返回null    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];e != null;e = e.next) {        Object k;        //若元素e.hash == 上面计算的hash值，并且(e.key 和入参key是同一个对象的引用，或者e.key和入参key equals相等)，        //则认为入参key和当前遍历的元素e的key是同一个,返回e的value值        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))            return e.value;    }    //上面遍历了一遍也没有找到，则返回null    return null;}//获取key为null的value值，由上面putForNullKey方法可知，key为null的键值对，被放在了Entry数组table的第一个bucket桶(table[0])private V getForNullKey() {    //获取Entry数组table的第一个元素e,从e开始往下遍历，若找到元素e.key 为null的，则直接返回该元素e.value值    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {        //找到元素e.key 为null的，则直接返回该元素e.value值        if (e.key == null)            return e.value;    }    //从table[0]开始，遍历链表一遍，没有找到key为null的，则返回null    return null;}</code></pre><p>从上面可以看出HashMap中判断key是否相等的条件是hash值相等且equals，提起这个我要引申下，正因为如此，重写equals时也要同时覆盖hashcode，具体可以看这些帖子<a href="https://blog.csdn.net/qq_34970891/article/details/80707259" target="_blank" rel="noopener">HashMap中判断两个key是否为同一个key详解</a>、<a href="https://blog.csdn.net/java_weekly/article/details/80608231" target="_blank" rel="noopener">HashMap中key是否相等的判断</a>、<a href="https://www.cnblogs.com/chengxiao/p/6059914.html" target="_blank" rel="noopener">HashMap实现原理及源码分析中第四点</a>。</p><h3 id="五、HashMap的resize（扩容操作）"><a href="#五、HashMap的resize（扩容操作）" class="headerlink" title="五、HashMap的resize（扩容操作）"></a>五、HashMap的resize（扩容操作）</h3><p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，而在HashMap数组扩容之后，<strong>最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize</strong>。</p><p>那么HashMap什么时候进行扩容呢？前面讲put操作里有提到，当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的<strong>threshold</strong>值，也叫做临界值）的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p><pre><code>/***将HashMap中Entry数组table的容量扩容至新容量newCapacity,数组的扩容不但涉及到数组元素的复制，还要将原数组中的元素rehash到新的数组中，很耗时;如果能预估到放入HashMap中元素的大小，最好使用new HashMap(size)方式创建足够容量的HashMap，避免不必要的数组扩容(rehash操作)，提高效率*/void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    //如果原数组的大小已经为允许的最大值MAXIMUM_CAPACITY了，则不能进行扩容了，这里仅仅将极限threshold设置为Integer.MAX_VALUE，然后返回    if (oldCapacity == MAXIMUM_CAPACITY) {        //将极限threshold设置为Integer.MAX_VALUE        threshold = Integer.MAX_VALUE;        return;    }    //程序走到这，说明可以进行扩容，先创建容量为newCapacity的新Entry数组newTable    Entry[] newTable = new Entry[newCapacity];    //调用tranfer(Entry[] newTable)方法，进行数组元素的移动和rehashing    transfer(newTable);    //将新数组newTable赋值给table    table = newTable;    //计算极限threshold的最新值    threshold = (int)(newCapacity * loadFactor);}//将原Entry数组table中的所有键值对迁移到新Entry数组newTable上void transfer(Entry[] newTable) {    //原数组赋值给src    Entry[] src = table;    //新数组长度为newCapacity    int newCapacity = newTable.length;    //遍历原数组    for (int j = 0; j &lt; src.length; j++) {        //获取原数组中的元素(键值对),赋值给e        Entry&lt;K,V&gt; e = src[j];        //若元素e不为null        if (e != null) {            //释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）            src[j] = null;            //遍历元素e所对应的bucket桶内的所有元素            do {                //获取下一个元素next                Entry&lt;K,V&gt; next = e.next;                //重新计算键值对e在新数组newTable中的bucketIndex位置(即rehash操作)                int i = indexFor(e.hash, newCapacity);                //标记[1]                e.next = newTable[i];                //将当前元素e放入新数组的i位置                newTable[i] = e;                //访问下一个Entry链上的元素                e = next;            } while (e != null);        }    }}</code></pre><p>关于rehash操作，可以看看这篇帖子的第六点<a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a>，讲得很形象，助我理解了很多，感谢作者。</p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>理解完HashMap我认为需要通过一些面试题来加深印象补缺补漏，来了<a href="https://blog.csdn.net/weixin_42636552/article/details/82016183" target="_blank" rel="noopener">HashMap面试常问问题</a>、<a href="https://www.cnblogs.com/qfxydtk/p/8734784.html" target="_blank" rel="noopener">HashMap常问面试题整理</a>，这两篇还是挺好的。</p><hr><p>其实写这篇HashMap小总结花了我不少时间，源码分析还是比较累的吧。。接下来我可能不能保持一周两更的频率了，学校事多，最近也想做做项目练手，主要还是自己懒吧，有点吃力，不够努力。</p><p>参考博文：</p><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p><p><a href="https://www.cnblogs.com/skywang12345/p/3310835.html" target="_blank" rel="noopener">Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例</a> </p><p><a href="https://www.cnblogs.com/xwdreamer/archive/2012/06/03/2532832.html" target="_blank" rel="noopener">深入Java集合学习系列：HashMap的实现原理</a></p><p><a href="https://www.cnblogs.com/lewis0077/p/5347061.html" target="_blank" rel="noopener">HashMap 源码解析</a></p><p><a href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Java HashMap工作原理及实现</a></p>]]></content>
      
      <categories>
          
          <category> 基础与进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2018/10/21/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/10/21/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>这周还是坚持二更了。</p><p>Java内存模型是进阶Java并发编程的基础，也是面试中的重点，概念不好和Java内存区域搞混，今天着重整理一下。</p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>Java内存模型（即Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。 </p><h3 id="二、主内存与工作内存"><a href="#二、主内存与工作内存" class="headerlink" title="二、主内存与工作内存"></a>二、主内存与工作内存</h3><p>在说主内存与工作内存之前，我想说点其他东西。学过计算机组成原理的同学都知道，由于计算机的存储设备与处理器的运算能力之间有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中没这样处理器就无需等待缓慢的内存读写了。</p><p>基于高速缓存的存储交互很好的解决了处理器与内存之间的矛盾，但也引入了新的问题：缓存一致性问题。在多处理器系统中，每个处理器有自己的高速缓存，而他们又共享同一块内存（下文称主存，main memory主要内存），当多个处理器运算都涉及到同一块内存区域的时候，就有可能发生缓存不一致的现象。为了解决这一问题，需要各个处理器运行时都遵循一些协议，在运行时需要将这些协议保证数据的一致性。这类协议包括MSI、MESI、MOSI等。如下图所示： </p><img src="/2018/10/21/Java内存模型/1.jpg"><p>主内存与工作内存之间的关系就好像主存和高速缓存之间的关系，如图：</p><img src="/2018/10/21/Java内存模型/2.jpg"><p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如上图所示。 </p><p><strong>这里所讲的主内存、工作内存与 Java内存区域中的 Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上没有关系，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。</strong>从更低层次上说，主内存就直接对应于物理硬件内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时注意访问读写的是工作内存。 </p><h3 id="三、内存间交互操作"><a href="#三、内存间交互操作" class="headerlink" title="三、内存间交互操作"></a>三、内存间交互操作</h3><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p><ul><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a、read b、load b、load a。除此之外，Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：</p><ul><li>不允许read和load、store和write操作之一单独出现。</li><li>不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，lock和unlock必须成对出现。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li><li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。</li></ul><h3 id="四、重排序"><a href="#四、重排序" class="headerlink" title="四、重排序"></a>四、重排序</h3><p>在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。重排序分成三种类型：</p><ul><li><p>编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</p></li><li><p>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p></li><li><p>内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ul><p>从Java源代码到最终实际执行的指令序列，会经过下面三种重排序：</p><img src="/2018/10/21/Java内存模型/3.png"><p>为了保证内存的可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。Java内存模型把内存屏障分为LoadLoad、LoadStore、StoreLoad和StoreStore四种： </p><img src="/2018/10/21/Java内存模型/4.png"><h3 id="五·、Java内存模型特性"><a href="#五·、Java内存模型特性" class="headerlink" title="五·、Java内存模型特性"></a>五·、Java内存模型特性</h3><h5 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h5><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。比如对于一个静态变量int x，两条线程同时对他赋值，线程A赋值为1，而线程B赋值为2，不管线程如何运行，最终x的值要么是1，要么是2，线程A和线程B间的操作是没有干扰的，这就是原子性操作，不可被中断的特点。</p><p>由Java内存模型来直接保证的原子性变量包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大方位的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式的使用这两个操作，这两个字节码指令反应到Java代码中就是同步块–synchronized关键字，<strong>因此在synchronized块之间的操作也具备原子性。</strong> </p><p>有点要注意的是，<strong>对于32位系统的来说，基本数据类型byte、short、int、float、boolean、char数据的读写是原子操作，但long类型数据和double类型数据它们的读写并非原子性的，也就是说如果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的。</strong>因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样可能会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值。但也不必太担心，因为读取到“半个变量”的情况比较少见，<strong>至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原子操作来执行，因此对于这个问题不必太在意，</strong>知道这么回事即可。</p><h5 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h5><p>一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）。</p><p>Java内存模型是通过将在工作内存中的变量修改后的值同步到主内存，在读取变量前从主内存刷新最新值到工作内存中，这种依赖主内存的方式来实现可见性的。</p><p>无论是普通变量还是volatile变量都是如此，区别在于：volatile的特殊规则保证了volatile变量值修改后的新值立刻同步到主内存，每次使用volatile变量前立即从主内存中刷新，因此volatile保证了多线程之间的操作变量的可见性，而普通变量则不能保证这一点。（volatile关键字下面会着重讲解）</p><p><strong>除了volatile关键字能实现可见性之外，还有synchronized、Lock、final也是可以的。</strong></p><p>使用synchronized关键字，在同步方法/同步块开始时（Monitor Enter）,使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在同步方法/同步块结束时(Monitor Exit),会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。</p><p>使用Lock接口的最常用的实现ReentrantLock(重入锁)来实现可见性：当我们在方法的开始位置执行lock.lock()方法，这和synchronized开始位置（Monitor Enter）有相同的语义，即使用共享变量时会从主内存中刷新变量值到工作内存中（即从主内存中读取最新值到线程私有的工作内存中），在方法的最后finally块里执行lock.unlock()方法，和synchronized结束位置（Monitor Exit）有相同的语义,即会将工作内存中的变量值同步到主内存中去（即将线程私有的工作内存中的值写入到主内存进行同步）。</p><p>final关键字的可见性是指：被final修饰的变量，在构造函数数一旦初始化完成，并且在构造函数中并没有把“this”的引用传递出去（“this”引用逃逸是很危险的，其他的线程很可能通过该引用访问到只“初始化一半”的对象），那么其他线程就可以看到final变量的值。</p><h5 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h5><p>对于一个线程的代码而言，我们总是以为代码的执行是从前往后的，依次执行的。这么说不能说完全不对，在单线程程序里，确实会这样执行；但是在多线程并发时，程序的执行就有可能出现乱序。用一句话可以总结为：<strong>在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行语义（WithIn Thread As-if-Serial Semantics）”,后半句是指“指令重排”现象和“工作内存和主内存同步延迟”现象。</strong></p><p><strong>Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性，volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现。</strong></p><p><em>介绍完并发的3个特性后，我们发现synchronized关键字在需要这三种特性的时候都可以作为其中一种解决方案。</em></p><h3 id="六、volatile关键字"><a href="#六、volatile关键字" class="headerlink" title="六、volatile关键字"></a>六、volatile关键字</h3><p>关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整的理解，以至于许多程序员都不习惯去使用它，遇到需要处理多线程的问题的时候一律使用synchronized来进行同步。了解volatile变量的语义对后面了解多线程操作的其他特性很有意义。Java内存模型对volatile专门定义了一些特殊的访问规则，当一个变量被定义成volatile之后，他将具备两种特性： </p><ul><li>保证此变量对所有线程的可见性。<strong>第一保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</strong>而普通变量是做不到这点，普通变量的值在线程在线程间传递均需要通过住内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行会写，另外一个线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。<strong>另外，Java里面的运算并非原子操作，会导致volatile变量的运算在并发下一样是不安全的，也就是说volatile关键字不能保证原子性。</strong></li><li>禁止指令重排序优化。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获得正确的结果，而不能保证变量赋值操作的顺序与程序中的执行顺序一致，在单线程中，我们是无法感知这一点的。</li></ul><p>由于volatile变量只能保证可见性，<strong>在不符合以下两条规则的运算场景中，我们仍然要通过加锁来保证原子性。</strong> </p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态比阿尼浪共同参与不变约束。</li></ul><p>前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p><p>观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><ul><li><p>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</p></li><li><p>它会强制将对缓存的修改操作立即写入主存。</p></li><li><p>如果是写操作，它会导致其他CPU中对应的缓存行无效。</p></li></ul><h3 id="七、happens-before原则（先行发生原则）"><a href="#七、happens-before原则（先行发生原则）" class="headerlink" title="七、happens-before原则（先行发生原则）"></a>七、happens-before原则（先行发生原则）</h3><p><strong>Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，</strong>“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>倘若在程序开发中，仅靠sychronized和volatile关键字来保证有序性，那么编写并发程序可能会显得十分麻烦，幸运的是，并不是所有的操作都是由volatile和synchronized实现的，Java中存在”先行发生“的原则。先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据。 </p><h5 id="1-什么是先行发生原则？"><a href="#1-什么是先行发生原则？" class="headerlink" title="1.什么是先行发生原则？"></a>1.什么是先行发生原则？</h5><p>举例说明： </p><pre><code>//以下操作在线程A中执行i = 1;//以下操作在线程B中执行j = i;//以下操作在线程C中执行i = 2;</code></pre><p>假设线程A中的操作 i=1先行发生于线程B的操作 j=i ，那么可以确定在线程B的操作执行之后，j一定等于1。因为根据先行发生原则，i=1的结果可以被B观察到。</p><p>先行发生原则就是操作A在时间上或者逻辑上比B先发生，如果B能看到A操作带来的影响（修改了共享变量的值等等），那么此时A就是先行发生于B。你可能会说难道B还有可能不会看到A带来的影响吗？A操作先执行的呀！想一想我们上面提到的可见性和有序性 。。</p><h5 id="2-先行发生原则都有哪些？"><a href="#2-先行发生原则都有哪些？" class="headerlink" title="2.先行发生原则都有哪些？"></a>2.先行发生原则都有哪些？</h5><p>下面是Java内存模型下一些”天然的“happens-before关系，这些happens-before关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。</p><ul><li><p>程序次序规则（Pragram Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。</p></li><li><p>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。</p></li><li><p>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。</p></li><li><p>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</p></li><li><p>线程终于规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。</p></li><li><p>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。</p></li><li><p>对象终结规则（Finalizer Rule）：一个对象初始化完成（构造方法执行完成）先行发生于它的finalize()方法的开始。</p></li><li><p>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p></li></ul><p><strong>一个操作”时间上的先发生“不代表这个操作会是”先行发生“，那如果一个操作”先行发生“是否就能推导出这个操作必定是”时间上的先发生 “呢？也是不成立的，一个典型的例子就是指令重排序。所以时间上的先后顺序与先行发生原则之间基本没有什么关系，所以衡量并发安全问题一切必须以先行发生原则为准。</strong></p><hr><p>终于把Java内存模型相关知识点理清楚了，我发现有关JVM的内容都好多啊，赶紧记录下什么时候觉得忘了就翻翻。</p><p>参考博文：<a href="https://www.cnblogs.com/nexiyi/p/java_memory_model_and_thread.html" target="_blank" rel="noopener">Java内存模型</a>、<a href="https://www.cnblogs.com/lewis0077/p/5143268.html" target="_blank" rel="noopener">浅析java内存模型–JMM(Java Memory Model)</a></p><p>参考资料：《深入理解Java虚拟机：JVM高级特性与最佳实践》</p>]]></content>
      
      <categories>
          
          <category> 基础与进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM垃圾回收总结</title>
      <link href="/2018/10/19/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2018/10/19/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>啥也不说了，这几天下来觉得最重要的还是身体，其他都好说。。</p><p>这两周可能做不到一周二更，以后有机会补上漏的。</p><p>这篇的主题是非常重要的，JVM学习的核心部分，所以这篇我会尽力写得更认真，更全面。</p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>说起垃圾回收（Garbage Collection，GC），很多人就会自然而然地把它和Java联系起来。事实上，GC的历史比Java久远，早在1960年Lisp这门语言中就使用了内存动态分配和垃圾回收技术。 在Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，顾名思义，垃圾回收就是释放垃圾占用的空间，这一切都交给了JVM来处理。本文主要解答四个问题：</p><p>1、哪些内存需要回收？（对象是否可以被回收的两种经典算法：引用计数法和可达性分析算法） </p><p>2、如何回收？（三种经典垃圾回收算法：标记-清除算法、复制算法、标记-整理算法，以及分代收集算法） </p><p>3、使用什么工具回收？（垃圾收集器）</p><p>4、Java堆内存分配与回收策略是怎样的？（新生代：Eden区、From Survivor、To Survivor，以及老年代）</p><p>在探讨Java垃圾回收机制之前，我们首先应该记住一个单词：Stop The World。Stop The World意味着 JVM由于要执行GC而停止了应用程序的执行，并且这种情形会在任何一种GC算法中发生。当Stop The World发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成。事实上，GC优化很多时候就是指减少Stop The World发生的时间，从而使系统具有高吞吐 、低停顿的特点。 </p><h3 id="二、哪些内存需要回收？"><a href="#二、哪些内存需要回收？" class="headerlink" title="二、哪些内存需要回收？"></a>二、哪些内存需要回收？</h3><p>我们都知道JVM的内存结构包括五大区域：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。其中程序计数器、Java虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，这几个区域的内存分配和回收都具备确定性，就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。<strong>而Java堆和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。</strong></p><p>垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法。</p><h5 id="1-JVM垃圾判定算法"><a href="#1-JVM垃圾判定算法" class="headerlink" title="1.JVM垃圾判定算法"></a>1.JVM垃圾判定算法</h5><p>常用的垃圾判定算法包括：引用计数算法，可达性分析算法。 </p><p>(1)引用计数算法</p><p>引用计数算法是垃圾收集器中的早期策略。引用计数算法描述为：给对象增加一个引用计数器，每当有一个地方引用它时，计数器就+1；当引用失效时，计数器就-1；任何时刻计数器为0的对象就是不能再被使用的，即对象已“死”。 </p><p>引用计数法实现简单，判定效率也比较高，在大部分情况下都是一个比较好的算法。比如Python语言就是采用的引用计数法来进行内存管理的。<strong>但是，在主流的JVM中没有选用引用计数法来管理内存，最主要的原因是引用计数法无法解决对象的循环引用问题。</strong> </p><pre><code>public class Main {    public static void main(String[] args) {        MyTest test1 = new MyTest();//MyTest实例1的引用计数加1，实例1的引用计数=1；        MyTest test2 = new MyTest();//MyTest实例2的引用计数加1，实例2的引用计数=1；        //test1与test2存在相互引用        test1.obj = test2;//MyTest实例2的引用计数加1，实例2的引用计数=2；        test2.obj = test1;//MyTest实例1的引用计数加1，实例1的引用计数=2；        test1 = null;//栈帧中test1不再指向Java堆，MyTest实例1的引用计数减1，结果为1；        test2 = null;//栈帧中test2不再指向Java堆，MyTest实例2的引用计数减1，结果为1；        System.gc();//回收        //到此，发现MyTest实例1和实例2的计数引用都不为0，那么如果采用的引用计数算法的话，那么这两个实例所占的内存将得不到释放，这便产生了内存泄露。    }}class MyTest{    public Object obj = null;}</code></pre><p>虽然最后将test1和test2赋值为null，也就是说test1和test2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。运行程序，从内存分析看到，事实上这两个对象的内存被回收，这也说明了当前主流的JVM都不是采用的引用计数器算法作为垃圾判定算法的。 </p><p>(2)可达性分析算法</p><p>可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。 </p><img src="/2018/10/19/JVM垃圾回收总结/gc-root.png"><p>上图红色为无用的节点，可以被回收。</p><p>目前Java中可以作为GC Roots的对象有：</p><ul><li><p>虚拟机栈中引用的对象（本地变量表）；</p></li><li><p>方法区中静态属性引用的对象；</p></li><li><p>方法区中常亮引用的对象；</p></li><li><p>本地方法栈中引用的对象（Native对象）；</p></li></ul><p>基本所有GC算法都引用可达性分析算法这种概念。</p><h5 id="2-对象死亡前最后的机会"><a href="#2-对象死亡前最后的机会" class="headerlink" title="2.对象死亡前最后的机会"></a>2.对象死亡前最后的机会</h5><p>在可达性分析算法中，不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否需要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“不需要要执行”。注意任何对象的finalize()方法只会被系统自动执行1次。</p><p>如果这个对象被判定为需要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。因此调用finalize()方法不代表该方法中代码能够完全被执行。</p><p>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。从如下代码中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。</p><pre><code>/**    * 此代码演示了两点：    * 1.对象可以在被GC时自我拯救。    * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次    */    public class FinalizeEscapeGC {        public static FinalizeEscapeGC SAVE_HOOK = null;        public void isAlive() {            System.out.println(&quot;yes, i am still alive :)&quot;);        }        @Override        protected void finalize() throws Throwable {             super.finalize();            System.out.println(&quot;finalize mehtod executed!&quot;);            FinalizeEscapeGC.SAVE_HOOK = this;        }        public static void main(String[] args) throws Throwable {            SAVE_HOOK = new FinalizeEscapeGC();            //对象第一次成功拯救自己            SAVE_HOOK = null;            System.gc();            //因为finalize方法优先级很低，所以暂停0.5秒以等待它            Thread.sleep(500);            if(SAVE_HOOK != null) {            SAVE_HOOK.isAlive();            } else {                System.out.println(&quot;no, i am dead :(&quot;);            }            //下面这段代码与上面的完全相同，但是这次自救却失败了            SAVE_HOOK = null;            System.gc();            //因为finalize方法优先级很低，所以暂停0.5秒以等待它            Thread.sleep(500);            if(SAVE_HOOK != null) {                SAVE_HOOK.isAlive();            } else {                System.out.println(&quot;no, i am dead :(&quot;);            }        }    }</code></pre><p>运行结果： </p><pre><code>finalize mehtod executed!    yes, i am still alive :)    no, i am dead :(</code></pre><p>从运行结果可以看出，SAVE_HOOK对象的finalize()方法确实被GC收集器调用过，且在被收集前成功逃脱了。另外一个值得注意的地方是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。 </p><h3 id="三、如何回收？"><a href="#三、如何回收？" class="headerlink" title="三、如何回收？"></a>三、如何回收？</h3><h5 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1.垃圾回收算法"></a>1.垃圾回收算法</h5><p>(1)标记-清除算法（Mark-Sweep）（DVM使用的算法）</p><p>标记-清除算法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。 </p><img src="/2018/10/19/JVM垃圾回收总结/1.png"><p>(2)复制算法（Copying）</p><p>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 </p><img src="/2018/10/19/JVM垃圾回收总结/2.png"><p>复制算法在存活对象比较少的时候，极为高效，但是带来的成本是牺牲一半的内存空间用于进行对象的移动。<strong>所以复制算法的使用场景，必须是对象的存活率非常低才行，</strong>而且最重要的是，我们需要克服50%内存的浪费。</p><p>(3)标记-整理算法（Mark-Compact）</p><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记、清除，但在回收不存活的对象占用的空间后，会将所有存活的对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法之上，又进行了对象的移动排序整理，因此成本更高，但却解决了内存碎片的问题。</p><img src="/2018/10/19/JVM垃圾回收总结/3.png"><p>标记-整理算法提高了内存的利用率，并且它适合在收集对象存活时间较长的老年代。 </p><p>(4)分代收集算法（Generational Collection） </p><p>当前JVM垃圾收集都采用的是分代收集算法，这个算法并没有新思想，只是根据对象存活周期的不同将内存划分为几块。 </p><p><strong>一般是把Java堆分为新生代和老年代。在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，因此我们采用复制算法，新生代发生的GC也叫做Minor GC；而老年代中对象存活率高、没有额外空间对它进行分配担保，就必须采用标记-清理算法或者标记-整理算法，老年代发生的GC也叫做Major GC即Full GC。</strong></p><p>面试题: 请问了解Minor GC和Full GC么，这两种GC有什么不一样吗？</p><ul><li><p>Minor GC又称为新生代GC : 指的是发生在新生代的垃圾收集。因为Java对象大多都具备朝生夕灭的特性，因此Minor GC（采用复制算法）非常频繁，一般回收速度也比较快。</p></li><li><p>Full GC又称为老年代GC或者Major GC : 指发生在老年代的垃圾收集。出现了Major GC，经常会伴随至少一次的Minor GC(并非绝对，在Parallel Scavenge收集器中就有直接进行Full GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</p></li></ul><h3 id="四、使用什么工具回收？"><a href="#四、使用什么工具回收？" class="headerlink" title="四、使用什么工具回收？"></a>四、使用什么工具回收？</h3><h5 id="1-垃圾回收器简介"><a href="#1-垃圾回收器简介" class="headerlink" title="1.垃圾回收器简介"></a>1.垃圾回收器简介</h5><p>需要注意的是，<strong>每一个回收器都存在Stop The World的问题，</strong>只不过各个回收器在Stop The World时间优化程度、算法的不同，可根据自身需求选择适合的回收器。</p><p>整理一下新生代和老年代的收集器。</p><p>新生代收集器：</p><ul><li><p>Serial （-XX:+UseSerialGC）</p></li><li><p>ParNew（-XX:+UseParNewGC）</p></li><li><p>ParallelScavenge（-XX:+UseParallelGC）</p></li><li><p>G1 收集器</p></li></ul><p>老年代收集器：</p><ul><li><p>SerialOld（-XX:+UseSerialOldGC）</p></li><li><p>ParallelOld（-XX:+UseParallelOldGC）</p></li><li><p>CMS（-XX:+UseConcMarkSweepGC）</p></li><li><p>G1 收集器</p></li></ul><p>这里就不详细介绍目前的7种垃圾收集器了，贴个博文，写得很详细，<a href="https://www.cnblogs.com/chengxuyuanzhilu/p/7088316.html" target="_blank" rel="noopener">JVM(HotSpot) 7种垃圾收集器的特点及使用场景</a>。</p><h3 id="五、Java堆内存分配与回收策略"><a href="#五、Java堆内存分配与回收策略" class="headerlink" title="五、Java堆内存分配与回收策略"></a>五、Java堆内存分配与回收策略</h3><p>Java堆一般分为2个大的区域： 默认的新生代（Young generation）、老年代（Old generation）。所占空间比例为 1 : 2 。</p><h5 id="1-新生代空间的构成与逻辑"><a href="#1-新生代空间的构成与逻辑" class="headerlink" title="1.新生代空间的构成与逻辑"></a>1.新生代空间的构成与逻辑</h5><p>为了更好的理解GC，我们来学习新生代的构成，它用来保存那些第一次被创建的对象，它被分成三个空间：</p><ul><li><p>一个伊甸园空间（Eden）</p></li><li><p>两个幸存者空间（From Survivor、To Survivor）</p></li></ul><p><strong>默认新生代空间的分配：Eden : From : To = 8 : 1 : 1</strong></p><img src="/2018/10/19/JVM垃圾回收总结/4.png"><p>一般情况下，新创建的对象都会被分配到Eden区（一些大对象直接进入老年代），这些对象经过第一次Minor GC后，如果仍然存活，将会被移到From Survivor区。在之后GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，经过一次GC每个存活对象年龄+1，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值（年龄阈值，可以通过-XX:MaxTenuringThreshold来设置，默认15）的对象会被移动到老年代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到To区不够容纳来自Eden区和From区的存活对象，就会发生空间分配担保，将To区无法容纳对象直接进入老年代中。  </p><p>从上面的步骤可以发现，<strong>两个Survivor区，必须有一个是保持空的</strong>。如果两个Survivor区都有数据，或两个Survivor区都是空的，那一定是你的系统出现了某种错误。</p><h5 id="2-老年代空间的构成与逻辑"><a href="#2-老年代空间的构成与逻辑" class="headerlink" title="2.老年代空间的构成与逻辑"></a>2.老年代空间的构成与逻辑</h5><p>老年代空间的构成其实很简单，它不像新生代空间那样划分为几个区域，它只有一个区域，里面存储的对象并不像新生代空间绝大部分都是朝闻道，夕死矣。<strong>这里的对象几乎都是从Survivor 空间中熬过来的，它们绝不会轻易的狗带</strong>。因此，Full GC（Major GC）发生的次数不会有Minor GC 那么频繁，并且做一次Major GC 的时间比Minor GC 要更长（约10倍）。</p><hr><p>好了，关于JVM垃圾回收就总结这么多了，还有GC日志如何查看和一些JVM参数可以查看这两篇博文：<a href="https://www.cnblogs.com/sunshisonghit/p/6694590.html" target="_blank" rel="noopener">（转）java中新生代和老年代</a>、<a href="https://blog.csdn.net/u013417227/article/details/79408645" target="_blank" rel="noopener">java堆内存–新生代和老年代</a>。</p><p>参考资料：《深入理解Java虚拟机：JVM高级特性与最佳实践》</p>]]></content>
      
      <categories>
          
          <category> 基础与进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>抽象类和接口</title>
      <link href="/2018/10/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2018/10/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      <content type="html"><![CDATA[<p>我发现刷题有关接口和抽象类的知识点是常考点，也是易错点。今天来总结下，做个记录。</p><h3 id="一、抽象类"><a href="#一、抽象类" class="headerlink" title="一、抽象类"></a>一、抽象类</h3><h5 id="1-抽象方法和抽象类"><a href="#1-抽象方法和抽象类" class="headerlink" title="1.抽象方法和抽象类"></a>1.抽象方法和抽象类</h5><p>抽象方法和抽象类必须使用abstract 修饰符来定义，<strong>有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法。</strong> </p><p>抽象方法和抽象类的规则如下：</p><ul><li><p>抽象类必须使用abstract修饰符来修饰，抽象方法也必须使用abstract修饰符来修饰，抽象方法不能有方法体。</p></li><li><p>抽象类不能被实例化，无法使用new关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法，这个抽象类也不能创建实例。</p></li></ul><ul><li>抽象类可以包含成员变量、方法（普通方法和抽象方法都可以）、构造器、初始化块、内部类(接口、枚举)5种成分。抽象类的构造器不能用于创建实例，主要是用于被其子类调用。</li></ul><ul><li>含有抽象方法的类（包括直接定义了一个抽象方法；或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或实现了一个接口，但没有完全实现接口包含的抽象方法三种情况）只能被定义成抽象类。  </li></ul><p>注意：</p><ul><li><p>定义抽象方法只需在普通方法上增加abstract 修饰符，并把普通方法的方法体（也就是方法后花括号括起来的部分）全部去掉，并在方法后增加分号即可。  </p></li><li><p>抽象方法和空方法体的方法不是同一个概念。例如，public abstract void test();是一个抽象方法，它根本没有方法体，即方法定义后面没有一对花括号；但public void test(){}方法是一个普通方法，它已经定义了方法体，只是方法体为空，即它的方法体什么也不做，因此这个方法不可使用abstract 来修饰。</p></li></ul><p>当使用abstract修饰类时，表明这个类只能被继承；当使用abstract修饰方法时，表明这个方法必须由子类提供实现(即重写)。而final修饰的类不能被继承，final 修饰的方法不能被重写。<strong>因此final和abstract永远不能同时使用。</strong></p><p>注意：</p><ul><li>abstract不能用于修饰成员变量，不能用于修饰局部变量，即没有抽象变量、没有抽象成员变量等说法；abstract也不能用于修饰构造器，没有抽象构造器，抽象类里定义的构造器只能是普通构造器。</li></ul><p>除此之外，当使用static修饰一个方法时，表明这个方法属于该类本身，即通过类就可调用该方法，但如果该方法被定义成抽象方法，则将导致通过该类来调用该方法时出现错误（调用了一个没有方法体的方法肯定会引起错误）。<strong>因此static和abstract不能同时修饰某个方法，即没有所谓的类抽象方法。</strong></p><p>注意：</p><ul><li>static和abstract并不是绝对互斥的，static 和abstract虽然不能同时修饰某个方法，但它们可以同时修饰内部类。</li><li>abstract关键字修饰的方法必须被其子类重写才有意义，否则这个方法将永远不会有方法体，因此abstract方法不能定义为private访问权限，即private和abstract不能同时修饰方法。</li></ul><h5 id="2-通过抽象类实现多态"><a href="#2-通过抽象类实现多态" class="headerlink" title="2.通过抽象类实现多态"></a>2.通过抽象类实现多态</h5><pre><code>package com.test;//抽象Pet类public abstract class Pet {    public abstract void cry();}//Dog类继承实现抽象类Petpublic class Dog extends Pet {    //实现父类抽象方法cry()    public void cry() {        System.out.println(&quot;汪汪汪&quot;);    }}//Cat类继承实现抽象类Petpublic class Cat extends Pet {    //实现父类抽象方法cry()    public void cry() {        System.out.println(&quot;喵喵喵&quot;);    }}//测试类public class TestAbstract {    public static void main(String[] args) {        // TODO Auto-generated method stub        Pet cat = new Cat();        Pet dog = new Dog();        cat.cry();        dog.cry();    }}</code></pre><p>上面main()方法中定义了两个Pet类型的引用变量，它们分别指向Cat对象和Dog对象。由于在Pet类中定义了cry()方法，所以程序可以直接调用cat变量和dog变量的cry()方法，无须强制类型转换为其子类类型。</p><p>利用抽象类和抽象方法的优势，可以更好地发挥多态的优势，使得程序更加灵活。</p><h3 id="二、接口"><a href="#二、接口" class="headerlink" title="二、接口"></a>二、接口</h3><h5 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1.接口的定义"></a>1.接口的定义</h5><p>和类定义不同，定义接口不再使用class关键字，而是使用interface关键字。接口定义的基本语法如下:  </p><pre><code>[修饰符] interface 接口名 extends 父接口1, 父接口2...{    零个到多个常量定义...    零个到名个抽象方法定义...    零个到多个内部类、接口、枚举定义...    零个到多个默认方法或类方法定义...}</code></pre><p>对上面语法的详细说明如下：</p><ul><li><p>修饰符可以是public或者省略，如果省略了public访问控制符，则默认采用包权限访问控制符，即只有在相同包结构下才可以访问该接口。</p></li><li><p>接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可；如果要遵守Java可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无须任何分隔符。接口名通常能够使用形容词。</p></li><li><p>一个接口可以有多个直接父接口，但接口只能继承接口，不能继承类。</p></li></ul><p><strong>在上面语法定义中，只有在Java8以上的版本中才允许在接口中定义默认方法、类方法。</strong></p><p><strong>由于接口定义的是一种规范，因此接口里不能包含构造器和初始化块定义。接口里可以包含成员变量（只能是静态常量）、方法（只能是抽象实例方法、类方法或默认方法）、内部类（包括内部接口、枚举）定义。</strong><br>对比接口和类的定义方式，不难发现接口的成员比类里的成员少了两种，而且接口里的成员变量只能是静态常量，接口里的方法只能是抽象方法、类方法或默认方法。<br>前面已经说过了，接口里定义的是多个类共同的公共行为规范，<strong>因此接口里的所有成员，包括常量、方法、内部类和内部枚举都是public访问权限。</strong>定义接口成员时，可以省略访问控制修饰符，如果指定访问控制修饰符，则只能使用public访问控制修饰符。<br><strong>对于接口里定义的静态常量而言，它们是接口相关的，因此系统会自动为这些成员变量增加static和final两个修饰符。也就是说，在接口中定义成员变量时，不管是否使用public static final 修饰符，接口里的成员变量总是使用这三个修饰符来修饰。而且接口里没有构造器和初始化块，因此接口里定义的成员变量只能在定义时指定默认值。</strong></p><p>接口里定义成员变量采用如下两行代码的结果完全一样。</p><pre><code>//系统自动为接口里定义的成员变量增加public static final修饰符int MAX_SIZE = 50;public static final int MAX_SIZE = 50;</code></pre><p>接口里定义的方法只能是抽象方法、类方法或默认方法，因此如果不是定义默认方法，系统将自动为普通方法增加abstract修饰符；<strong>定义接口里的普通方法时不管是否使用public abstract修饰符，接口里的普通方法总是使用public abstract来修饰。接口里的普通方法不能有方法实现（方法体）；但类方法、默认方法都必须有方法实现（方法体）。</strong></p><p>注意：</p><ul><li>接口里定义的内部类、内部接口，内部枚举默认都采用public static两个修饰符，不管定义时是否指定这两个修饰符，系统都会自动使用public static对它们进行修饰。</li></ul><h5 id="2-接口的继承"><a href="#2-接口的继承" class="headerlink" title="2.接口的继承"></a>2.接口的继承</h5><p>接口的继承和类继承不一样，接口完全支持多继承，即一个接口可以有多个直接父接口。和类继承相似，子接口扩展某个父接口，将会获得父接口里定义的所有抽象方法、常量。<br>一个接口继承多个父接口时，多个父接口排在extends关键字之后，多个父接口之间以英文逗号(,)隔开。下面程序定义了三个接口，第三个接口继承了前面两个接口。</p><pre><code>interface interfaceA {    int PROP_ A = 5;    void testA();}interface interfaceB {    int PROP_ B = 6;    void testB();}interface interfaceC extends interfaceA, interfaceB {    int PROP_ C = 7;    void testC();}public class InterfaceExtendsTest {    public static void main(String[] args) {        System.out.println(interfaceC.PROP_ A);        System.out.println(interfaceC.PROP_ B);        System.out.println(interfaceC.PROP_ C);    }}</code></pre><p>上面程序中的itetfaceC接口继承了interfaceA和interfaceB，所以interfaceC中获得了它们的常量，因此在main()方法中看到通过interfaceC来访问PROP_ A、PROP_ B和PROP_C常量。</p><h3 id="三、抽象类和接口"><a href="#三、抽象类和接口" class="headerlink" title="三、抽象类和接口"></a>三、抽象类和接口</h3><p>接口和抽象类很像，它们都具有如下特征。</p><ul><li>接口和抽象类都不能被实例化，它们都位于继承树的顶端，用于被其他类实现和继承。</li></ul><ul><li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</li></ul><p>但接口和抽象类之间的差别非常大，这种差别主要体现在二者设计目的上。下面具体分析二者的差别。</p><p>接口作为系统与外界交互的窗口，接口体现的是一种规范。对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务（以方法的形式来提供）；对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务（就是如何来调用方法）。当在一个程序中使用接口时，接口是多个模块间的耦合标准；当在多个应用程序之间使用接口时，接口是多个程序之间的通信标准。</p><p>从某种程度上来看，接口类似于整个系统的“总纲”，它制定了系统各模块应该遵循的标准，因此一个系统中的接口不应该经常改变。一旦接口被改变，对整个系统其至其他系统的影响将是辐射式的，导致系统中大部分类都需要改写。</p><p>抽象类则不一样， 抽象类作为系统中多个子类的共同父类，它所体现的是一种模板式设计。 抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能（那些已经提供实现的方法），但这个产品依然不能当成最终产品，必须有更进一步的完善， 这种完兽可能有几种不同方式。</p><p>除此之外，接口和抽象类在用法上也存在如下差别：</p><ul><li><p>接口里只能包含抽象方法、静态方法和默认方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。</p></li><li><p>接口里不能定义静态方法（Java8之前）；抽象类里可以定义静态方法。</p></li></ul><ul><li>接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。</li></ul><ul><li>接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</li></ul><ul><li>接口里不能包含初始化块；但抽象类则完全可以包含初始化块。</li></ul><ul><li>一个类最多只能有一个直接父类， 包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。</li></ul><p>好了，关于抽象类和接口的总结我就写这么多了，还想理解的可以看看这两篇帖子<a href="https://www.cnblogs.com/burns/p/4113527.html" target="_blank" rel="noopener">Java 接口和抽象类区别(写的很好，转了）</a>、<a href="https://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">深入理解Java的接口和抽象类</a>。</p><p>参考资料：《Java疯狂讲义》</p>]]></content>
      
      <categories>
          
          <category> 基础与进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java基本数据类型与包装类</title>
      <link href="/2018/10/10/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
      <url>/2018/10/10/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>前几天提到我最近要复习Java基础，所以我又去图书馆借了这本书</p><img src="/2018/10/10/Java基本数据类型与包装类/1.jpg"><p>刚好过去整整一年，当初我入门Java就是看这本书，今天的我依然是个Java初学者~</p><p>这篇的主题是基础中的基础了，所以也很容易被人忽略（包括我也是），最近刷起题来才发现细枝末节的东西很多，还是要理一理。</p><h3 id="一、基本数据类型"><a href="#一、基本数据类型" class="headerlink" title="一、基本数据类型"></a>一、基本数据类型</h3><p>Java提供了八种基本类型，六种数值类型（四个整型，两个浮点型），一种字符型，还有一种布尔型。</p><img src="/2018/10/10/Java基本数据类型与包装类/2.png"><p><strong>byte：</strong></p><ul><li>byte 数据类型是8位、有符号的以二进制补码表示的整数；</li><li>最小值是 -128（-2^7）；</li><li>最大值是 127（2^7-1）；</li><li>默认值是 0；</li><li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li><li>例子：byte a = 100；byte b = -50；</li></ul><p><strong>short：</strong></p><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数；</li><li>最小值是 -32768（-2^15）；</li><li>最大值是 32767（2^15 - 1）；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 0；</li><li>例子：short s = 1000；short r = -20000；</li></ul><p><strong>int：</strong></p><ul><li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 -2,147,483,648（-2^31）；</li><li>最大值是 2,147,483,647（2^31 - 1）；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 0 ；</li><li>例子：int a = 100000；int b = -200000；</li></ul><p><strong>long：</strong></p><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li><li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是 0L；</li><li>例子： long a = 100000L；Long b = -200000L；<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li></ul><p><strong>float：</strong></p><ul><li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float 在储存大型浮点数组的时候可节省内存空间；</li><li>默认值是 0.0f；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>例子：float f1 = 234.5f；</li></ul><p><strong>double：</strong></p><ul><li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li><li>浮点数的默认类型为double类型；</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是 0.0d；</li><li>例子：double d1 = 123.4；</li></ul><p><strong>boolean：</strong></p><ul><li>boolean数据类型表示1位的信息；</li><li>只有两个取值：true 和 false；</li><li>这种类型只作为一种标志来记录 true/false 情况；</li><li>默认值是 false；</li><li>例子：boolean one = true；</li></ul><p><strong>char：</strong></p><ul><li>char类型是一个单一的 16 位 Unicode 字符；</li><li>最小值是 \u0000（即为0）；</li><li>最大值是 \uffff（即为65,535）；</li><li>char 数据类型可以储存任何字符；</li><li>例子：char letter = ‘A’；</li></ul><p>注：</p><ul><li>整型默认为int类型，但如果将一个较小的整数值（在byte或short类型的表数范围内）赋给一个byte或short变量，系统会自动把这个整数值当成byte或者short类型来处理。</li><li>如果使用一个很大的整数值（超出int类型的表数范围）时，Java不会自动把这个整数值当成long类型来处理，如果希望把它当成long类型来处理推荐在整数值后加字母L作为后缀。</li><li>Java整数值有四种表示形式：十进制，二进制（0b或0B开头），八进制（0开头），十六进制（0x或0X开头，其中10~15分别以a~f来表示）。</li><li>浮点型默认为较精确的double，如果想使用float应在浮点数后加上尾缀f或F。</li><li>浮点型是不精确的，不能对浮点型进行精确比较，也不能作为switch语句判断条件。</li></ul><h3 id="二、基本类型的类型转换"><a href="#二、基本类型的类型转换" class="headerlink" title="二、基本类型的类型转换"></a>二、基本类型的类型转换</h3><h5 id="1-自动类型转换"><a href="#1-自动类型转换" class="headerlink" title="1.自动类型转换"></a>1.自动类型转换</h5><img src="/2018/10/10/Java基本数据类型与包装类/4.jpg"><p>注：</p><ul><li>基本数据类型中，布尔类型boolean占有一个字节，由于其本身所代码的特殊含义，boolean类型与其他基本类型不能进行类型的转换（既不能进行自动类型的提升，也不能强制类型转换）， 否则将编译出错。 </li><li>byte，char，short虽然类型从小到大自动转换，但是byte不能转成char，char也不能转成short。因为byte和short是数值型的变量，char字符型的变量。数值型变量有符号（第一位）而在char中则无正负之分。byte转short自然就是可以的了。</li></ul><h5 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="2.强制类型转换"></a>2.强制类型转换</h5><p>如果将上图箭头右边的值转换为左边的值就需要强制类型转换，原因很简单，右边表示的范围大，左边表示的范围小。 当进行强制类型转换时，类似于把一个大瓶子的水倒入小瓶子，如果大瓶子的水不多还好，但如果大瓶子里的水很多就会引起溢出，造成数据丢失。</p><p>《疯狂Java讲义》中有个很好的例子说明强制类型转换后数值是如何改变的，在这贴出来做个记录。</p><img src="/2018/10/10/Java基本数据类型与包装类/5.jpg"><img src="/2018/10/10/Java基本数据类型与包装类/6.jpg"><h5 id="3-表达式类型的自动提升"><a href="#3-表达式类型的自动提升" class="headerlink" title="3.表达式类型的自动提升"></a>3.表达式类型的自动提升</h5><p>当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将发生自动提升。Java定义了如下的自动提升规则。</p><ul><li><p>所有的byte类型、short类型和char类型将被提升到int类型。</p></li><li><p>整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型。</p></li></ul><p>面试陷阱</p><pre><code>byte b1 = 10;byte b2 = 11;//错误: 不兼容的类型: 从int转换到byte可能会有损失//否则，两个操作数都将转换为int类型。byte b3 = b1 + b2 //错误byte b3 = (byte)(b1 + b2); //正确</code></pre><pre><code>short s1 = 1; s1 = s1 + 1; //错误: 不兼容的类型: 从int转换到short可能会有损失short s2 = 1; s2 += 1; // 等同于short s2 = (short)(s2 + (short)1); //正确</code></pre><h3 id="三、包装类"><a href="#三、包装类" class="headerlink" title="三、包装类"></a>三、包装类</h3><p>为了满足Java语言面向对象的这一特性，上述基本数据类型中的每一个在java.lang包中都有一个包装类，即将每个基本类型都包装成了一个类。 </p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><p>对于包装类说，这些类的用途主要包含三种：</p><ul><li><p>集合不允许存放基本数据类型，故常用包装类。</p></li><li><p>作为和基本数据类型对应的类类型存在，方便涉及到对象的操作。</p></li><li><p>包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。</p></li></ul><h5 id="1-基本类型与包装类型之间的转换"><a href="#1-基本类型与包装类型之间的转换" class="headerlink" title="1.基本类型与包装类型之间的转换"></a>1.基本类型与包装类型之间的转换</h5><p>JDK自从1.5版本以后，就引入了自动拆装箱的语法，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便我们的代码书写。使用示例代码如下： </p><pre><code>//自动装箱int m = 10;Integer in = m;System.out.println(in); //10//自动拆箱Integer inn = new Integer(10);int n = inn;System.out.println(n); //10</code></pre><h5 id="2-字符串和基本类型之间的转换"><a href="#2-字符串和基本类型之间的转换" class="headerlink" title="2.字符串和基本类型之间的转换"></a>2.字符串和基本类型之间的转换</h5><p>(1)基本类型转换成字符串类型</p><ul><li><p>包装类的toString()方法。</p></li><li><p>String 类的valueOf()方法。</p></li><li><p>空字符串加一个基本类型变量。</p></li></ul><p>(2)字符串类型转换成基本类型</p><ul><li><p>包装类的parseXxx()静态方法。</p></li><li><p>包装类的valueOf()方法。</p></li></ul><h5 id="3-包装类中“-”与equals的用法比较"><a href="#3-包装类中“-”与equals的用法比较" class="headerlink" title="3.包装类中“==”与equals的用法比较"></a>3.包装类中“==”与equals的用法比较</h5><p>值得注意的是，包装类中的equals方法和String类一样，都是重写了Object类中的equals方法，因此比较的是内容而不是地址，而“==”比较的依然是引用变量的地址，只是当包装类型和与之相对应的基本类型进行“==”比较时会先做自动拆箱处理。 </p><pre><code>public static void equalsTest() {        // TODO Auto-generated method stub        Integer a = new Integer(-100);        Integer b = new Integer(-100);        int c = -100;        System.out.println(a == b);//false        System.out.println(a == c);//true        System.out.println(b == c);//true        System.out.println(a.equals(b));//true        String s1 = new String(&quot;hello&quot;);        String s2 = new String(&quot;hello&quot;);        System.out.println(s1 == s2);//false        System.out.println(s1.equals(s2));//true}</code></pre><h5 id="4-包装类的常量池"><a href="#4-包装类的常量池" class="headerlink" title="4.包装类的常量池"></a>4.包装类的常量池</h5><p>既然提到String类，必须说说包装类和String类一样，JVM也为其提供了常量池，下面代码具体说明：</p><pre><code>/** * 8种基本类型的包装类和对象池 *         包装类：java提供的为原始数据类型的封装类，如：int(基本数据类型)，Integer封装类。 *         对象池：为了一定程度上减少频繁创建对象，将一些对象保存到一个&quot;容器&quot;中。 *  *     Byte,Short,Integer,Long,Character。这5种整型的包装类的对象池范围在-128~127之间，也就是说， *     超出这个范围的对象都会开辟自己的堆内存。 *  *  Boolean也实现了对象池技术。Double,Float两种浮点数类型的包装类则没有实现。 *     String也实现了常量池技术。 *  * 自动装箱拆箱技术 *     JDK5.0及之后允许直接将基本数据类型的数据直接赋值给其对应地包装类。 *  如：Integer i = 3;（这就是自动装箱） *  实际编译代码是：Integer i=Integer.valueOf(3); 编译器自动转换 *     自动拆箱则与装箱相反：int i = (Integer)5; */public class Test {    public static void main(String[] args) {        //基本数据类型常量池范围-128~127        Integer n1 = -129;        Integer n2 = -129;        Long n3 = 100L;        Long n4 = 100L;        Double n5 =  12.0;        Double n6 = 12.0;        //false        System.out.println(n1 == n2);        //true        System.out.println(n3 == n4);        //false        System.out.println(n5 == n6);        //String常量池技术,注意：这里String不是用new创建的对象        String str1 = &quot;abcd&quot;;        String str2 = &quot;abcd&quot;;        //true        System.out.println(str1 == str2);    }}</code></pre><p>想深入了解的话可以看看这两篇帖子<a href="https://blog.csdn.net/l_bestcoder/article/details/75137105" target="_blank" rel="noopener">Java包装类对象比较中存在的问题</a>、<a href="https://www.cnblogs.com/xiongyan/p/4245541.html" target="_blank" rel="noopener">Java包装类的常量池</a>。</p><p>这篇Java基本数据类型与包装类到这就更完了，没想到小细节是真得多，最后感谢上述出现过的帖子的作者以及《疯狂Java讲义》的作者李刚先生。</p>]]></content>
      
      <categories>
          
          <category> 基础与进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合模式</title>
      <link href="/2018/10/07/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/07/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="一、组合模式概述"><a href="#一、组合模式概述" class="headerlink" title="一、组合模式概述"></a>一、组合模式概述</h3><p>树形结构在软件中随处可见，例如操作系统中的目录结构、应用软件中的菜单、办公系统中的公司组织结构等等，如何运用面向对象的方式来处理这种树形结构是组合模式需要解决的问题，组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，也可以一致性地处理树形结构中的叶子节点（不包含子节点的节点）和容器节点（包含子节点的节点）。 </p><p>比如一个文件系统就是一个典型的组合模式系统。下图是常见的计算机XP文件系统的一部分。 </p><img src="/2018/10/07/组合模式/1.png"><p>从上图可以看出，文件系统是一个树结构，树上长有节点。树的节点有两种，一种是树枝节点，即目录，有内部树结构，在图中涂有颜色；另一种是文件，即树叶节点，没有内部树结构。</p><p>显然，可以把目录和文件当做同一种对象同等对待和处理，这也就是组合模式的应用。</p><p>组合模式可以不提供父对象的管理方法，但是组合模式必须在合适的地方提供子对象的管理方法，诸如：add()、remove()、以及getChild()等。</p><p>组合模式定义如下：</p><p><strong>组合模式(Composite Pattern)：组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式，它是一种对象结构型模式。</strong> </p><p>组合模式的实现根据所实现接口的区别分为两种形式，分别称为<strong>安全式</strong>和<strong>透明式</strong>。</p><h3 id="二、安全式组合模式的结构"><a href="#二、安全式组合模式的结构" class="headerlink" title="二、安全式组合模式的结构"></a>二、安全式组合模式的结构</h3><p>安全模式的组合模式要求管理聚集的方法只出现在树枝构件类中，而不出现在树叶构件类中。 </p><img src="/2018/10/07/组合模式/2.png"><p>这种形式涉及到三个角色： </p><ul><li><p>抽象构件(Component)角色：这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为，可以用来管理所有的子对象。合成对象通常把它所包含的子对象当做类型为Component的对象。在安全式的组合模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝构件对象给出。</p></li><li><p>树叶构件(Leaf)角色：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。</p></li><li><p>树枝构件(Composite)角色：代表参加组合的有下级子对象的对象。树枝构件类给出所有的管理子对象的方法，如add()、remove()以及getChild()。</p></li></ul><p>以下是示例代码：</p><pre><code>//抽象构件角色类public interface Component {    // 输出组建自身的名称    public void printStruct(String preStr);}</code></pre><pre><code>//树枝构件角色类public class Composite implements Component {    //用来存储组合对象中包含的子组件对象    private List&lt;Component&gt; childComponents = new ArrayList&lt;Component&gt;();    //组合对象的名字    private String name;    //构造方法，传入组合对象的名字    public Composite(String name) {        this.name = name;    }    //聚集管理方法，增加一个子构件对象    public void addChild(Component child) {        childComponents.add(child);    }    //聚集管理方法，删除一个子构件对象    public void removeChild(int index) {        childComponents.remove(index);    }    //聚集管理方法，返回所有子构件对象    public List&lt;Component&gt; getChild() {        return childComponents;    }    //输出对象的自身结构    @Override    public void printStruct(String preStr) {        // 先把自己输出        System.out.println(preStr + &quot;+&quot; + this.name);        //如果还包含有子组件，那么就输出这些子组件对象        if(this.childComponents != null) {            //添加两个空格，表示向后缩进两个空格            preStr += &quot;  &quot;;            //输出当前对象的子对象            for(Component c : childComponents) {                //递归输出每个子对象                c.printStruct(preStr);            }        }            }}</code></pre><pre><code>//树叶构件角色类public class Leaf implements Component {    //叶子对象的名字    private String name;    //构造方法，传入叶子对象的名称    public Leaf(String name) {        this.name = name;    }    //输出叶子对象的结构，叶子对象没有子对象，也就是输出叶子对象的名字    @Override    public void printStruct(String preStr) {        // TODO Auto-generated method stub        System.out.println(preStr + &quot;-&quot; + name);    }}</code></pre><pre><code>//客户端类public class Client {    public static void main(String[]args) {        Composite root = new Composite(&quot;服装&quot;);        Composite c1 = new Composite(&quot;男装&quot;);        Composite c2 = new Composite(&quot;女装&quot;);        Leaf leaf1 = new Leaf(&quot;衬衫&quot;);        Leaf leaf2 = new Leaf(&quot;夹克&quot;);        Leaf leaf3 = new Leaf(&quot;裙子&quot;);        Leaf leaf4 = new Leaf(&quot;套装&quot;);        root.addChild(c1);        root.addChild(c2);        c1.addChild(leaf1);        c1.addChild(leaf2);        c2.addChild(leaf3);        c2.addChild(leaf4);        root.printStruct(&quot;&quot;);    }}</code></pre><p>可以看出，树枝构件类(Composite)给出了addChild()、removeChild()以及getChild()等方法的声明和实现，而树叶构件类则没有给出这些方法的声明或实现。这样的做法是安全的做法，由于这个特点，客户端应用程序不可能错误地调用树叶构件的聚集方法，因为树叶构件没有这些方法，调用会导致编译错误。</p><p>安全式组合模式的缺点是不够透明，因为树叶类和树枝类将具有不同的接口。</p><h3 id="三、透明式组合模式的结构"><a href="#三、透明式组合模式的结构" class="headerlink" title="三、透明式组合模式的结构"></a>三、透明式组合模式的结构</h3><p>与安全式的组合模式不同的是，透明式的组合模式要求所有的具体构件类，不论树枝构件还是树叶构件，均符合一个固定接口。 </p><img src="/2018/10/07/组合模式/3.png"><p>以下是示例代码：</p><pre><code>//抽象构件角色类public abstract class Component {    //输出组建自身的名称    public abstract void printStruct(String preStr);    //聚集管理方法，增加一个子构件对象    public void addChild(Component child) {        /**         * 缺省实现，抛出异常，因为叶子对象没有此功能         * 或者子组件没有实现这个功能         */        throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;);    }    //聚集管理方法，删除一个子构件对象    public void removeChild(int index) {        /**         * 缺省实现，抛出异常，因为叶子对象没有此功能         * 或者子组件没有实现这个功能         */        throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;);    }    //聚集管理方法，返回所有子构件对象    public List&lt;Component&gt; getChild() {        /**         * 缺省实现，抛出异常，因为叶子对象没有此功能         * 或者子组件没有实现这个功能         */        throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;);    }}</code></pre><pre><code>//树枝构件角色类，此类将implements Conponent改为extends Conponent，其他地方无变化。public class Composite extends Component {    //用来存储组合对象中包含的子组件对象    private List&lt;Component&gt; childComponents = new ArrayList&lt;Component&gt;();    //组合对象的名字    private String name;    //构造方法，传入组合对象的名字    public Composite(String name) {        this.name = name;    }    //聚集管理方法，增加一个子构件对象    public void addChild(Component child) {        childComponents.add(child);    }    //聚集管理方法，删除一个子构件对象    public void removeChild(int index) {        childComponents.remove(index);    }    //聚集管理方法，返回所有子构件对象    public List&lt;Component&gt; getChild() {        return childComponents;    }    //输出对象的自身结构    @Override    public void printStruct(String preStr) {        // 先把自己输出        System.out.println(preStr + &quot;+&quot; + this.name);        //如果还包含有子组件，那么就输出这些子组件对象        if(this.childComponents != null) {            //添加两个空格，表示向后缩进两个空格            preStr += &quot;  &quot;;            //输出当前对象的子对象            for(Component c : childComponents) {                //递归输出每个子对象                c.printStruct(preStr);            }        }            }}</code></pre><pre><code>//树叶构件角色类，此类将implements Conponent改为extends Conponent，其他地方无变化。public class Leaf extends Component {    //叶子对象的名字    private String name;    //构造方法，传入叶子对象的名称    public Leaf(String name) {        this.name = name;    }    //输出叶子对象的结构，叶子对象没有子对象，也就是输出叶子对象的名字    @Override    public void printStruct(String preStr) {        // TODO Auto-generated method stub        System.out.println(preStr + &quot;-&quot; + name);    }}</code></pre><pre><code>//客户端类的主要变化是不再区分Composite对象和Leaf对象。public class Client {    public static void main(String[]args) {        Component root = new Composite(&quot;服装&quot;);        Component c1 = new Composite(&quot;男装&quot;);        Component c2 = new Composite(&quot;女装&quot;);        Component leaf1 = new Leaf(&quot;衬衫&quot;);        Component leaf2 = new Leaf(&quot;夹克&quot;);        Component leaf3 = new Leaf(&quot;裙子&quot;);        Component leaf4 = new Leaf(&quot;套装&quot;);        root.addChild(c1);        root.addChild(c2);        c1.addChild(leaf1);        c1.addChild(leaf2);        c2.addChild(leaf3);        c2.addChild(leaf4);        root.printStruct(&quot;&quot;);    }}</code></pre><p>可以看出，客户端无需再区分操作的是树枝对象(Composite)还是树叶对象(Leaf)了；对于客户端而言，操作的都是Component对象。</p><h3 id="四、两种实现方法的选择"><a href="#四、两种实现方法的选择" class="headerlink" title="四、两种实现方法的选择"></a>四、两种实现方法的选择</h3><p><strong>这里所说的安全性组合模式是指：</strong>从客户端使用组合模式上看是否更安全，如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的。</p><p><strong>这里所说的透明性组合模式是指：</strong>从客户端使用组合模式上，是否需要区分到底是“树枝对象”还是“树叶对象”。如果是透明的，那就不用区分，对于客户而言，都是Compoent对象，具体的类型对于客户端而言是透明的，是无须关心的。</p><p>对于组合模式而言，在安全性和透明性上，<strong>会更看重透明性</strong>，毕竟组合模式的目的是：让客户端不再区分操作的是树枝对象还是树叶对象，而是以一个统一的方式来操作。</p><p>而且对于安全性的实现，需要区分是树枝对象还是树叶对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，这种类型转换必然是不够安全的。</p><p>因此在使用组合模式的时候，建议多采用透明性的实现方式。</p><h3 id="五、组合模式总结"><a href="#五、组合模式总结" class="headerlink" title="五、组合模式总结"></a>五、组合模式总结</h3><p>组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式，Java SE中的AWT和Swing包的设计就基于组合模式，在这些界面包中为用户提供了大量的容器构件（如Container）和成员构件（如Checkbox、Button和TextComponent等），其结构如图：</p><img src="/2018/10/07/组合模式/4.jpg"><p>在图中，Component类是抽象构件，Checkbox、Button和TextComponent是叶子构件，而Container是容器构件，在AWT中包含的叶子构件还有很多，因为篇幅限制没有在图中一一列出。在一个容器构件中可以包含叶子构件，也可以继续包含容器构件，这些叶子构件和容器构件一起组成了复杂的GUI界面。</p><p>除此以外，在XML解析、组织结构树处理、文件系统设计等领域，组合模式都得到了广泛应用。</p><h5 id="1-主要优点"><a href="#1-主要优点" class="headerlink" title="1. 主要优点"></a>1. 主要优点</h5><p>组合模式的主要优点如下：</p><p>(1)组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</p><p>(2)客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</p><p>(3)在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</p><p>(4)组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</p><h5 id="2-主要缺点"><a href="#2-主要缺点" class="headerlink" title="2.主要缺点"></a>2.主要缺点</h5><p>组合模式的主要缺点如下：</p><p>在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。</p><h5 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h5><p>在以下情况下可以考虑使用组合模式：</p><p>(1)在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。</p><p>(2)在一个使用面向对象语言开发的系统中需要处理一个树形结构。</p><p>(3)在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>外观模式</title>
      <link href="/2018/10/05/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/05/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>国庆放假虽然都在玩，但是至少也要保持一周两更的频率，先水一篇设计模式23333。</p><p>外观模式是一种相对简单且使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，降低子系统与客户端的耦合度，且客户端调用非常方便。 </p><h3 id="一、外观模式概述"><a href="#一、外观模式概述" class="headerlink" title="一、外观模式概述"></a>一、外观模式概述</h3><p>不知道大家有没有比较过自己泡茶和去茶馆喝茶的区别，如果是自己泡茶需要自行准备茶叶、茶具和开水，如图(A)所示，而去茶馆喝茶，最简单的方式就是跟茶馆服务员说想要一杯什么样的茶，是铁观音、碧螺春还是西湖龙井？正因为茶馆有服务员，顾客无须直接和茶叶、茶具、开水等交互，整个泡茶过程由服务员来完成，顾客只需与服务员交互即可，整个过程非常简单省事，如图(B)所示。 </p><img src="/2018/10/05/外观模式/1.jpg"><p>在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互。<strong>外观模式通过引入一个新的外观类(Facade)来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。在外观模式中，那些需要交互的业务类被称为子系统(Subsystem)</strong>。如果没有外观类，那么每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大，如图(A)所示；而引入外观类之后，客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度，如图(B)所示。 </p><img src="/2018/10/05/外观模式/3.jpg"><p>外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。</p><p>外观模式定义如下：</p><p><strong>外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 </strong></p><p>外观模式又称为门面模式，它是一种对象结构型模式。外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。 </p><h3 id="二、外观模式结构与实现"><a href="#二、外观模式结构与实现" class="headerlink" title="二、外观模式结构与实现"></a>二、外观模式结构与实现</h3><h5 id="1-模式结构"><a href="#1-模式结构" class="headerlink" title="1.模式结构"></a>1.模式结构</h5><p>外观模式没有一个一般化的类图描述， 下图所示的类图也可以作为描述外观模式的结构图： </p><img src="/2018/10/05/外观模式/4.png"><p>由图可知，外观模式包含如下两个角色：</p><ul><li>外观角色(Facade)：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</li></ul><ul><li>子系统角色(SubSystem)：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</li></ul><h5 id="2-模式实现"><a href="#2-模式实现" class="headerlink" title="2.模式实现"></a>2.模式实现</h5><p>子系统角色中的类：</p><pre><code>public class ModuleA {    //示意方法    public void testA() {        System.out.println(&quot;调用ModuleA中的testA方法&quot;);    }}</code></pre><pre><code>public class ModuleB {    //示意方法    public void testB() {        System.out.println(&quot;调用ModuleB中的testB方法&quot;);    }}</code></pre><pre><code>public class ModuleC {    //示意方法    public void testC() {        System.out.println(&quot;调用ModuleC中的testC方法&quot;);    }}</code></pre><p>外观角色类：</p><pre><code>public class Facade {    //示意方法，满足客户端需要的功能    public void test(){        ModuleA a = new ModuleA();        a.testA();        ModuleB b = new ModuleB();        b.testB();        ModuleC c = new ModuleC();        c.testC();    }}</code></pre><p>客户端角色类：</p><pre><code>public class Client {    public static void main(String[] args) {        Facade facade = new Facade();        facade.test();    }}</code></pre><p>Facade类其实相当于A、B、C模块的外观界面，有了这个Facade类，那么客户端就不需要亲自调用子系统中的A、B、C模块了，也不需要知道系统内部的实现细节，甚至都不需要知道A、B、C模块的存在，客户端只需要跟Facade类交互就好了，从而更好地实现了客户端和子系统中A、B、C模块的解耦，让客户端更容易地使用系统。 </p><h3 id="三、外观模式的应用"><a href="#三、外观模式的应用" class="headerlink" title="三、外观模式的应用"></a>三、外观模式的应用</h3><p>使用外观模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。</p><p>比如，定义如下A、B、C模块：</p><pre><code>public class ModuleA {    //提供给子系统外部使用的方法    public void a1(){};    //子系统内部模块之间相互调用时使用的方法    public void a2(){};    public void a3(){};}</code></pre><pre><code>public class ModuleB {    //提供给子系统外部使用的方法    public void b1(){};    //子系统内部模块之间相互调用时使用的方法    public void b2(){};    public void b3(){};}</code></pre><pre><code>public class ModuleC {    //提供给子系统外部使用的方法    public void c1(){};    //子系统内部模块之间相互调用时使用的方法    public void c2(){};    public void c3(){};}</code></pre><pre><code>public class ModuleFacade {    ModuleA a = new ModuleA();    ModuleB b = new ModuleB();    ModuleC c = new ModuleC();    //下面这些是A、B、C模块对子系统外部提供的方法       public void a1(){        a.a1();    }    public void b1(){        b.b1();    }    public void c1(){        c.c1();    }}</code></pre><p>这样定义一个ModuleFacade类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。比如a2()和a3()方法就不需要让客户端知道，否则既暴露了内部的细节，又让客户端迷惑。对客户端来说，他可能还要去思考a2()、a3()方法用来干什么呢？其实a2()和a3()方法是内部模块之间交互的，原本就不是对子系统外部的，所以干脆就不要让客户端知道。</p><p>Tomcat中外观模式使用的很多，因为Tomcat中有很多不同组件，每个组件要相互通信，但是又不能将自己内部数据过多的暴露给其他组件。用外观模式隔离数据是个很好的方法。</p><p>下面是Request上使用的外观模式：</p><img src="/2018/10/05/外观模式/5.png"><p>使用过Servlet的人都清楚，除了要在web.xml做相应的配置外，还需继承一个叫HttpServlet的抽象类，并且重写doGet与doPost方法（当然只重写service方法也是可以的）。 </p><pre><code>public class TestServlet extends HttpServlet {    public void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        this.doPost(request, response);    }    public void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {    }}</code></pre><p>可以看出doGet与doPost方法有两个参数，参数类型是接口HttpServletRequest与接口HttpServletResponse，那么从Tomcat中传递过来的真实类型到底是什么呢？通过debug会发现，在真正调用TestServlet类之前，会经过很多Tomcat中的方法。如下图所示 ：</p><img src="/2018/10/05/外观模式/6.png"><p>注意红色方框圈中的类，StandardWrapperValue类中的invoke方法225行代码如下： </p><pre><code> filterChain.doFilter     (request.getRequest(), response.getResponse());</code></pre><p>在StandardWrapperValue类中并没有直接将Request对象与Response对象传递给ApplicationFilterChain类的doFilter方法，传递的是RequestFacade与ResponseFacade对象，为什么这么说呢，看一下request.getRequest()与response.getResponse()方法就真相大白了。 </p><p>Request类 </p><pre><code>public HttpServletRequest getRequest() {    if (facade == null) {        facade = new RequestFacade(this);    }    return facade;}</code></pre><p>Response类 </p><pre><code>public HttpServletResponse getResponse() {    if (facade == null) {        facade = new ResponseFacade(this);    }    return (facade);}</code></pre><p>可以看到它们返回都是各自的一个Facade类，那么这样做有什么好处呢？ </p><p>Request对象中的很多方法都是内部组件之间相互交互时使用的，比如setComet、setRequestedSessionId等方法（这里就不一一列举了）。这些方法并不对外部公开，但是又必须设置为public，因为还需要跟内部组件之间交互使用。最好的解决方法就是通过使用一个Facade类，将与内部组件之间交互使用的方法屏蔽掉，只提供给外部程序感兴趣的方法。</p><p>如果不使用Facade类，直接传递的是Request对象和Response对象，那么熟悉容器内部运作的程序员可以分别把ServletRequest和ServletResponse对象向下转换为Request和Response，并调用它们的公共方法。比如拥有Request对象，就可以调用setComet、setRequestedSessionId等方法，这会危害安全性。</p><h3 id="四、外观模式总结"><a href="#四、外观模式总结" class="headerlink" title="四、外观模式总结"></a>四、外观模式总结</h3><p>外观模式是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。在几乎所有的软件中都能够找到外观模式的应用，如绝大多数B/S系统都有一个首页或者导航页面，大部分C/S系统都提供了菜单或者工具栏，在这里，首页和导航页面就是B/S系统的外观角色，而菜单和工具栏就是C/S系统的外观角色，通过它们用户可以快速访问子系统，降低了系统的复杂程度。所有涉及到与多个业务对象交互的场景都可以考虑使用外观模式进行重构。 </p><h5 id="1-主要优点"><a href="#1-主要优点" class="headerlink" title="1.主要优点"></a>1.主要优点</h5><p>外观模式的主要优点如下：</p><p>(1)它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</p><p>(2)它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</p><p>(3)一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</p><h5 id="2-主要缺点"><a href="#2-主要缺点" class="headerlink" title="2.主要缺点"></a>2.主要缺点</h5><p>外观模式的主要缺点如下：</p><p>(1)不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活 性。</p><p>(2)如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</p><h5 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h5><p>在以下情况下可以考虑使用外观模式：</p><p>(1)当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。</p><p>(2)客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</p><p>(3)在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</p><p>参考资料：《设计模式的艺术软件开发人员内功修炼之道》</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>排序算法</title>
      <link href="/2018/09/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/09/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>上篇提过我这几天在看数构，今天就来整理下排序算法，打算先更简单选择排序、冒泡排序、直接插入排序、折半插入排序、快速排序、归并排序，emmm以后可能会补更希尔排序和堆排序，看心情啦。</p><h3 id="一、简单选择排序"><a href="#一、简单选择排序" class="headerlink" title="一、简单选择排序"></a>一、简单选择排序</h3><p>基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换，然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止，简单选择排序是不稳定排序 。（太简单了，不具体说了） </p><pre><code>public static void SelectSort(int[] numbers) {    //数组长度    int size = numbers.length;     int temp = 0;    for(int i=0;i&lt;size-1;i++) {        //待确定的位置        int min = i;        //选择出应该在第i个位置的数        for(int j=i+1;j&lt;size;j++)             if(numbers[j] &lt; numbers[min])                min = j;        //进行交换，如果min发生变化，则进行交换        if (min != i) {            temp = numbers[i];            numbers[i] = numbers[min];            numbers[min] = temp;        }    }}</code></pre><p>简单选择排序的比较次数与序列的初始排序无关。假设待排序的序列有n个元素，则比较次数总是n(n-1)/2。</p><p>而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。</p><p>当序列反序时，移动次数最多，为3n(n-1)/2。</p><p>所以，综合以上，简单排序的时间复杂度为<strong>O(n2)</strong>。 </p><h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><p>基本思想：在要排序的一组数中，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序，冒泡排序是稳定排序 。</p><pre><code>public static void BubbleSort(int[] numbers) {    boolean flag = true;    int temp = 0;    int i,j;    for(i=0;i&lt;numbers.length-1&amp;&amp;flag;i++) {        //如果本轮没有进入if判断语句的执行语句，标志位flag为false        flag = false;        for(j=0;j&lt;numbers.length-i-1;j++)            if(numbers[j] &gt; numbers[j+1]) {                temp = numbers[j];                numbers[j] = numbers[j+1];                numbers[j+1] = temp;                flag = true;            }    }}</code></pre><p>若记录序列的初始状态为正序，则冒泡排序过程只需进行一趟排序，在排序过程中只需进行n-1次比较，且不移动记录。</p><p>反之，若记录序列的初始状态为逆序，则需进行n(n-1)/2次比较和记录移动。</p><p>因此冒泡排序总的时间复杂度为<strong>O(n2)</strong>。 </p><h3 id="三、直接插入排序"><a href="#三、直接插入排序" class="headerlink" title="三、直接插入排序"></a>三、直接插入排序</h3><p>基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止，直接插入排序是稳定排序 。 </p><pre><code>public static void InsertSort(int[] numbers) {    int size = numbers.length;    int i,j;    for(i=1;i&lt;size;i++) {        int temp = numbers[i];        //假如temp比前面的值小，则将前面的值后移        for(j=i-1;j&gt;=0&amp;&amp;temp&lt;numbers[j];j--)            numbers[j+1] = numbers[j];        numbers[j+1] = temp;    }}</code></pre><p>当数据正序时，执行效率最好，每次插入都不用移动前面的元素，时间复杂度为<strong>O(n)</strong>。 </p><p>当数据反序时，执行效率最差，每次插入都要前面的元素后移，时间复杂度为<strong>O(n2)</strong>。</p><p>所以，<strong>数据越接近正序，直接插入排序的算法性能越好</strong>。 </p><h3 id="四、折半插入排序"><a href="#四、折半插入排序" class="headerlink" title="四、折半插入排序"></a>四、折半插入排序</h3><p>基本思想：折半插入排序是对直接插入排序的改进，排序原理同直接插入排序，是稳定的排序算法。</p><p>与直接插入排序的区别在于：在寻找待排序数据的正确位置时，使用了二分查找。</p><pre><code>public static void BinarySort(int[] numbers) {    int i,j;    int low,high,mid;    int temp;    for(i=1;i&lt;numbers.length;i++) {        temp = numbers[i];        low = 0;        high = i - 1;        //寻找插入点        while(low &lt;= high) {            mid = low + (high - low) / 2;            if(temp &lt; numbers[mid])                high = mid - 1;            else                low = mid + 1;        }        //移动有序序列中插入点之后的元素        for(j=i-1;j&gt;=high+1;j--)            numbers[j+1] = numbers[j];        //将待排序数据插入有序数列        numbers[high+1] = temp;    }}</code></pre><p>折半插入排序只是减少了比较次数，但是元素的移动次数不变。折半插入排序平均时间复杂度为<strong>O(n2)</strong>。</p><h3 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h3><p>基本思想：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。</p><p>一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到从前往后的比较索引等于从后往前比较的索引，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><p>接着分别比较左右两边的序列，重复上述的循环。</p><p>在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。 </p><pre><code>public static void QuickSort(int[] numbers,int low,int hight) {        //如果左边索引大于等于右边，说明该组序列整理完毕        if(low &gt;= hight)             return;        int i = low;        int j = hight;        //用子表的第一个记录做基准        int k = numbers[i];         //本轮排序开始，当i==j时本轮排序结束，将基准赋值给numbers[i]        while (i &lt; j) {             //从表的两端交替向中间扫描            while(i &lt; j &amp;&amp; numbers[j] &gt;= k)                j--;            numbers[i] = numbers[j];            while(i &lt; j &amp;&amp; numbers[i] &lt; k)                i++;            numbers[j] = numbers[i];        }        //将基准数值替换回numbers[i]        numbers[i] = k;        //对低子表进行递归排序        QuickSort(numbers,low,i-1);        //对高子表进行递归排序        QuickSort(numbers,i+1,hight); } </code></pre><p>当数据有序时，以第一个关键字为基准分为两个子序列，前一个子序列为空，此时执行效率最差。</p><p>而当数据随机分布时，以第一个关键字为基准分为两个子序列，两个子序列的元素个数接近相等，此时执行效率最好。</p><p>所以，数据越随机分布时，快速排序性能越好；数据越接近有序，快速排序性能越差。</p><p>快速排序平均时间复杂度也为<strong>O(nlogn)</strong>，最好情形下快速排序空间复杂度大约为O(logn)。 </p><h3 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h3><p>基本思想：归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之）。 </p><img src="/2018/09/29/排序算法/2.png"><pre><code>public static void MergeSort(int[] numbers,int start,int end) {    if(start &gt;= end)        return;    int mid = (start + end) &gt;&gt; 1;    // 递归实现归并排序    MergeSort(numbers,start,mid);    MergeSort(numbers,mid+1,end);    merge(numbers,start,mid,end);}//将两个有序序列归并为一个有序序列(二路归并)public static void merge(int[] numbers,int start,int mid,int end) {    //定义一个临时数组，用来存储排序后的结果    int[] temp = new int[end+1];    //临时数组的索引    int tempStart = start;    int low = start;    //第二个序列的起始下标    int center = mid + 1;    //取出最小值放入临时数组中    while(start &lt;= mid &amp;&amp; center &lt;= end)        temp[low++] = numbers[start] &gt; numbers[center] ? numbers[center++] : numbers[start++];    //若还有段序列不为空，则将其加入临时数组末尾    while(start &lt;= mid)        temp[low++] = numbers[start++];    while(center &lt;= end)        temp[low++] = numbers[center++];    //将临时数组中的值copy到原数组中    for(int i=tempStart;i&lt;=end;i++)        numbers[i] = temp[i];}</code></pre><p>归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。<em>值得一提的是，Java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。</em>每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。</p><p>总的平均时间复杂度为O(nlogn)。而且，归并排序不管最好或者最坏的情况下平均时间复杂度均为<strong>O(nlogn)</strong>。 </p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>各种排序的稳定性，时间复杂度、空间复杂度、稳定性总结如下图： </p><img src="/2018/09/29/排序算法/sort_table.jpg">]]></content>
      
      <categories>
          
          <category> 基础与进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM内存区域</title>
      <link href="/2018/09/28/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2018/09/28/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p>这几天在复习数构，leetcode上A了大概三十道题，昨天突然发现打题目太杀时间了，我这种菜鸟一天至少花两小时在上面，不得不考虑一下性价比，以后一天1~2道，绝不多打，是时候腾时间复习一波基础了。</p><p>今天开新坑，整理并记录下重要的知识点，主要是JVM、Java并发编程、集合容器类源码等等，第一篇就说我们的JVM内存区域。</p><p><em>注：本篇文大多数内容来自周志明先生著《深入理解Java虚拟机》，强烈推荐想学习JVM知识的同学去拜读经典！！</em></p><p>在开始之前，我们首先要了解下什么是运行时数据区。由于Java程序是交由JVM执行的，所以我们在谈Java内存区域划分的时候事实上是指JVM内存区域划分。Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)，然后由JVM中的类加载器加载各个类的字节码文件，加载完毕之后，交由JVM执行引擎执行。在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间就被称作为Runtime Data Area(运行时数据区)，也就是我们常说的JVM内存。因此，在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）。  </p><p>根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：程序计数器(Program Counter Register)、Java虚拟机栈(VM Stack)、本地方法栈(Native Method Stack)、方法区(Method Area)、堆(Heap)。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p><img src="/2018/09/28/JVM内存区域/MemoryArea.jpg"><p>线程私有：</p><ul><li>程序计数器；</li><li>Java虚拟机栈；</li><li>本地方法栈；</li></ul><p>线程共享：</p><ul><li>堆；</li><li>方法区；</li></ul><h3 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h3><p>程序计数器是一块较小的内存空间，它可以看作是<strong>当前线程所执行的字节码的行号指示器。</strong>在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机的多条线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，<strong>为了线程切换后能恢复到正确的执行位置，每一条线程都有自己的程序计数器，</strong>各条线程之间的计算器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这个计数器的值则为空(undefined)。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="二、Java虚拟机栈"><a href="#二、Java虚拟机栈" class="headerlink" title="二、Java虚拟机栈"></a>二、Java虚拟机栈</h3><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同。<strong>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</strong></p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定如下两种异常情况：如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量时，Java虚拟机将会抛出一个StackOverflowError异常；如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常。</p><h3 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h3><p><strong>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</strong>在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSopt虚拟机）直接就把二者合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p><h3 id="四、Java堆"><a href="#四、Java堆" class="headerlink" title="四、Java堆"></a>四、Java堆</h3><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。<strong>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong>这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么绝对了。</p><p><strong>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做GC堆。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。</strong>不过无论如何划分，都于存放内容无关，无论哪个区域，存储的都是对象实例，进一步划分的目的是为了更好的回收内存，或者更快地分配内存。</p><img src="/2018/09/28/JVM内存区域/heap.png"><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，即可实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx JVM最大允许分配的堆内存，按需分配和-Xms JVM初始分配的堆内存<br>控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h3><p>方法区在JVM中也是一个非常重要的区域，<strong>它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等数据。</strong></p><p>很多人习惯把方法区称为永久代， 方法区就是永久代？并非如此。虽然<strong>现在市面上使用最广泛的HotSpot虚拟机选择用永久代来实现方法区，从而省去了为方法区编写内存管理代码的工作。但这只是一种实现方式，其他虚拟机（BEA JRockit/IBM J9 VM）都不存在永久代这一概念。通过永久代来实现方法区容易造成内存溢出，未来也可能会被替代。</strong></p><p><strong>JDK1.7中JVM把字符串常量区从方法区中移除了；JDK1.8中JVM把字符串常量池移入了堆中，同时取消了永久代，改用元空间代替（Metaspace） 实现方法区。但也带来了一些新问题，比如String.intern()方法。永久代或者是元空间是对方法区的不同实现，是实现层面的东西。</strong> </p><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样永久存在了。这区域的内存回收目标重要是针对常量池的回收和类型的卸载，一般来说这个内存区域的回收‘成绩’比较难以令人满意。尤其是类型的卸载条件非常苛刻，但是这部分的回收确实是必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完成回收导致的内存溢出。</p><h3 id="六、-其它"><a href="#六、-其它" class="headerlink" title="六、 其它"></a>六、 其它</h3><h5 id="1-运行时常量池"><a href="#1-运行时常量池" class="headerlink" title="1.运行时常量池"></a>1.运行时常量池</h5><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p><strong>Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。</strong>不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p><p><strong>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才会产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用的比较多的便是String类的intern()方法。</strong></p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><p>有关常量池这块比较乱，想进一步理解的话看这两篇帖子<a href="https://www.jianshu.com/p/10584345b10a" target="_blank" rel="noopener">JVM解读-方法区</a>、<a href="https://blog.csdn.net/Sugar_Rainbow/article/details/68150249" target="_blank" rel="noopener">JVM-String常量池与运行时常量池</a>。</p><p>刚刚说方法区中String常量池从方法区移入堆中带来了一个问题，那就是String.intern()方法的变化，想了解的话看这三篇帖子<a href="https://blog.csdn.net/soonfly/article/details/70147205" target="_blank" rel="noopener">几张图轻松理解String.intern()</a>、<a href="https://blog.csdn.net/wjzhang5514/article/details/70209403" target="_blank" rel="noopener">String的intern()方法详解</a>、<a href="https://www.cnblogs.com/dreamroute/p/5946272.html" target="_blank" rel="noopener">触摸java常量池</a>。</p><h5 id="2-直接内存"><a href="#2-直接内存" class="headerlink" title="2.直接内存"></a>2.直接内存</h5><p>直接内存并不是虚拟机运行内存的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存区域也被频繁的使用，也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p><p>在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）和缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆中和Native堆中来回复制数据。   </p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，肯定还会受到本机总内存大小及处理器寻址空间的限制。服务器管理员在配置虚拟机内存参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p><p>到此有关JVM的各个内存区域就介绍完了，如果你认真读并且仔细思考相信你一定能有所收获，你的理解一定不再局限于老师所讲的堆和栈的理解，对JVM内存区域的深入理解对于今后的学习一定会有很大的帮助。</p><p>参考资料：《深入理解Java虚拟机：JVM高级特性与最佳实践》</p>]]></content>
      
      <categories>
          
          <category> 基础与进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring MVC注解</title>
      <link href="/2018/09/22/Spring%20MVC%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/09/22/Spring%20MVC%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="一、一个小例子"><a href="#一、一个小例子" class="headerlink" title="一、一个小例子"></a>一、一个小例子</h3><p>上周Spring MVC入了个门，没有入门程序，今天补上，正好借这个入门小程序来讲讲今天的主题，有关Spring MVC的常用注解。</p><h5 id="1-导入jar包"><a href="#1-导入jar包" class="headerlink" title="1.导入jar包"></a>1.导入jar包</h5><p>第一步当然是新建一个普通的web项目，在lib目录下添加运行Spring MVC程序需要的jar包，下图是所要添加的jar包：</p><h5 id="2-配置DispatcherServlet"><a href="#2-配置DispatcherServlet" class="headerlink" title="2.配置DispatcherServlet"></a>2.配置DispatcherServlet</h5><p>在项目的web.xml文件中做如下配置：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee                               http://xmlns.jcp.org/xml/ns/javaee/web-app_3_0.xsd&quot;         id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&gt;    &lt;!--配置DispatcherServlet--&gt;    &lt;servlet&gt;        &lt;!--servlet-name随意命名--&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;        &lt;!--配置初始化参数：作用是配置Spring MVC配置文件的位置和名称--&gt;        &lt;!--可以不配置，默认Spring MVC配置文件名称为&lt;servlet-name&gt;-servlet.xml--&gt;        &lt;init-param&gt;            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;            &lt;param-value&gt;classpath:dispatcherServlet-servlet.xml&lt;/param-value&gt;        &lt;/init-param&gt;        &lt;!--表示容器在应用启动时就加载并初始化这个servlet--&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;        &lt;!--截取所有请求--&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;&lt;/web-app&gt;　　</code></pre><h5 id="3-创建Spring-MVC的配置文件"><a href="#3-创建Spring-MVC的配置文件" class="headerlink" title="3.创建Spring MVC的配置文件"></a>3.创建Spring MVC的配置文件</h5><p>因为我们在web.xml文件中配置了Spring MVC配置文件的名称，所以我们要新建一个名为dispatcherServlet-servlet.xml的文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans　　　　http://www.springframework.org/schema/beans/spring-beans.xsd　　　　http://www.springframework.org/schema/context　　　　http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--配置自动扫描注解的包--&gt;    &lt;context:component-scan base-package=&quot;com.springmvc.controller&quot;/&gt;    &lt;!--对于适配器和解析器的配置，我们可以使用&lt;mvc:annotation-driven/&gt;代替--&gt;    &lt;!--自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter--&gt;    &lt;mvc:annotation-driven/&gt;    &lt;!--配置视图解析器:如何把handle方法返回值解析为实际的物理视图--&gt;    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;!--prefix和suffix：查找视图页面的前缀和后缀（前缀[逻辑视图名]后缀）--&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot;/&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h5 id="4-创建Controller类"><a href="#4-创建Controller类" class="headerlink" title="4.创建Controller类"></a>4.创建Controller类</h5><p>在com.springmvc.controller包下创建controller类</p><pre><code>package com.springmvc.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;//Controller注解，在《Spring的Bean与IoC实现》提过@Controllerpublic class StartController {    //DispatcherServlet根据配置的url地址决定调用哪个方法    @RequestMapping(&quot;/helloworld&quot;)    public String helloworld() {        //返回jsp文件名        return &quot;helloworld&quot;;    }}</code></pre><h5 id="5-创建视图界面"><a href="#5-创建视图界面" class="headerlink" title="5.创建视图界面"></a>5.创建视图界面</h5><p>在WEB-INF/views/目录下创建helloworld.jsp</p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;      pageEncoding=&quot;utf-8&quot;%&gt; &lt;html&gt;&lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello,World!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h5 id="6-启动项目，测试应用"><a href="#6-启动项目，测试应用" class="headerlink" title="6.启动项目，测试应用"></a>6.启动项目，测试应用</h5><p>发布项目并启动Tomcat，在浏览器中输入地址<code>http://localhost:8080/项目名/helloworld</code>你便可以看到上面的helloworld.jsp界面。</p><h3 id="二、常用注解"><a href="#二、常用注解" class="headerlink" title="二、常用注解"></a>二、常用注解</h3><h5 id="1-RequestMapping"><a href="#1-RequestMapping" class="headerlink" title="1.@RequestMapping"></a>1.@RequestMapping</h5><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。在类的级别上的注解会将一个特定请求或者请求模式映射到一个控制器之上。之后你还可以另外添加方法级别的注解来进一步指定到处理方法的映射关系。 </p><p>RequestMapping注解有六个属性：</p><p>value：指定请求的实际地址，指定的地址可以是RESTful风格；</p><p><em>有关RESTful风格可以看这篇帖子<a href="https://kb.cnblogs.com/page/512047/" target="_blank" rel="noopener">RESTful架构详解</a>。</em></p><ul><li>method：指定请求的method类型， GET、POST、PUT、DELETE等；</li><li>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；</li><li>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li><li>params：指定request中必须包含某些参数值是，才让该方法处理；</li><li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求；</li></ul><p>具体示例：<a href="https://blog.csdn.net/J080624/article/details/55193269" target="_blank" rel="noopener">SpringMVC--@RequestMapping的参数和用法</a>。</p><h5 id="2-Resource和-Autowired"><a href="#2-Resource和-Autowired" class="headerlink" title="2.@Resource和@Autowired"></a>2.@Resource和@Autowired</h5><p>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><p>(1)共同点</p><p>两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法。</p><p>(2)不同点</p><p>@Autowired</p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><pre><code>public class TestServiceImpl {    // 下面两种@Autowired只要使用一种即可    @Autowired    private UserDao userDao; // 用于字段上    @Autowired    public void setUserDao(UserDao userDao) { // 用于属性的方法上        this.userDao = userDao;    }}</code></pre><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。如下：</p><pre><code>public class TestServiceImpl {    @Autowired    @Qualifier(&quot;userDao&quot;)    private UserDao userDao; }</code></pre><p>@Resource</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><pre><code>public class TestServiceImpl {    // 下面两种@Resource只要使用一种即可    @Resource(name=&quot;userDao&quot;)    private UserDao userDao; // 用于字段上    @Resource(name=&quot;userDao&quot;)    public void setUserDao(UserDao userDao) { // 用于属性的setter方法上        this.userDao = userDao;    }}</code></pre><p>@Resource装配顺序：</p><ul><li><p>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</p></li><li><p>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</p></li><li><p>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</p></li><li><p>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p></li></ul><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p><h5 id="3-PathVariable"><a href="#3-PathVariable" class="headerlink" title="3.@PathVariable"></a>3.@PathVariable</h5><p>用于将请求URL中的模板变量映射到功能处理方法的参数上，即取出uri模板中的变量作为参数。如：</p><pre><code>@Controller  public class TestController {       @RequestMapping(value=&quot;/user/{userId}/roles/{roleId}&quot;,method = RequestMethod.GET)       public String getLogin(@PathVariable(&quot;userId&quot;) String userId,           @PathVariable(&quot;roleId&quot;) String roleId){           System.out.println(&quot;User Id : &quot; + userId);           System.out.println(&quot;Role Id : &quot; + roleId);           return &quot;hello&quot;;       }       @RequestMapping(value=&quot;/product/{productId}&quot;,method = RequestMethod.GET)       public String getProduct(@PathVariable(&quot;productId&quot;) String productId){             System.out.println(&quot;Product Id : &quot; + productId);             return &quot;hello&quot;;       } }</code></pre><h5 id="4-RequestParam"><a href="#4-RequestParam" class="headerlink" title="4.@RequestParam"></a>4.@RequestParam</h5><p>主要用于在Spring MVC后台控制层获取参数，类似一种是request.getParameter(“name”)，它有三个常用参数：defaultValue = “0”, required = false, value = “isApp”；defaultValue表示设置默认值，required通过boolean设置是否是必须要传入的参数，value值表示接受的传入的参数类型。 </p><p>@PathVariable和@RequestParam的区别：</p><p>请求路径上有个变量值，可以通过@PathVariable来获取；</p><p>@RequestParam用来获得静态的URL请求参数。</p><h5 id="5-RequestHeader和-CookieValue"><a href="#5-RequestHeader和-CookieValue" class="headerlink" title="5. @RequestHeader和@CookieValue"></a>5. @RequestHeader和@CookieValue</h5><p>@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上。</p><p>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。 </p><p>Request请求header部分如下：</p><pre><code>Host                    localhost:8080  Accept                  text/html,application/xhtml+xml,application/xml;q=0.9  Accept-Language         fr,en-gb;q=0.7,en;q=0.3  Accept-Encoding         gzip,deflate  Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7  Keep-Alive              300  </code></pre><p>示例代码：</p><pre><code>@Controller  public class TestController {      //例如有cookie值 JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84    @RequestMapping(&quot;/displayHeaderInfo&quot;)      public void displayHeaderInfo(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding,                                    @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive,                                  @CookieValue(&quot;JSESSIONID&quot;) String cookie) {        System.out.println(&quot;Accept-Encoding : &quot; + encoding);          System.out.println(&quot;Keep-Alive : &quot; + keepAlive);        System.out.println(&quot;JSESSIONID : &quot; + cookie);    } }</code></pre><h5 id="6-RequestBody"><a href="#6-RequestBody" class="headerlink" title="6.@RequestBody"></a>6.@RequestBody</h5><p>该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上，再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上 。</p><h5 id="7-ResponseBody"><a href="#7-ResponseBody" class="headerlink" title="7.@ResponseBody"></a>7.@ResponseBody</h5><p>该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。</p><p>使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用。</p><h5 id="8-ModelAttribute和-SessionAttributes"><a href="#8-ModelAttribute和-SessionAttributes" class="headerlink" title="8.@ModelAttribute和@SessionAttributes"></a>8.@ModelAttribute和@SessionAttributes</h5><p>@ModelAttribute主要有两种使用方式，一种是标注在方法上，一种是标注在 Controller 方法参数上。当@ModelAttribute标记在方法上的时候，该方法将在处理器方法执行之前执行，然后把返回的对象存放在模型属性中，属性名称可以使用@ModelAttribute(“attributeName”) 在标记方法的时候指定，若未指定，则使用返回类型的类名称（首字母小写）作为属性名称。</p><pre><code>@Controller@RequestMapping(&quot;/myTest&quot;)public class MyController {    @ModelAttribute(&quot;hello&quot;)    public String getModel() {        return &quot;world&quot;;    }    @ModelAttribute(&quot;intValue&quot;)    public int getInteger() {        return 10;    }    @ModelAttribute(&quot;user2&quot;)    public User getUser() {        //省略User类代码，只有一个字段为userName        return new User(&quot;user2&quot;);    }    @RequestMapping(&quot;/sayHello&quot;)    public void sayHello(@ModelAttribute(&quot;hello&quot;) String hello, @ModelAttribute(&quot;intValue&quot;) int num, @ModelAttribute(&quot;user2&quot;) User user, Writer writer) throws IOException {       writer.write(&quot;Hello &quot; + hello + &quot; , Hello &quot; + user.getUsername() + num);       writer.write(&quot;\r&quot;);    } }</code></pre><p>当我们请求 /myTest/sayHello的时候使用@ModelAttribute 标记的方法会先执行，然后把它们返回的对象存放到模型中。最终访问到 sayHello方法的时候，使用 @ModelAttribute 标记的方法参数都能被正确的注入值。执行结果如下所示： </p><p> <em>Hello world,Hello user210</em> </p><p>@ModelAttribute注解作用在方法上或者方法的参数上，表示将被注解的方法的返回值或者是被注解的参数作为Model的属性加入到Model中，然后Spring框架自会将这个Model传递给ViewResolver。Model的生命周期只有一个http请求的处理过程，请求处理完后，Model就销毁了。如果想让参数在多个请求间共享，那么可以用到要说到的@SessionAttribute注解。</p><p>@SessionAttributes即将值放到session作用域中，只能作用在类上 。 </p><p>具体使用可以参考这篇帖子<a href="https://www.jb51.net/article/134885.htm" target="_blank" rel="noopener">spring学习之@SessionAttributes实例解析</a>。</p><h3 id="三、POST中文乱码解决方案"><a href="#三、POST中文乱码解决方案" class="headerlink" title="三、POST中文乱码解决方案"></a>三、POST中文乱码解决方案</h3><p>在web.xml里配置：</p><pre><code>&lt;!-- spring Web MVC框架提供了org.springframework.web.filter.CharacterEncodingFilter用于解决POST方式造成的中文乱码问题 --&gt;&lt;filter&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;encoding&lt;/param-name&gt;      &lt;param-value&gt;UTF-8&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;init-param&gt;      &lt;param-name&gt;forceEncoding&lt;/param-name&gt;      &lt;param-value&gt;true&lt;/param-value&gt;    &lt;/init-param&gt;  &lt;/filter&gt;  &lt;filter-mapping&gt;    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;</code></pre>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring mvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>装饰模式</title>
      <link href="/2018/09/20/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/20/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="一、装饰模式概述"><a href="#一、装饰模式概述" class="headerlink" title="一、装饰模式概述"></a>一、装饰模式概述</h3><p>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为，在现实生活中，这种情况也到处存在，例如一张照片，我们可以不改变照片本身，给它增加一个相框，使得它具有防潮的功能，而且用户可以根据需要给它增加不同类型的相框，甚至可以在一个小相框的外面再套一个大相框。</p><p>装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能。</p><p>装饰模式定义如下：</p><p><strong>装饰模式(Decorator Pattern)：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。</strong> </p><p>装饰模式的类图如下： </p><img src="/2018/09/20/装饰模式/1.png"><p>在装饰模式中的角色有： </p><ul><li>抽象构件(Component)角色：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。  </li></ul><ul><li>具体构件(ConcreteComponent)角色：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。  </li></ul><ul><li>装饰(Decorator)角色：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 </li></ul><ul><li>具体装饰(ConcreteDecorator)角色：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。 </li></ul><p>举例代码如下：</p><pre><code>//抽象构件public interface Component {    public void sampleOperation();}</code></pre><pre><code>//具体构件public class ConcreteComponent implements Component {    @Override    public void sampleOperation() {        // 写相关的业务代码    }}</code></pre><pre><code>//装饰角色public class Decorator implements Component {    //持有抽象构件对象的引用    private Component component;    public Decorator(Component component) {        this.component = component;    }    @Override    public void sampleOperation() {        //要注意的是在Decorator中并未真正实现sampleOperation()方法，而只是调用原有component对象的sampleOperation()方法，它没有真正实施装饰，而是提供一个统一的接口，将具体装饰过程交给子类完成。        component.sampleOperation();    }}</code></pre><pre><code>//具体装饰角色public class ConcreteDecoratorA extends Decorator {    public ConcreteDecoratorA(Component component) {        super(component);    }    @Override    public void sampleOperation() {　　　　　super.sampleOperation();        // 写相关的业务代码    }}public class ConcreteDecoratorB extends Decorator {    public ConcreteDecoratorB(Component component) {        super(component);    }    @Override    public void sampleOperation() {　　　　  super.sampleOperation();        // 写相关的业务代码    }}</code></pre><pre><code>//测试类public class DecoratorTest {     public static void main(String[] args) {         Component component = new ConcreteComponent();//原来的对象         component.sampleOperation();//原来的方法         ConcreteDecoratorA concreteDecoratorA = new ConcreteDecoratorA(component);//装饰成A         concreteDecoratorA.sampleOperation();//A的方法         ConcreteDecoratorB concreteDecoratorB = new ConcreteDecoratorB(component);//装饰成B         concreteDecoratorB.sampleOperation();//B的方法    }}</code></pre><h3 id="二、装饰模式的简化"><a href="#二、装饰模式的简化" class="headerlink" title="二、装饰模式的简化"></a>二、装饰模式的简化</h3><p>大多数情况下，装饰模式的实现都要比上面给出的示意性例子要简单。</p><p>如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如下图所示：</p><img src="/2018/09/20/装饰模式/2.png"><p>如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。如下图所示： </p><img src="/2018/09/20/装饰模式/3.png"><h3 id="三、在JAVA-IO库中的应用"><a href="#三、在JAVA-IO库中的应用" class="headerlink" title="三、在JAVA IO库中的应用"></a>三、在JAVA IO库中的应用</h3><p>装饰模式在Java语言中的最著名的应用莫过于Java IO标准库的设计了。</p><p>由于Java IO库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是Java IO库的基本模式。</p><p>Java IO库的对象结构图如下，由于Java IO的对象众多，因此只画出InputStream的部分。</p><img src="/2018/09/20/装饰模式/4.png"><p>根据上图可以看出：</p><ul><li>抽象构件(Component)角色：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</li></ul><ul><li>具体构件(ConcreteComponent)角色：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。</li></ul><ul><li>抽象装饰(Decorator)角色：由FilterInputStream扮演。它实现了InputStream所规定的接口。</li></ul><ul><li>具体装饰(ConcreteDecorator)角色：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。</li></ul><h3 id="四、装饰模式总结"><a href="#四、装饰模式总结" class="headerlink" title="四、装饰模式总结"></a>四、装饰模式总结</h3><p>装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在Java IO中的输入流和输出流的设计、javax.swing包中一些图形界面构件功能的增强等地方都运用了装饰模式。</p><p><strong>1.主要优点</strong></p><p>装饰模式的主要优点如下：</p><p>(1) 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</p><p>(2) 可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</p><p>(3) 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。</p><p>(4) 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</p><p><strong>2.主要缺点</strong></p><p>装饰模式的主要缺点如下：</p><p>(1) 使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</p><p>(2) 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</p><p><strong>3.适用场景</strong></p><p>在以下情况下可以考虑使用装饰模式：</p><p>(1) 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p><p>(2) 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java中的final类）。</p><p>参考资料：《设计模式的艺术软件开发人员内功修炼之道》</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring MVC入门</title>
      <link href="/2018/09/16/Spring%20MVC%E5%85%A5%E9%97%A8/"/>
      <url>/2018/09/16/Spring%20MVC%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>这两天看多线程的几个锁和和并发容器以及优化真的脑壳疼，想起来框架学习真的不难，过阵子吸收完现在学的就去看看源码。现在开始更Spring MVC的基础，第一篇简单点，那就开始吧。</p><h3 id="一、Spring-MVC简介"><a href="#一、Spring-MVC简介" class="headerlink" title="一、Spring MVC简介"></a>一、Spring MVC简介</h3><p>Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2(一般老项目使用)等。 </p><p>我们平时说的Spring框架是狭义的，上面提到的Spring框架是广义的，更好理解为Spring大家族，Spring MVC是Spring大家族的一个表现层框架，很好地实现了MVC模式，与我们平时说的Spring框架关系紧密，毕竟同根同族嘛，这是我找到的关于它们两个关系的帖子<a href="https://www.cnblogs.com/xtdxs/p/6594191.html" target="_blank" rel="noopener">Spring和SpringMVC的区别</a>。</p><h3 id="二、Spring-MVC工作流程"><a href="#二、Spring-MVC工作流程" class="headerlink" title="二、Spring MVC工作流程"></a>二、Spring MVC工作流程</h3><p>说到Spring MVC工作流程那就必须得贴上这张经典的图了，学过Spring MVC肯定都看过这张或者类似的图</p><img src="/2018/09/16/Spring%20MVC入门/1.png"><p>具体解释下：</p><ol><li>用户通过浏览器向服务器发起请求，请求会被Spring MVC的前端控制器DispatcherServlet所拦截。</li><li>DispatcherServlet拦截到请求后，会调用处理器映射器HandlerMapping，通过HandlerMapping完成url到controller映射的组件。简单来说，就是将在springmvc.xml中配置的或者注解的url与对应的处理类找到并进行存储，用map&lt;url,handler&gt;这样的方式来存储。</li><li>处理器映射器HandlerMapping有了映射关系，并且根据请求url找到对应的处理器，生成处理器对象返回给DispatcherServlet，在返回前会加上很多拦截器。</li><li>DispatcherServlet会通过返回信息找到合适的处理器适配器HandlerAdapter。</li><li>HandlerAdapter会调用并执行处理器Handler（也叫后端控制器Controller）。</li><li>处理器会返回一个ModelAndView对象给HandlerAdapter。</li><li>通过HandlerAdapter将ModelAndView对象返回给前端控制器DispatcherServlet。</li><li>DispatcherServlet会根据ModelAndView对象选择一个合适的视图解析器ViewResolver去进行视图解析。</li><li>ViewResolver解析后，会向DispatcherServlet中返回具体的视图view。</li><li>DispatcherServlet根据view进行渲染（即将模型数据填充至视图中）。</li><li>视图渲染结果会返回给客户端浏览器显示。</li></ol><p>下面我们对上面出现的一些组件进行解释： </p><ol><li><p>前端控制器DispatcherServlet（不需要程序员开发）。</p><p>作用：接收请求，响应结果，相当于转发器，中央处理器。有了DispatcherServlet减少了其它组件之间的耦合度。</p></li><li><p>处理器映射器HandlerMapping（不需要程序员开发）。</p><p>作用：根据请求的url查找Handler。</p></li><li><p>处理器适配器HandlerAdapter（不需要程序员开发）。</p></li></ol><p>   作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler。</p><ol start="4"><li>处理器Handler（需要程序员开发）。</li></ol><p>   注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler。</p><ol start="5"><li>视图解析器ViewResolver（不需要程序员开发）。</li></ol><p>   作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）。</p><ol start="6"><li>视图View（需要程序员开发jsp）。</li></ol><p>   注意：View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）。</p><p><em>ps:不需要程序员开发的，需要程序员自己做一下配置即可。</em></p><p><em>pps:关于处理器映射器的配置，可以看<a href="https://www.cnblogs.com/lhblogs/p/7478800.html" target="_blank" rel="noopener">SpringMVC 学习笔记(处理器映射器的配置)</a></em>、<em><a href="https://blog.csdn.net/u013991521/article/details/53692362" target="_blank" rel="noopener">非注解和注解的处理器映射器和适配器—SpringMVC学习笔记（三）</a>。</em></p><p>好了，本来想写个入门demo，奈何时间太紧，这篇大概就这样结束了（好应付。。</p><p>同样，以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我，并感谢上面三篇帖子的作者。</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring mvc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring事务管理</title>
      <link href="/2018/09/14/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2018/09/14/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>最近忙着做课设，抽空看JVM和Java高并发，发现又好久没更博了，真的是忙得不可开交啊。。昨晚就抽空整理了一下Spring的事务管理，现在就讲讲吧。</p><h3 id="一、事务介绍"><a href="#一、事务介绍" class="headerlink" title="一、事务介绍"></a>一、事务介绍</h3><p>什么是事务管理呢，根据百度百科的介绍，<strong>事务管理是对于一系列数据库操作进行管理，一个事务包含一个或多个SQL语句，是逻辑管理的工作单元（原子单元）</strong>。学过数据库的同学都知道这么一个例子，比如你去ATM机取1000块钱，大体有两个步骤：第一步输入密码金额，银行卡扣掉1000元钱；第二步从ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。如何保证这两个步骤不会出现一个出现异常了，而另一个执行成功呢？事务就是用来解决这样的问题。事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。 在企业级应用程序开发中，事务管理是必不可少的技术，用来确保数据的完整性和一致性。</p><p>事务有四个特性：ACID </p><ul><li><p>原子性（Atomicity）：事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</p></li><li><p>一致性（Consistency）：一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</p></li><li><p>隔离性（Isolation）：可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</p></li></ul><p>持久性（Durability）：一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</p><h3 id="二、Spring事务管理的核心接口"><a href="#二、Spring事务管理的核心接口" class="headerlink" title="二、Spring事务管理的核心接口"></a>二、Spring事务管理的核心接口</h3><p>Spring事务管理接口： </p><ul><li>PlatformTransactionManager：（平台）事务管理器</li><li>TransactionDefinition： 事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)</li><li>TransactionStatus： 事务运行状态</li></ul><img src="/2018/09/14/Spring事务管理/1.png"><p>上图是Spring的事务管理接口之间的联系，下面我具体介绍这三个接口</p><h5 id="1-PlatformTransactionManager"><a href="#1-PlatformTransactionManager" class="headerlink" title="1.PlatformTransactionManager"></a>1.PlatformTransactionManager</h5><p>Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager。Spring并不直接管理事务，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，也就是将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 我们来看看PlatformTransactionManager的源码：</p><pre><code>Public interface PlatformTransactionManager()...{      // 由TransactionDefinition得到TransactionStatus对象    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;     // 提交    Void commit(TransactionStatus status) throws TransactionException;      // 回滚    Void rollback(TransactionStatus status) throws TransactionException;      } </code></pre><ul><li><p>TransactionStatus getTransaction(TransactionDefinition definition) ：事务管理器通过TransactionDefinition，获得“事务状态”，从而管理事务。</p></li><li><p>void commit(TransactionStatus status)：根据状态提交。</p></li><li><p>void rollback(TransactionStatus status)：根据状态回滚。</p></li></ul><p>上面说过，Spring并不直接管理事务，它只是提供了事务管理器的接口PlatformTransactionManager和三个方法，具体如何管理事务由它的实现类来完成。PlatformTransactionManager接口有许多不同的实现类，我们可以从上图看出，这里我再给张图让大家看看：</p><img src="/2018/09/14/Spring事务管理/2.png"><h5 id="2-TransactionStatus"><a href="#2-TransactionStatus" class="headerlink" title="2.TransactionStatus"></a>2.TransactionStatus</h5><p>TransactionStatus接口是事务的状态，它描述某一时间点上事务的状态信息。该接口包含六个方法，具体如下：</p><img src="/2018/09/14/Spring事务管理/3.png"><p>不知大家有没有发现，在PlatformTransactionManager接口中的TransactionStatus getTransaction(TransactionDefinition definition) 方法返回值类型就为TransactionStatus。</p><h5 id="3-TransactionDefinition"><a href="#3-TransactionDefinition" class="headerlink" title="3.TransactionDefinition"></a>3.TransactionDefinition</h5><p>上面讲到的事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到事务状态，这个方法里面的参数是TransactionDefinition类，这个类就定义了一些基本的事务属性。 </p><p>那么什么是事务属性呢？事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面，如图所示：</p><img src="/2018/09/14/Spring事务管理/4.png"><p>(1)传播行为：当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p><p>Spring 定义了如下七中传播行为，这里以A业务和B业务之间如何传播事务为例说明：</p><ul><li><p>PROPAGATION_REQUIRED：required，必须。默认值，A如果有事务，B将使用该事务；如果A没有事务，B将创建一个新的事务。</p></li><li><p>PROPAGATION_SUPPORTS：supports，支持。A如果有事务，B将使用该事务；如果A没有事务，B将以非事务执行。</p></li><li><p>PROPAGATION_MANDATORY：mandatory，强制。A如果有事务，B将使用该事务；如果A没有事务，B将抛异常。</p></li><li><p>PROPAGATION_REQUIRES_NEW：requires_new，必须新的。如果A有事务，将A的事务挂起，B创建一个新的事务；如果A没有事务，B创建一个新的事务。</p></li><li><p>PROPAGATION_NOT_SUPPORTED：not_supported，不支持。如果A有事务，将A的事务挂起，B将以非事务执行；如果A没有事务，B将以非事务执行。</p></li><li><p>PROPAGATION_NEVER：never，从不。如果A有事务，B将抛异常；如果A没有事务，B将以非事务执行。</p></li><li><p>PROPAGATION_NESTED：nested，嵌套。A和B底层采用保存点机制，形成嵌套事务。</p></li></ul><p>(2)隔离级别：定义了一个事务可能受其他并发事务影响的程度。</p><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。 </p><ul><li><p>脏读（Dirty reads）：脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</p></li><li><p>不可重复读（Nonrepeatable read）：不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。</p></li><li><p>幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录。</p></li></ul><p>在 Spring 事务管理中，为我们定义了如下的隔离级别： </p><table><thead><tr><th>名称</th><th>值</th><th>解释</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>-1</td><td>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>1</td><td>这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>2</td><td>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。</td></tr><tr><td>ISOLATION_REPEATABLE_READ</td><td>4</td><td>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻读。</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>8</td><td>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻读。</td></tr></tbody></table><p>(3)只读</p><p>这是事务的第三个特性，是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。 </p><p>(4)事务超时</p><p>为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。 </p><p>(5)回滚规则</p><p>事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的） 。但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。 </p><h3 id="三、编程式和声明式事务的区别"><a href="#三、编程式和声明式事务的区别" class="headerlink" title="三、编程式和声明式事务的区别"></a>三、编程式和声明式事务的区别</h3><p>编程式事务处理：所谓编程式事务指的是通过编码方式实现事务，允许用户在代码中精确定义事务的边界。即类似于JDBC编程实现事务管理。管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</p><p>声明式事务处理：管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。</p><p>简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。</p><p>好了，关于Spring事务管理我就讲这么多了，至于编程式和声明式事务的使用是比较简单的，大家如果不知道或者不熟悉的话可以看这篇帖子<a href="https://www.cnblogs.com/ysocean/p/7617620.html" target="_blank" rel="noopener">Spring详解（八）——事务管理</a>，上面说得很详细，本篇博文很多内容都是参考此帖，在这感谢作者。</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>适配器模式</title>
      <link href="/2018/09/08/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/08/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>适配器模式是做什么的？用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。 </p><h3 id="一、适配器模式概述"><a href="#一、适配器模式概述" class="headerlink" title="一、适配器模式概述"></a>一、适配器模式概述</h3><p>与电源适配器相似，在适配器模式中引入了一个被称为适配器(Adapter)的包装类，而它所包装的对象称为适配者(Adaptee)，即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。</p><p>适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无须修改原来的适配者接口和抽象目标类接口。适配器模式定义如下：</p><p><strong>适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</strong> </p><h3 id="二、对象适配器模式"><a href="#二、对象适配器模式" class="headerlink" title="二、对象适配器模式"></a>二、对象适配器模式</h3><p>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，<strong>在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</strong>在实际开发中，对象适配器的使用频率更高，对象适配器模式结构如图所示： </p><img src="/2018/09/08/适配器模式/1.jpg"><p>在对象适配器模式结构图中包含如下几个角色：</p><ul><li>Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li></ul><ul><li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</li></ul><ul><li>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li></ul><p>下面利用具体代码详细说明适配器模式（例子为对象适配器模式）。</p><pre><code>//目标抽象接口public interface Target {    //这是适配者Adaptee有的方法    public void sampleOperation1();     //这是适配者Adaptee没有的方法    public void sampleOperation2(); }</code></pre><pre><code>//适配者Adaptee类，有目标类所需的sampleOperation1()方法public class Adaptee {    public void sampleOperation1(){}}</code></pre><pre><code>//适配器Adapter类，实现目标接口public class Adapter implements Target {    private Adaptee adaptee;    public Adapter(Adaptee adaptee) {        this.adaptee = adaptee;    }    /**     * 适配者Adaptee有方法sampleOperation1     * 因此适配器类直接委派即可     */    public void sampleOperation1(){        this.adaptee.sampleOperation1();    }    /**     * 适配者Adaptee没有方法sampleOperation2     * 因此由适配器类需要补充此方法     */    public void sampleOperation2(){        //写相关的代码    }}</code></pre><p>如果你理解了这个例子，这还有一个例子也解释了适配器模式<a href="http://www.runoob.com/design-pattern/adapter-pattern.html" target="_blank" rel="noopener">适配器模式|菜鸟教程</a>，比我上面的稍微复杂了一点，大家尽量理解。</p><h3 id="三、类适配器模式"><a href="#三、类适配器模式" class="headerlink" title="三、类适配器模式"></a>三、类适配器模式</h3><p>除了对象适配器模式之外，适配器模式还有一种形式，那就是类适配器模式，<strong>类适配器模式和对象适配器模式最大的区别在于适配器和适配者之间的关系不同，对象适配器模式中适配器和适配者之间是关联关系，而类适配器模式中适配器和适配者是继承关系</strong>，类适配器模式结构如图所示： </p><img src="/2018/09/08/适配器模式/2.jpg"><p>根据类适配器模式结构图，适配器类实现了抽象目标类接口Target，并继承了适配者类，在适配器类的request()方法中调用所继承的适配者类的specificRequest()方法，实现了适配。典型的类适配器代码如下所示：</p><pre><code>class Adapter extends Adaptee implements Target {      public void request() {          specificRequest();      }  }  </code></pre><p>由于Java、C#等语言不支持多重类继承，因此类适配器的使用受到很多限制，例如如果目标抽象类Target不是接口，而是一个类，就无法使用类适配器；此外，如果适配者Adapter为最终(Final)类，也无法使用类适配器。在Java等面向对象编程语言中，大部分情况下我们使用的是对象适配器，类适配器较少使用。 </p><h3 id="四、双向适配器模式"><a href="#四、双向适配器模式" class="headerlink" title="四、双向适配器模式"></a>四、双向适配器模式</h3><p>在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器，其结构示意图如图所示： </p><img src="/2018/09/08/适配器模式/3.jpg"><p>双向适配器的实现较为复杂，其典型代码如下所示： </p><pre><code>class Adapter implements Target,Adaptee {      //同时维持对抽象目标类和适配者的引用      private Target target;      private Adaptee adaptee;      public Adapter(Target target) {          this.target = target;      }      public Adapter(Adaptee adaptee) {          this.adaptee = adaptee;      }      public void request() {          adaptee.specificRequest();      }      public void specificRequest() {          target.request();      }  }  </code></pre><p>在实际开发中，我们很少使用双向适配器。 </p><h3 id="五、缺省适配器模式"><a href="#五、缺省适配器模式" class="headerlink" title="五、缺省适配器模式"></a>五、缺省适配器模式</h3><img src="/2018/09/08/适配器模式/4.jpg"><p>缺省适配器模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。当原接口中定义的方法太多，而其中大部分又不被需要时，这种模式非常实用。<strong>由缺省适配器类直接实现目标角色接口，并为所有方法提供缺省的空实现。用户类就只需要继承适配器类，只实现感兴趣的方法就行了。</strong> 作为适配器模式的一个特例，缺省适配器模式在JAVA语言中有着特殊的应用。 </p><p>以下是实例代码</p><pre><code>//目标接口，部分方法我们需要public interface SubjectTarget {    void learnChinese();    void learnEnglish();    void learnMath();    void learnBiological();}</code></pre><pre><code>//缺省适配器，为目标接口实现空方法public abstract class SubjectAdapter implements SubjectTarget {    @Override    public void learnChinese() {    }    @Override    public void learnEnglish() {    }    @Override    public void learnMath() {    }    @Override    public void learnBiological() {    }}</code></pre><pre><code>//用户类public class StudentA extends SubjectAdapter {    @Override    public void learnMath() {        super.learnMath();        System.out.println(&quot;just learn Math&quot;);    }}public class StudentB extends SubjectAdapter {    @Override    public void learnChinese() {        super.learnChinese();        System.out.println(&quot;just lear Chinese&quot;);    }}</code></pre><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在spring等开源框架、驱动程序设计（如JDBC中的数据库驱动程序）中也使用了适配器模式。</p><p><strong>1.主要优点</strong></p><p>无论是对象适配器模式还是类适配器模式都具有如下优点：</p><p>(1)将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</p><p>(2)增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</p><p>(3)灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p><p>具体来说，<strong>类适配器模式</strong>还有如下优点：</p><p>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</p><p><strong>对象适配器模式</strong>还有如下优点：</p><ul><li>一个对象适配器可以把多个不同的适配者适配到同一个目标；</li></ul><ul><li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li></ul><p><strong>2.主要缺点</strong></p><p><strong>类适配器模式</strong>的缺点如下：</p><p>(1)对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</p><p>(2)适配者类不能为最终类，如在Java中不能为final类，C#中不能为sealed类；</p><p>(3)在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</p><p><strong>对象适配器模式</strong>的缺点如下：</p><p>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</p><p><strong>3.适用场景</strong></p><p>在以下情况下可以考虑使用适配器模式：</p><p>(1)系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</p><p>(2)想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p><p>参考资料：《设计模式的艺术软件开发人员内功修炼之道》</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring AOP总结</title>
      <link href="/2018/09/02/Spring%20AOP%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/02/Spring%20AOP%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>关于Spring AOP，我在准备这篇博文的时候发现了一篇讲得非常全面的帖子<a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">关于 Spring AOP (AspectJ) 你该知晓的一切</a>，相信大家好好读完肯定会对Spring AOP有所领悟。基于这篇帖子实在是写得太优秀，所以我这篇博文对Spring AOP也不再解释什么，主要就是自己记下易忘的知识点。 </p><p>静态代理是编译阶段生成AOP代理类，也就是说生成的字节码就织入了增强后的AOP对象；动态代理则不会修改字节码，而是在内存中临时生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。 </p><p>Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理。JDK动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类。 如果目标类没有实现接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意，CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的，诸如private的方法也是不可以作为切面的。</p><h3 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、<strong>静态代理</strong></h3><p>由程序员创建或由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。 </p><pre><code>public interface PersonDao {    void savePerson();}</code></pre><pre><code>public class PersonDaoImpl implements PersonDao {    @Override    public void savePerson() {        System.out.println(&quot;save person&quot;);    }}</code></pre><pre><code>public class Transaction {    void beginTransaction() {        System.out.println(&quot;begin Transaction&quot;);    }    void commit() {        System.out.println(&quot;commit&quot;);    }}</code></pre><p>接下来编写静态代理类—实现PersonDao接口 </p><pre><code>/** * 静态代理类 */public class PersonDaoProxy implements PersonDao{    PersonDao personDao;    Transaction transaction;    public PersonDaoProxy(PersonDao personDao, Transaction transaction) {        this.personDao = personDao;        this.transaction = transaction;    }    @Override    public void savePerson() {        this.transaction.beginTransaction();        this.personDao.savePerson();        this.transaction.commit();    }}</code></pre><pre><code>/** * 测试静态代理 */public class TestPersonProxy {    @Test    public void testSave(){        PersonDao personDao = new PersonDaoImpl();        Transaction transaction = new Transaction();        PersonDaoProxy proxy = new PersonDaoProxy(personDao, transaction);        proxy.savePerson();    }}</code></pre><p>总结：</p><p>(1)静态代理模式并没有做到事务的重用。</p><p>(2)假设dao有100个类，100个proxy，接口中有多少方法，在proxy层就得实现多少方法，有多少方法就要开启和提交多少事务。</p><p>(3)如果一个proxy实现了多个接口，如果其中的一个接口发生变化（添加了一个方法），那么proxy也要做相应改变。</p><h3 id="二、JDK动态代理"><a href="#二、JDK动态代理" class="headerlink" title="二、JDK动态代理"></a>二、JDK动态代理</h3><p>动态代理类：在程序运行时，运用反射机制动态创建而成。</p><p>JDK的动态代理必须具备四个条件：1、目标接口 2、目标类 3、拦截器 4、代理类</p><p>使用上个例子的PersonDao接口、PersonDaoImpl类及Transaction类</p><p>编写拦截器</p><pre><code>import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;/** * 拦截器  *         1、目标类导入进来  *         2、事物导入进来  *         3、invoke完成：开启事务、调用目标对象的方法、事务提交 */public class Interceptor implements InvocationHandler {    private Object target; // 目标类    private Transaction transaction;    public Interceptor(Object target, Transaction transaction) {        this.target = target;        this.transaction = transaction;    }    /**     * @param proxy 目标对象的代理类实例     * @param method 对应于在代理实例上调用接口方法的Method实例     * @param args 传入到代理实例上方法参数值的对象数组     * @return 方法的返回值，没有返回值是null     * @throws Throwable     */    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        String methodName = method.getName();        if (&quot;savePerson&quot;.equals(methodName) || &quot;deletePerson&quot;.equals(methodName) || &quot;updatePerson&quot;.equals(methodName)) {            this.transaction.beginTransaction(); // 开启事务            method.invoke(target); // 调用目标方法            this.transaction.commit(); // 提交事务        } else {            method.invoke(target);        }        return null;    }}</code></pre><p>测试 </p><pre><code>/** * 测试jdk动态代理 */public class TestJDKProxy {    @Test    public void testSave(){        /**         * 1、创建一个目标对象         * 2、创建一个事务         * 3、创建一个拦截器         * 4、动态产生一个代理对象         */        Object target = new PersonDaoImpl();        Transaction transaction = new Transaction();        Interceptor interceptor = new Interceptor(target, transaction);        /**         * 参数一：设置代码使用的类加载器，一般采用跟目标类相同的类加载器         * 参数二：设置代理类实现的接口，跟目标类使用相同的接口         * 参数三：设置回调对象，当代理对象的方法被调用时，会调用该参数指定对象的invoke方法         */        PersonDao personDao = (PersonDao) Proxy.newProxyInstance(                target.getClass().getClassLoader(),                target.getClass().getInterfaces(),                interceptor);        personDao.savePerson();    }}</code></pre><p>总结：</p><p>(1)因为利用JDKProxy生成的代理类实现了接口，所以目标类中所有的方法在代理类中都有。</p><p>(2)生成的代理类的所有的方法都拦截了目标类的所有的方法。而拦截器中invoke方法的内容正好就是代理类的各个方法的组成体。</p><p>(3)利用JDKProxy方式必须有接口的存在。</p><p>(4)invoke方法中的三个参数可以访问目标类的被调用方法的API、被调用方法的参数、被调用方法的返回类型。</p><p>缺点：</p><p>(1)在拦截器中除了能调用目标对象的目标方法以外，功能是比较单一的，在这个例子中只能处理事务。<br>(2)拦截器中的invoke方法的if判断语句在真实的开发环境下是不靠谱的，因为一旦方法很多if语句需要写很多。</p><h3 id="三、CGLIB动态代理"><a href="#三、CGLIB动态代理" class="headerlink" title="三、CGLIB动态代理"></a>三、CGLIB动态代理</h3><p>使用上个例子的PersonDaoImpl类和Transaction类（不用接口）</p><p>编写拦截器类</p><pre><code>import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;/** * CGLIB代理 拦截器  */public class Interceptor  implements MethodInterceptor {    private Object target; // 代理的目标类    private Transaction transaction;    public Interceptor(Object target, Transaction transaction) {        this.target = target;        this.transaction = transaction;    }    /**     * 创建目标对象的代理对象     *      * @return     */    public Object createProxy() {        // 代码增强        Enhancer enhancer = new Enhancer(); // 该类用于生成代理对象        enhancer.setCallback(this); // 参数为拦截器        enhancer.setSuperclass(target.getClass());// 设置父类        return enhancer.create(); // 创建代理对象    }    /**     * @param obj 目标对象代理类的实例     * @param method 代理实例上 调用父类方法的Method实例     * @param args 传入到代理实例上方法参数值的对象数组     * @param methodProxy 使用它调用父类的方法     * @return     * @throws Throwable     */    public Object intercept(Object obj, Method method, Object[] args,            MethodProxy methodProxy) throws Throwable {        this.transaction.beginTransaction();        method.invoke(target);        this.transaction.commit();        return null;    }}</code></pre><p>测试 </p><pre><code>/** * 测试cglib动态代理 * 通过cglib产生的代理对象，代理类是目标类的子类 */public class TestCglibProxy {    @Test    public void testSave(){        Object target = new PersonDaoImpl();        Transaction transaction = new Transaction();        Interceptor interceptor = new Interceptor(target, transaction);        PersonDaoImpl personDaoImpl = (PersonDaoImpl) interceptor.createProxy();        personDaoImpl.savePerson();    }}</code></pre><p>总结：</p><p>(1)CGLIB是一个强大的,高性能,高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。</p><p>(2)用CGLIB生成代理类是目标类的子类。</p><p>(3)用CGLIB生成 代理类不需要接口。</p><p>(4)用CGLIB生成的代理类重写了父类的各个方法。</p><p>(5)拦截器中的intercept方法内容正好就是代理类中的方法体。</p><h3 id="四、CGLIB和JDK动态代理区别"><a href="#四、CGLIB和JDK动态代理区别" class="headerlink" title="四、CGLIB和JDK动态代理区别"></a>四、CGLIB和JDK动态代理区别</h3><p>JDK:</p><p>(1)目标类和代理类实现了共同的接口。</p><p>(2)拦截器必须实现InvocationHandler接口，而这个接口中invoke方法体的内容就是代理对象方法体的内容。</p><p>CGLIB:</p><p>(1)目标类是代理类的父类。</p><p>(2)拦截器必须实现MethodInterceptor接口，而接口中的intercept方法就是代理类的方法体，使用字节码增强机制创建代理对象的。</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>建造者模式</title>
      <link href="/2018/08/23/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/23/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>今天更下创建性模式的最后一种，也是不那么常见但难度较高的一种设计模式–建造者模式。这篇更完这个暑假大概就不更了，还剩一周多时间我打算放松放松，再完成下学校的作业。拾掇拾掇准备开学，下篇更Spring AOP。废话不说，开始吧。</p><p>没有人买车会只买一个轮胎或者方向盘，大家买的都是一辆包含轮胎、方向盘和发动机等多个部件的完整汽车。如何将这些部件组装成一辆完整的汽车并返回给用户，这是建造者模式需要解决的问题。建造者模式又称为生成器模式，它是一种较为复杂、使用频率也相对较低的创建型模式。建造者模式为客户端返回的不是一个简单的产品，而是一个由多个部件组成的复杂产品。</p><h3 id="一、建造者模式概述"><a href="#一、建造者模式概述" class="headerlink" title="一、建造者模式概述"></a>一、建造者模式概述</h3><p>建造者模式是较为复杂的创建型模式，它将客户端与包含多个组成部分（或部件）的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可。它关注如何一步一步创建一个的复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，无须修改已有代码，系统具有较好的扩展性。</p><p><strong>建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。</strong> </p><p> 建造者模式一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式结构如图所示： </p><img src="/2018/08/23/建造者模式/建造者模式.png"><p>在建造者模式结构图中包含如下几个角色：</p><ul><li><p>Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是getResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。</p></li><li><p>ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</p></li><li><p>Product（产品角色）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</p></li><li><p>Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。</p></li></ul><p>在建造者模式的定义中提到了复杂对象，那么什么是复杂对象？简单来说，复杂对象是指那些包含多个成员属性的对象，这些成员属性也称为部件或零件，如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件，一个典型的复杂对象类代码示例如下：</p><pre><code>class Product {       private String partA; //定义部件，部件可以是任意类型，包括值类型和引用类型       private String partB;       private String partC;       //partA的Getter方法和Setter方法省略       //partB的Getter方法和Setter方法省略       //partC的Getter方法和Setter方法省略}</code></pre><p>在抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下： </p><pre><code>abstract class Builder {    //创建产品对象    protected Product product = new Product();    public abstract void buildPartA();    public abstract void buildPartB();    public abstract void buildPartC();    //返回产品对象    public Product getResult() {        return product;    }}</code></pre><p>在抽象类Builder中声明了一系列抽象的buildPartX()方法用于创建复杂产品的各个部件，具体建造过程在ConcreteBuilder中实现，此外还提供了工厂方法getResult()，用于返回一个建造好的完整产品。</p><p>在ConcreteBuilder中实现了buildPartX()方法，通过调用Product的setPartX()方法可以给产品对象的成员属性设值。不同的具体建造者在实现buildPartX()方法时将有所区别，如setPartX()方法的参数可能不一样，在有些具体建造者类中某些setPartX()方法无须实现（提供一个空实现）。而这些对于客户端来说都无须关心，客户端只需知道具体建造者类型即可。</p><pre><code>public class ConcreteBuilder extends Builder {    /**     * 产品零件建造方法A     */    @Override    public void buildPartA() {        //构建产品的第一个零件 　　　　product.setPartA(&quot;编号：0001&quot;);    }    /**     * 产品零件建造方法B     */    @Override    public void buildPartB() {        //构建产品的第二个零件 　　　　product.setPartB(&quot;名称：firstTool&quot;);    }    /**     * 产品零件建造方法C     */    @Override    public void buildPartC() {        //构建产品的第三个零件 　　　　product.setPartC(&quot;日期：20180823&quot;);    }    /**     * 产品返还方法     */    public Product getResult() {        return product;    }}</code></pre><p>在建造者模式的结构中还引入了一个指挥者类Director，该类主要有两个作用：一方面它隔离了客户与创建过程；另一方面它控制产品的创建过程，包括某个buildPartX()方法是否被调用以及多个buildPartX()方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。在实际生活中也存在类似指挥者一样的角色，如一个客户去购买电脑，电脑销售人员相当于指挥者，只要客户确定电脑的类型，电脑销售人员可以通知电脑组装人员给客户组装一台电脑。指挥者类的代码示例如下：</p><pre><code>class Director {    private Builder builder;    public Director(Builder builder) {        this.builder = builder;    }    public void setBuilder(Builder builder) {        this.builder = builer;    }    //产品构建与组装方法    public Product construct() {        builder.buildPartA();        builder.buildPartB();         builder.buildPartC();         return builder.getResult();    }}</code></pre><p>客户端类Client</p><pre><code>public class Client {    public static void main(String []args) {        Builder builder = new ConcreteBuilder();        Director director = new Director(builder);        Product product = director.construct();        System.out.println(product.getPartA());        System.out.println(product.getPartB());        System.out.println(product.getPartC());    }}</code></pre><p>客户端负责创建导演者和具体建造者对象。然后，客户端把具体建造者对象交给导演者，导演者操作具体建造者，开始创建产品。当产品完成后，建造者把产品返还给客户端。把创建具体建造者对象的任务交给客户端而不是导演者对象，是为了将导演者对象与具体建造者对象的耦合变成动态的，从而使导演者对象可以操纵数个具体建造者对象中的任何一个。</p><p>建造者模式分成两个很重要的部分：</p><ul><li><p>一个部分是Builder接口，这里是定义了如何构建各个部件，也就是知道每个部件功能如何实现，以及如何装配这些部件到产品中去；</p></li><li><p>另外一个部分是Director，Director是知道如何组合来构建产品，也就是说Director负责整体的构建算法，而且通常是分步骤地来执行。</p></li></ul><p>不管如何变化，<strong>建造者模式都存在这么两个部分，一个部分是部件构造和产品装配，另一个部分是整体构建的算法</strong>。认识这点是很重要的，因为在建造者模式中，强调的是固定整体构建的算法，而灵活扩展和切换部件的具体构造和产品装配的方式。</p><p>再直白点说，建造者模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用。具体的构造实现可以很方便地扩展和切换，从而可以灵活地组合来构造出不同的产品对象。</p><h3 id="二、建造者模式总结"><a href="#二、建造者模式总结" class="headerlink" title="二、建造者模式总结"></a>二、建造者模式总结</h3><p>建造者模式的核心在于如何一步步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品，在软件开发中，如果我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式。</p><h5 id="1-主要优点"><a href="#1-主要优点" class="headerlink" title="1.主要优点"></a>1.主要优点</h5><p>建造者模式的主要优点如下：</p><p>(1)在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><p>(2)每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“开闭原则”。</p><p>(3)可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p><h5 id="2-主要缺点"><a href="#2-主要缺点" class="headerlink" title="2.主要缺点"></a>2.主要缺点</h5><p>建造者模式的主要缺点如下：</p><p>(1)建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p>(2)如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。</p><h5 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3.适用场景"></a>3.适用场景</h5><p>在以下情况下可以考虑使用建造者模式：</p><p>(1)需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</p><p>(2)需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</p><p>(3)对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。</p><p>(4)隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原型模式</title>
      <link href="/2018/08/20/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/20/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>在开发过程中，有时会遇到为一个类创建多个实例的情况，这些实例内部成员往往完全相同或有细微的差异，而且实例的创建开销比较大或者需要输入较多参数，如果能通过复制一个已创建的对象实例来重复创建多个相同的对象，这就可以大大减少创建对象的开销，这个时候就需要原型模式。 </p><h3 id="一、原型模式概述"><a href="#一、原型模式概述" class="headerlink" title="一、原型模式概述"></a>一、原型模式概述</h3><p>在使用原型模式时，我们需要首先创建一个原型对象，再通过复制这个原型对象来创建更多同类型的对象。原型模式的定义如下：</p><p><strong>原型模式(Prototype  Pattern)：使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。</strong> </p><p>原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p><p>需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p><p>原型模式的结构如图所示： </p><img src="/2018/08/20/原型模式/原型模式.png"><p>在原型模式结构图中包含如下几个角色：</p><p>Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</p><p>ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p><p>Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</p><p>原型模式的核心在于如何实现克隆方法，下面将介绍两种在Java语言中常用的克隆实现方法：</p><h5 id="1-通用实现方法"><a href="#1-通用实现方法" class="headerlink" title="1.通用实现方法"></a>1.通用实现方法</h5><p>通用的克隆实现方法是在具体原型类的克隆方法中实例化一个与自身类型相同的对象并将其返回，并将相关的参数传入新创建的对象中，保证它们的成员属性相同。示意代码如下所示： </p><pre><code>//接口Prototype不写了，它声明了个clone()方法class ConcretePrototype implements Prototype {    private String attr; //成员属性    public void setAttr(String attr) {        this.attr = attr;    }    public String  getAttr() {        return this.attr;    }    //实现父接口Prototype方法    public Prototype clone() {        Prototype prototype = new ConcretePrototype(); //创建新对象        prototype.setAttr(this.attr);        return prototype;    }}</code></pre><p>在客户类中我们只需要创建一个ConcretePrototype对象作为原型对象，然后调用其clone()方法即可得到对应的克隆对象，如下代码所示： </p><pre><code>Prototype obj1 = new ConcretePrototype();obj1.setAttr(&quot;Sunny&quot;);Prototype obj2 = obj1.clone();</code></pre><p>这种方法可作为原型模式的通用实现，它与编程语言特性无关，任何面向对象语言都可以使用这种形式来实现对原型的克隆。 </p><h5 id="2-Java语言提供的clone-方法"><a href="#2-Java语言提供的clone-方法" class="headerlink" title="2.Java语言提供的clone()方法"></a>2.Java语言提供的clone()方法</h5><p>学过Java语言的人都知道，所有的Java类都继承自java.lang.Object。事实上，Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。</p><p>需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。如下代码所示：</p><pre><code>class ConcretePrototype implements Cloneable {    ……    public Prototype clone() {        Object object = null;        try {            object = super.clone();        } catch (CloneNotSupportedException exception) {            System.err.println(&quot;Not support cloneable&quot;);        }        return (Prototype)object;        }    ……}</code></pre><p> 在客户端创建原型对象和克隆对象也很简单，如下代码所示： </p><pre><code>Prototype obj1 = new ConcretePrototype();Prototype obj2 = obj1.clone();</code></pre><p>一般而言，Java语言中的clone()方法满足：</p><p>(1)对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；</p><p>(2)对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；</p><p>(3)如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。</p><p>为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：</p><p>(1)在派生类中覆盖基类的clone()方法，并声明为public；</p><p>(2)在派生类的clone()方法中，调用super.clone()；</p><p>(3)派生类需实现Cloneable接口。</p><p>此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。</p><h3 id="二、浅克隆和深克隆"><a href="#二、浅克隆和深克隆" class="headerlink" title="二、浅克隆和深克隆"></a>二、浅克隆和深克隆</h3><p>浅克隆和深克隆，在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制，下面将对两者进行详细介绍。 </p><h5 id="1-浅克隆"><a href="#1-浅克隆" class="headerlink" title="1.浅克隆"></a>1.浅克隆</h5><p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</p><img src="/2018/08/20/原型模式/浅克隆.png"><p><strong>在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆</strong>，即上述的第二种方法，下面举例</p><pre><code>//普通Author类public class Author {    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><pre><code>//Book类实现Cloneable接口class Book implements Cloneable {    private String title;    //Author类成员变量    private Author author;    public Book clone() {        Book book = null;        try {            book = (Book)super.clone();        } catch (CloneNotSupportedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }        return book;    }    public String getTitle() {        return title;    }    public void setTitle(String title) {        this.title = title;    }    public Author getAuthor() {        return author;    }    public void setAuthor(Author author) {        this.author = author;    }}</code></pre><pre><code>//测试类public class PrototypeTest {    public static void main(String[] args) {        Book book1 = new Book();        Author author = new Author();        author.setName(&quot;stormjie&quot;);        book1.setAuthor(author);        book1.setTitle(&quot;stormjie&#39;s blog&quot;);        Book book2 = book1.clone();        System.out.println(book1 == book2);  // false        System.out.println(book1.getTitle() == book2.getTitle());  // true        System.out.println(book1.getAuthor() == book2.getAuthor());  // true                    }}</code></pre><p>由输出的结果可以验证说到的结论。由此我们发现：虽然克隆出来的对象重新在堆上开辟了内存空间，但是，对象中各属性确保持相等。对于基本数据类型很好理解，但对于引用数据类型来说，则意味着此引用类型的属性所指向的对象本身是相同的， 并没有重新开辟内存空间存储。换句话说，引用类型的属性所指向的对象并没有克隆。<br>由此，我们将其称之为浅克隆。当克隆后的对象的引用类型的属性所指向的对象也重新得以克隆，此时，称之为深克隆。</p><h5 id="2-深克隆"><a href="#2-深克隆" class="headerlink" title="2.深克隆"></a>2.深克隆</h5><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p><img src="/2018/08/20/原型模式/深克隆.png"><p>在Java语言中，如果需要实现深克隆，可以通过序列化(Serialization)等方式来实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。需要注意的是能够实现序列化的对象其类必须实现Serializable接口，否则无法实现序列化操作。 下面我们使用深克隆技术来实现上述Book对象和Author对象的复制，由于要将Book对象和Author对象都写入流中，因此两个类均需要实现Serializable接口。</p><pre><code>class Author implements Serializable{    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><pre><code>class Book implements Serializable {    private String title;    private Author author;    public Book deepClone() throws IOException,ClassNotFoundException {        // 写入当前对象的二进制流         ByteArrayOutputStream bos = new ByteArrayOutputStream();          ObjectOutputStream oos = new ObjectOutputStream(bos);          oos.writeObject(this);        // 读出二进制流产生的新对象          ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());          ObjectInputStream ois = new ObjectInputStream(bis);          return (Book)ois.readObject();    }    public String getTitle() {        return title;    }    public void setTitle(String title) {        this.title = title;    }    public Author getAuthor() {        return author;    }    public void setAuthor(Author author) {        this.author = author;    }}</code></pre><pre><code>//测试类public class PrototypeTest {    public static void main(String[] args) throws ClassNotFoundException,IOException {        Book book1 = new Book();        Author author = new Author();        author.setName(&quot;stormjie&quot;);        book1.setAuthor(author);        book1.setTitle(&quot;stormjie&#39;s blog&quot;);        Book book2 = book1.deepClone();        System.out.println(book1 == book2);  // false        System.out.println(book1.getTitle() == book2.getTitle());  // true        System.out.println(book1.getAuthor() == book2.getAuthor());  // false        }}</code></pre><p>从输出结果中可以看出，深克隆不仅在堆内存上开辟了空间以存储克隆出的对象，甚至连对象中的引用类型的属性所指向的对象也得以克隆，重新开辟了堆空间存储。深克隆技术实现了原型对象和克隆对象的完全独立，对任意克隆对象的修改都不会给其他对象产生影响，是一种更为理想的克隆实现方式。 </p><p>扩展：Java语言提供的Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。</p><h3 id="三、原型模式总结"><a href="#三、原型模式总结" class="headerlink" title="三、原型模式总结"></a>三、原型模式总结</h3><p>原型模式的优点：</p><p>(1)当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</p><p>(2)扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</p><p>(3)原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</p><p>(4)可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。</p><p>原型模式的缺点：</p><p>(1)需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</p><p>(2)在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</p><p>参考资料：《设计模式的艺术软件开发人员内功修炼之道》</p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring的Bean与IoC实现</title>
      <link href="/2018/08/18/Spring%E7%9A%84Bean%E4%B8%8EIoC%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/18/Spring%E7%9A%84Bean%E4%B8%8EIoC%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="一、传统JavaBean与Spring的Bean的区别"><a href="#一、传统JavaBean与Spring的Bean的区别" class="headerlink" title="一、传统JavaBean与Spring的Bean的区别"></a>一、传统JavaBean与Spring的Bean的区别</h3><p>JavaBean现在很少人使用，Spring的Bean可以说是JavaBean的发展，但已经完全不是一样了。</p><p>规范：Spring容器对Bean 没有特殊要求，不像JavaBean 一样遵循一些规范（为每个属性提供相应的setter 和 getter 方法），不过对于设值注入的Bean，一定要提供setter 方法。</p><p>作用：Spring中的Bean是Java 实例、Java组件，它的作用几乎无所不包，任何应用组件都被称为Bean，而传统的Java应用中的JavaBean通常作为DTO（数据传输对象），来封装值对象，在各层之间传递数据。</p><p>生命周期：传统的JavaBean作为值对象传递，不接受任何容器管理其生命周期，Spring中的Bean有Spring管理其生命周期行为。</p><h3 id="二、Bean的实例化"><a href="#二、Bean的实例化" class="headerlink" title="二、Bean的实例化"></a>二、Bean的实例化</h3><p>在Spring中实例化Bean有三种方式，分别为构造器实例化、静态工厂方式实例化和实例工厂方式实例化，其中最常用的是<strong>构造器实例化</strong>，下面我就对构造器实例化做详解。</p><p>首先写一个普通的Bean，我们不写它的构造函数，使用它默认的无参构造函数</p><pre><code>package com.spring.demo;public class myBean {    public void print(){        System.out.println(&quot;myBean......&quot;);    }}</code></pre><p>接着在相同目录下配置Bean的xml文件bean.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;!-- 关键部分 --&gt;    &lt;bean id=&quot;bean1&quot; class=&quot;com.spring.demo.myBean&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>&lt;bean id = “bean1” class=”com.spring.demo.myBean”&gt;&lt;/bean&gt;：</p><p>id为在xml文件里的这个bean的标识，class为xml文件里的这个bean绑定的Java类(bean)的全路径(包名+类名)。</p><p>这个标签会自动寻找myBean类中的无参数构造函数来创建对象。</p><p>最后我们测试一下，在相同目录下编写一个测试类</p><pre><code>package com.spring.demo;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Text {    @Test    public void textUser() {        //Spring容器ApplicationContext在加载配置文件时对Bean进行实例化        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);         //由配置文件返回对象         myBean b = (myBean)context.getBean(&quot;bean1&quot;);         System.out.println(b);         b.print();    }}</code></pre><p>好了，上面就是Bean实例化中最常用的构造器实例化的一个例子，关于Bean配置中常用的标签和属性，不熟的话可以看看这篇<a href="https://www.cnblogs.com/V1haoge/p/5859556.html" target="_blank" rel="noopener">Spring中Bean的配置</a>，还想深入了解其他两种实例化方式的话可以看看这篇<a href="https://www.cnblogs.com/leihuazhe/p/7719539.html" target="_blank" rel="noopener">Spring学习之实例化bean的三种方式</a>。</p><h3 id="三、Bean的作用域"><a href="#三、Bean的作用域" class="headerlink" title="三、Bean的作用域"></a>三、Bean的作用域</h3><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p><ul><li><p>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例。</p></li><li><p>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例。</p></li><li><p>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效。</p></li><li><p>session：对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效。</p></li><li><p>globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效。</p></li></ul><p>用法举例：<code>&lt;bean id=&quot;bean1&quot; class=&quot;com.spring.demo&quot; scope=&quot;singleton&quot;/&gt;</code> </p><p>其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。也就是说，初始化生命周期回调方法在所有作用域的Bean是都会调用的，但是销毁生命周期回调方法在prototype作用域的Bean是不会调用的。 </p><p><strong>如果不指定Bean的作用域，Spring默认使用singleton作用域。</strong>Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p><p><em>这是基于线程安全性的考虑，如果使用有状态的Bean对象用singleton作用域，而无状态的Bean对象用prototype作用域。</em></p><h3 id="四、Bean的生命周期"><a href="#四、Bean的生命周期" class="headerlink" title="四、Bean的生命周期"></a>四、Bean的生命周期</h3><img src="/2018/08/18/Spring的Bean与IoC实现/springbean.png"><p>1.Spring对Bean进行实例化（相当于程序中的new Xx()） </p><p>2.Spring将值和Bean的引用注入进Bean对应的属性中</p><p>3.如果Bean实现了BeanNameAware接口，Spring将Bean的ID传递给setBeanName()方法（实现BeanNameAware清主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的）</p><p>4.如果Bean实现了BeanFactoryAware接口，Spring将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。（实现BeanFactoryAware 主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等）</p><p>5.如果Bean实现了ApplicationContextAwaer接口，Spring容器将调用setApplicationContext(ApplicationContext ctx)方法，把y应用上下文作为参数传入<br>（作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext 的参数传入，而Spring容器在调用setBeanDactory前需要程序员自己指定（注入）setBeanDactory里的参数BeanFactory ）</p><p>6.如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessBeforeInitialization（预初始化）方法（作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能）</p><p>7.如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法，作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法。</p><p>8.如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessAfterInitialization（后初始化）方法（作用与6的一样，只不过6是在Bean初始化前执行的，而这个是在Bean初始化后执行的，时机不同 )</p><p>9.经过以上的工作后，Bean如果定义作用范围为prototype，则该Bean交给调用者，调用者管理Bean的生命周期，Spring不再管理该Bean，否则Bean交给Spring IoC的缓冲池，将触发Spring对该Bean的生命周期管理。</p><p>10.如果Bean实现了DispostbleBean接口，Spring将调用它的destory方法，作用与在配置文件中对Bean使用destory-method属性的作用一样，都是在Bean实例销毁前执行的方法。</p><h3 id="五、IoC实现"><a href="#五、IoC实现" class="headerlink" title="五、IoC实现"></a>五、IoC实现</h3><p>IoC的实现即Bean依赖注入的方式，也就是Bean的装配方式。Spring容器支持多种形式的Bean的装配方式，我想讲三种主要的装配方式。</p><h5 id="1-基于XML的装配"><a href="#1-基于XML的装配" class="headerlink" title="1.基于XML的装配"></a>1.基于XML的装配</h5><p>Spring提供了两种基于XML的装配方式：设值注入和构造注入。下面就讲解下如何在XML配置文件中使用这两种注入方式来实现基于XML的装配。</p><p>在Spring实例化Bean的过程中，Spring首先会调用Bean的默认构造方法来实例化Bean对象，然后通过反射的方式调用setter方法来注入属性值。因此，设值注入一个Bean必须满足以下两点要求。</p><ul><li><p>Bean类必须提供一个默认的无参构造方法。</p></li><li><p>Bean类必须为需要注入的属性提供对应的setter方法。</p></li></ul><p>使用设值注入时，在Spring配置文件中，需要使用&lt;bean&gt;元素的子元素&lt;property&gt;来为每个属性注入值；而使用构造注入时，在配置文件里，需要使用&lt;bean&gt;元素的子元素&lt;constructor-arg&gt;来定义构造方法的参数，可以使用其value属性（或子元素）来设置该参数的值。下面通过一个案例来演示基于XML方式的Bean的装配。</p><pre><code>//接口就不写了，下同package dao;public class UserDaoImpl implements UserDao {    private String username;    private String password;    /**     *1.使用构造注入     *提供带所有参数的有参构造方法     */    public UserDaoImpl(String username,String password) {        super();        this.username = username;        this.password = password;    }    /**     *2.使用设值注入     *提供默认无参构造方法     *为所有属性提供setter方法     */    public UserDaoImpl() {        }    public void setUsername(String username) {        this.username = username;    }    public void setPassword(String password) {        this.password = password;    }    @Override    public void save() {        System.out.println(&quot;hello,User Dao...My name is &quot;+username+&quot; password is &quot;+password);            } }</code></pre><p>UserDaoImpl的对象作为UserServiceImpl成员变量</p><pre><code>package service;import dao.UserDao;public class UserServiceImpl implements UserService {    private UserDao userDao;    /**     *1.使用构造注入     *提供带所有参数的有参构造方法     */    public UserServiceImpl(UserDao userDao) {        this.userDao = userDao;    }    /**     *2.使用设值注入     *提供默认无参构造方法     *为所有属性提供setter方法     */    public UserServiceImpl() {        }    public void setUserDao(UserDao userDao) {        this.userDao = userDao;    }    //实现了UserService中的方法    @Override    public void addUser() {        userDao.save();        System.out.println(&quot;hello,User Service...&quot;);    } }</code></pre><p>bean.xml文件中使用set方式装配普通成员变量与对象成员变量 </p><pre><code>&lt;!-- 将指定对象配置给spring，让spring创建实例 --&gt;&lt;bean id=&quot;userDao&quot; class=&quot;dao.UserDaoImpl&quot;&gt;     &lt;!-- 通过设值注入装配Bean --&gt;     &lt;property name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;     &lt;!-- 通过构造注入装配Bean --&gt;     &lt;constructor-arg index=&quot;0&quot; value=&quot;jack&quot;&gt;&lt;/constructor-arg&gt;     &lt;constructor-arg index=&quot;1&quot; value=&quot;1234&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;service.UserServiceImpl&quot;&gt;     &lt;!-- 设值注入方式 将userDao实例注入到userService实例中(使用setter方法) 与userDao实例装配Bean方式一样不过这里成员变量是对象 value改为ref --&gt;    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;    &lt;!-- 使用构造方法注入 --&gt;    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><p>测试方法</p><pre><code>@Test public void testUserDao() {     String xmlPath = &quot;beans.xml&quot;;     //初始化spring容器，加载配置文件     ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);     //通过容器获取userDao实例     UserDao userDao = (UserDao)applicationContext.getBean(&quot;userDao&quot;);     userDao.save(); }@Test public void testService() {     String xmlPath=&quot;beans.xml&quot;;     ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath);     UserService userService = (UserServiceImpl)applicationContext.getBean(&quot;userService&quot;);                     userService.addUser(); }</code></pre><h5 id="2-基于注解的装配"><a href="#2-基于注解的装配" class="headerlink" title="2.基于注解的装配"></a>2.基于注解的装配</h5><p>为了防止有过多的Bean导致配置文件繁琐，可使用注解的功能进行Bean的装配，提供3个@Component注解衍生注解（功能一样）<br>@Repository ：Dao层 （数据访问层）<br>@Service：Service层 （业务层）<br>@Controller：Constroller层 （控制层）<br>这三个注解和@Component一样，但能使标注类的本身用途更加清晰。 </p><p>除了上面四个类注解，Spring还提供了@Value取代xml中的普通字段值，提供@Resource取代xml中的字段引用值（实现相同功能的注解还有@Autowired和@Autowired与@Qualifier的配合使用）。</p><p>上面的例子使用注解方式配置如下：</p><p>xml配置 context:component-scan标签</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://www.springframework.org/schema/beans/spring-beans.xsd             http://www.springframework.org/schema/context             http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!-- 使用注解的方式装配Bean --&gt;    &lt;!-- 通知Spring扫描指定包下的所有Bean类，进行注解解析 --&gt;    &lt;context:component-scan base-package=&quot;annotation&quot;/&gt;&lt;/beans&gt;</code></pre><p>UserDaoimpl（数据访问层）类中使用@Repository注解 </p><pre><code>@Repository(&quot;userDao&quot;)public class UserDaoImpl implements UserDao {    @Override    public void save() {        // TODO Auto-generated method stub        System.out.println(&quot;userDao...save...&quot;);    }}</code></pre><p>UserServiceImpl（业务逻辑层）使用@Service注解，有引用字段userDao </p><pre><code>@Service(&quot;userService&quot;)public class UserServiceImpl implements UserService{    @Resource(name=&quot;userDao&quot;)    private UserDao userDao;    public void setUserDao(UserDao userDao) {        this.userDao = userDao;    }    @Override    public void save() {        // TODO Auto-generated method stub        userDao.save();        System.out.println(&quot;userService...save...&quot;);    }}</code></pre><p>UserAction（业务流程控制层）使用@Controller注解，有引用字段userService </p><pre><code>@Controller(&quot;userAction&quot;)public class UserAction {    @Resource(name=&quot;userService&quot;)    private UserService userService;    public void setUserService(UserService userService) {        this.userService = userService;    }    public void save() {        userService.save();        System.out.println(&quot;userAction...save...&quot;);    }}</code></pre><p>测试方法</p><pre><code>    @Test    public void testAnnotation() {        //文件配置路径        String xmlPath=&quot;annotation/beans2.xml&quot;;        //加载配置文件，获得应用上下文实例        ApplicationContext context =                 new ClassPathXmlApplicationContext(xmlPath);        UserAction userAction = (UserAction)context.getBean(&quot;userAction&quot;);        System.out.println(userAction);        userAction.save();    }</code></pre><h5 id="3-自动装配"><a href="#3-自动装配" class="headerlink" title="3.自动装配"></a>3.自动装配</h5><p>需配置bean元素的autowire属性，该属性有五个值：byName、byType、constructor、autodetect、no 。</p><p>可将上例中beans.xml配置文件改成如下（类不需使用注解）： </p><pre><code>    &lt;!-- 使用自动装配方式,类中不需使用注解，装配引用字段直接通过id自动装配 --&gt;    &lt;bean id=&quot;userDao&quot; class=&quot;annotation.UserDaoImpl&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userService&quot; class=&quot;annotation.UserServiceImpl&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;    &lt;bean id=&quot;userAction&quot; class=&quot;annotation.UserAction&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</code></pre><p>输出结果与使用注解一致。 </p><p>这种方式不是很常用，感兴趣的自行了解<a href="https://www.jb51.net/article/106856.htm" target="_blank" rel="noopener">Spring的自动装配Bean的三种方式</a>、<a href="https://www.cnblogs.com/longshiyVip/p/4575563.html" target="_blank" rel="noopener">spring实战二之Bean的自动装配(非注解方式)</a>。</p><p>好了，这就是今天我要说的全部内容，主要对Spring中Bean和依赖注入的实现进行了详细讲解，内容是经过我自己理解及网上资料的总结，如果有什么疑惑或者错误欢迎联系我。</p><p>参考资料：《JavaEE企业级应用开发教程》</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring IoC与Spring容器</title>
      <link href="/2018/08/17/Spring%20IoC%E4%B8%8ESpring%E5%AE%B9%E5%99%A8/"/>
      <url>/2018/08/17/Spring%20IoC%E4%B8%8ESpring%E5%AE%B9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h3 id="一、IoC与DI概念"><a href="#一、IoC与DI概念" class="headerlink" title="一、IoC与DI概念"></a>一、IoC与DI概念</h3><p>控制反转(Inversion of Control ,简称IoC）与依赖注入(Dependency Injection,简称DI)的含义相同，只不过这两个称呼是从两个角度描述的同一概念。对于一个Spring初学者来说，这两个称呼很难理解，下面我们将通过简单语言来描述这两个概念。</p><p>当某个Java对象（调用者）需要调用另一个Java对象（被调用者，即被依赖对象）时，在传统模式下，调用者通常会采用new关键字来创建对象，这种方式会导致调用者与被调用者之间的耦合性增加，不利于后期项目的升级和维护。</p><p>在使用Spring框架之后，对象的实例不再由调用者来创建，而是由Spring容器来创建，Spring容器会负责控制程序之间的关系，而不是由调用者的程序代码直接控制。这样，控制权由应用代码转移到了Spring容器，控制权发生了反转，这就是Spring的控制反转。</p><p>从Spring容器的角度看，Spring容器负责将被依赖对象赋值给调用者的成员变量，这相当于为调用者注入了它依赖的实例，这就是Spring的依赖注入。</p><p><em>提示：以下内容可能对初学者不太友好，可以大概看看，建议有基础后再来看。</em></p><h3 id="二、Spring容器"><a href="#二、Spring容器" class="headerlink" title="二、Spring容器"></a>二、Spring容器</h3><p>Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化 Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。</p><ul><li>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身； </li><li>ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。</li></ul><h5 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1.BeanFactory"></a>1.BeanFactory</h5><p>BeanFactory体系架构： </p><img src="/2018/08/17/Spring%20IoC与Spring容器/beanfactory.jpg"> <p>BeanFactory 接口位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展：</p><ul><li><p>ListableBeanFactory：该接口定义了访问容器中 Bean 基本信息的若干方法，如查看Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法； </p></li><li><p>HierarchicalBeanFactory：父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean。</p></li><li><p>ConfigurableBeanFactory：是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法； </p></li><li><p>AutowireCapableBeanFactory：定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法； </p></li><li><p>SingletonBeanRegistry：定义了允许在运行期间向容器注册单实例 Bean 的方法；</p></li><li><p>BeanDefinitionRegistry： Spring 配置文件中每一个&lt;bean&gt;节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。</p></li></ul><h5 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2.ApplicationContext"></a>2.ApplicationContext</h5><p>ApplicationContext 由 BeanFactory 派生而来，提供了更多面向实际应用的功能。</p><p>在BeanFactory 中，很多功能需要以编程的方式实现，而在 ApplicationContext 中则可以通过配置的方式实现。</p><img src="/2018/08/17/Spring%20IoC与Spring容器/ApplicationContext.jpg"><p>ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能： </p><ul><li>ClassPathXmlApplicationContext：默认从类路径加载配置文件</li><li>FileSystemXmlApplicationContext：默认从文件系统中装载配置文件</li><li>ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。实现了 ApplicationListener 事件监听接口的 Bean 可以接收到容器事件 ， 并对事件进行响应处理 。 在 ApplicationContext 抽象实现类AbstractApplicationContext 中，我们可以发现存在一个 ApplicationEventMulticaster，它负责保存所有监听器，以便在容器产生上下文事件时通知这些事件监听者。 </li><li>MessageSource：为应用提供 i18n 国际化消息访问的功能； </li><li>ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。 </li><li>LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。</li><li>ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要的方法： refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。这些接口方法为容器的控制管理带来了便利，但作为开发者，我们并不需要过多关心这些方法。</li></ul><p>使用：</p><p>如果配置文件放置在类路径下，用户可以优先使用 ClassPathXmlApplicationContext 实现类：</p><pre><code>ApplicationContext ctx = new ClassPathXmlApplicationContext(String configLocation);</code></pre><p>如果配置文件放置在文件系统的路径下，则可以优先考虑使用 FileSystemXmlApplicationContext 实现类：</p><pre><code>ApplicationContext ctx = new FileSystemXmlApplicationContext(String configLocation);</code></pre><p>Spring 3.0 支持基于类注解的配置方式，主要功能来自于 Spring 的一个名为 JavaConfig 子项目，目前 JavaConfig已经升级为 Spring核心框架的一部分。</p><p>ApplicationContext 在初始化应用上下文时就实例化所有单实例的 Bean。</p><h5 id="3-WebApplicationContext"><a href="#3-WebApplicationContext" class="headerlink" title="3.WebApplicationContext"></a>3.WebApplicationContext</h5><p>WebApplication体系架构： </p><img src="/2018/08/17/Spring%20IoC与Spring容器/WebApplicationContext.jpg"><p>WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext 中可以获得 ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext 中，以便 Web 应用环境可以访问 Spring 应用上下文。 WebApplicationContext 定义了一个常量ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE，在上下文启动时， WebApplicationContext 实例即以此为键放置在 ServletContext 的属性列表中，因此我们可以直接通过以下语句从 Web 容器中获取WebApplicationContext： </p><pre><code>WebApplicationContext wac = (WebApplicationContext)servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</code></pre><p>Spring 和 Web 应用的上下文融合：</p><img src="/2018/08/17/Spring%20IoC与Spring容器/web.jpg"><p>WebApplicationContext 的初始化方式：WebApplicationContext 需要 ServletContext 实例，它必须在拥有 Web 容器的前提下才能完成启动的工作。可以在 web.xml 中配置自启动的 Servlet 或定义 Web 容器监听器（ ServletContextListener），借助这两者中的任何一个就可以完成启动 Spring Web 应用上下文的工作。Spring 分别提供了用于启动 WebApplicationContext 的 Servlet 和 Web 容器监听器： </p><ul><li>org.springframework.web.context.ContextLoaderServlet；</li><li>org.springframework.web.context.ContextLoaderListener；</li><li>由于 WebApplicationContext 需要使用日志功能，比如日志框架使用Log4J，用户可以将 Log4J 的配置文件放置到类路径 WEB-INF/classes 下，这时 Log4J 引擎即可顺利启动。如果 Log4J 配置文件放置在其他位置，用户还必须在 web.xml 指定 Log4J 配置文件位置。</li></ul><h3 id="三、Spring容器高层视图"><a href="#三、Spring容器高层视图" class="headerlink" title="三、Spring容器高层视图"></a>三、Spring容器高层视图</h3><p>Spring 启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。 </p><img src="/2018/08/17/Spring%20IoC与Spring容器/Spring.jpg"><p>Bean缓存池：HashMap实现 </p><h3 id="四、容器启动过程"><a href="#四、容器启动过程" class="headerlink" title="四、容器启动过程"></a>四、容器启动过程</h3><p>web环境下Spring容器、SpringMVC容器启动过程：</p><p>首先，对于一个web应用，其部署在web容器中，web容器提供其一个全局的上下文环境，这个上下文就是ServletContext，其为后面的spring IoC容器提供宿主环境；</p><p>其次，在web.xml中会提供有contextLoaderListener（或ContextLoaderServlet）。在web容器启动时，会触发容器初始化事件，此时contextLoaderListener会监听到这个事件，其contextInitialized方法会被调用，在这个方法中，spring会初始化一个启动上下文，这个上下文被称为根上下文，即WebApplicationContext，这是一个接口类，确切的说，其实际的实现类是XmlWebApplicationContext。这个就是spring的IoC容器，其对应的Bean定义的配置由web.xml中的context-param标签指定。在这个IoC容器初始化完毕后，spring容器以WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE为属性Key，将其存储到ServletContext中，便于获取；</p><p>再次，contextLoaderListener监听器初始化完毕后，开始初始化web.xml中配置的Servlet，这个servlet可以配置多个，以最常见的DispatcherServlet为例（Spring MVC），这个servlet实际上是一个标准的前端控制器，用以转发、匹配、处理每个servlet请求。DispatcherServlet上下文在初始化的时候会建立自己的IoC上下文容器，用以持有spring mvc相关的bean，这个servlet自己持有的上下文默认实现类也是XmlWebApplicationContext。在建立DispatcherServlet自己的IoC上下文时，会利用WebApplicationContext.ROOTWEBAPPLICATIONCONTEXTATTRIBUTE先从ServletContext中获取之前的根上下文(即WebApplicationContext)作为自己上下文的parent上下文（即第2步中初始化的XmlWebApplicationContext作为自己的父容器）。有了这个parent上下文之后，再初始化自己持有的上下文（这个DispatcherServlet初始化自己上下文的工作在其initStrategies方法中可以看到，大概的工作就是初始化处理器映射、视图解析等）。初始化完毕后，spring以与servlet的名字相关(此处不是简单的以servlet名为Key，而是通过一些转换)的属性为属性Key，也将其存到ServletContext中，以便后续使用。这样每个servlet就持有自己的上下文，即拥有自己独立的bean空间，同时各个servlet共享相同的bean，即根上下文定义的那些bean。</p><p>好了，关于Spring知识点有点多，这篇理论我知道让人懵懵的，建议和下篇博文一起食用，以上是经过我自己理解及网上资料对Spring控制反转和容器的总结，如果有什么疑惑或者错误欢迎联系我。</p><p>参考资料：《JavaEE企业级应用开发教程》《Spring 3.x企业应用开发实战》 </p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring入门</title>
      <link href="/2018/08/15/Spring%E5%85%A5%E9%97%A8/"/>
      <url>/2018/08/15/Spring%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>如果你看完我分类中JavaEE的所有内容并且能完成两三个Servlet+JSP+JDBC小项目，你可以正式开始后端框架的学习了。<strong>以后路还很长，我们慢慢走吧。</strong>不过首先我想先让你看看这个帖子<a href="https://zhuanlan.zhihu.com/p/34985791" target="_blank" rel="noopener">Spring核心技术原理(1)–为什么要有Spring?</a>，这个帖子详细说明了JavaWeb的发展历程以及为何我们要使用Spring，整理得很好，（其中涉及的设计模式不理解的话可以去我博客里找相关博文）。然后我们就开始吧。</p><h3 id="一、Spring概述"><a href="#一、Spring概述" class="headerlink" title="一、Spring概述"></a>一、Spring概述</h3><h5 id="1-什么是Spring"><a href="#1-什么是Spring" class="headerlink" title="1.什么是Spring"></a>1.什么是Spring</h5><p>Spring是由Rod Johnson组织开发的一个分层的JavaEE轻量级开源框架，它以IoC(Inversion of Control ,控制反转)和AOP(Aspect Oriented Programming ,面向切面编程)为内核，使用基本的JavaBean来完成以前只能由<a href="https://baike.baidu.com/item/EJB" target="_blank" rel="noopener">EJB</a>完成的工作，取代了<a href="https://baike.baidu.com/item/EJB" target="_blank" rel="noopener">EJB</a>臃肿低效的开发模式。</p><p>Spring致力于JavaEE应用各层的解决方案，在表现层它提供了Spring MVC以及与Struts框架的整合功能；在业务逻辑层可以管理事务、记录日志等；在持久层可以整合Mybatis、Hibernate、JdbcTemplate等技术。因此，可以说Spring是企业应用开发很好的“一站式”选择。虽然Spring贯穿于表现层、业务逻辑层和持久层，但它并不想取代那些已有的框架，而是以高度的开放性与它们进行无缝整合。</p><h5 id="2-Spring的特点"><a href="#2-Spring的特点" class="headerlink" title="2.Spring的特点"></a>2.Spring的特点</h5><p>(1)方便解耦，简化开发</p><p>通过Spring提供的IoC容器，我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p><p>(2)AOP编程的支持</p><p>通过Spring提供的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。</p><p>(3)声明式事务的支持</p><p>在Spring中，我们可以从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活地进行事务的管理，提高开发效率和质量。</p><p>(4)方便程序的测试</p><p>可以用非容器依赖的编程方式进行几乎所有的测试工作，在Spring里，测试不再是昂贵的操作，而是随手可做的事情。例如：Spring对Junit4支持，可以通过注解方便的测试Spring程序。</p><p>(5)方便集成各种优秀框架</p><p>Spring不排斥各种优秀的开源框架，相反，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架（如Struts、Hibernate、Mybatis）等的直接支持。</p><p>(6)降低JavaEE API的使用难度</p><p>Spring对很多难用的JavaEE API（如JDBC，JavaMail，远程调用等）提供了一个薄薄的封装层，通过Spring的简易封装，这些JavaEE API的使用难度大为降低。</p><p>(7)Java 源码是经典学习范例</p><p>Spring的源码设计精妙、结构清晰、匠心独运，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。</p><h5 id="3-Spring体系结构"><a href="#3-Spring体系结构" class="headerlink" title="3.Spring体系结构"></a>3.Spring体系结构</h5><img src="/2018/08/15/Spring入门/spring.jpg"><p>从中可以看到Spring Framework差不多有20个模块组成，这些模块分为核心容器，数据访问/集成，Web，AOP（面向方面的编程），Instrumentation，消息传递和测试，如上图所示。</p><p>Core Container模块，包含spring-beans、spring-core、spring-context、spring-expression四个方面。</p><ul><li>spring-core和spring-beans：提供了框架的基础部分，包括反转控制和依赖注入功能。其中Bean Factory是容器核心，本质是“工厂设计模式”的实现，而且无需编程实现“单例设计模式”，单例完全由容器控制，而且提倡面向接口编程，而非面向实现编程；所有应用程序对象及对象间关系由框架管理，从而真正把你从程序逻辑中把维护对象之间的依赖关系提取出来，所有这些依赖关系都由BeanFactory来维护。</li></ul><ul><li>spring-context：<strong>这个模块建立在core和bean模块提供坚实的基础上，集成Beans模块功能并添加资源绑定、数据验证、国际化、Java EE支持、容器生命周期、事件传播等；</strong>核心接口是ApplicationContext。</li></ul><ul><li>spring-expression：提供强大的表达式语言支持，支持访问和修改属性值，方法调用，支持访问及修改数组、容器和索引器，命名变量，支持算数和逻辑运算，支持从Spring 容器获取Bean，它也支持列表投影、选择和一般的列表聚合等。</li></ul><p>AOP and Instrumentation模块，包含spring-aop、spring-instrument两个方面。</p><ul><li>spring-aop：Spring AOP模块提供了符合 <em>AOP Alliance</em>规范的面向方面的编程（aspect-oriented programming）实现，提供比如日志记录、权限控制、性能统计等通用功能和业务逻辑分离的技术，并且能动态的把这些功能添加到需要的代码中；这样各专其职，降低业务逻辑和通用功能的耦合。</li></ul><ul><li>spring-instrument：在特定的应用程序服务器中支持类和类加载器的实现，比如Tomcat。</li></ul><p>Messaging，从Spring  Framework  4开始集成了MessageChannel, MessageHandler等，用于消息传递的基础。</p><p>Data Access/Integration，包括了JDBC、ORM、OXM、JMS和事务管理。</p><p>事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事物管理。</p><ul><li>spring-jdbc：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。</li></ul><ul><li>spring-orm：提供与流行的“对象-关系”映射框架的无缝集成，包括Hibernate、JPA、Ibatiss等。而且可以使用Spring事务管理，无需额外控制事务。</li></ul><ul><li>spring-oxm：提供了一个对Object/XML映射实现，将java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。</li></ul><ul><li>spring-jms：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li></ul><p>Web，包含了spring-web, spring-webmvc, spring-websocket, and spring-webmvc-portlet几个模块。</p><ul><li>spring-web：提供了基础的web功能。例如多文件上传、集成IoC容器、远程过程访问（RMI、Hessian、Burlap）以及Web Service支持，并提供一个RestTemplate类来提供方便的Restful services访问。</li></ul><ul><li>spring-webmvc：提供了一个Spring MVC Web框架和REST Web服务的实现。Spring的MVC框架提供了领域模型代码和Web表单之间分离，并与Spring框架的所有其他功能集成。</li></ul><ul><li>spring-webmvc-portlet：提供了在Portlet环境中使用MVC实现，并且反映了spring-webmvc模块的功能。</li></ul><h3 id="二、入门例子"><a href="#二、入门例子" class="headerlink" title="二、入门例子"></a>二、入门例子</h3><p>(1)导入Spring框架中的相关jar包，这里只导入Spring的Core模块（Core模块是框架的核心类库）下的jar包（使用IoC的基本操作，并不需要导入Spring的所有jar包，只导入<code>spring-beans</code>、<code>spring-core</code>、<code>spring-context</code>、<code>spring-expression</code>这4个jar包），以及 支持日志输出的 commons-logging 和 log4j 的jar包。<br>(2)创建一个普通的Java类，并在该类中创建方法，如下：<br>User.java</p><pre><code>package com.spring;public class User {    public void add() {        System.out.println(&quot;User Add Method.&quot;);    }    @Override    public String toString() {        return &quot;This is a user object.&quot;;    }}</code></pre><p>(3)创建Spring的配置文件，进行Bean的配置<br>Spring的核心配置文件名称和位置不是固定的。但官方件建议将该核心配置文件放在src目录下，且命名为 applicationContext.xml。这里为了方便，将核心配置文件放在src目录下，并命名为 applicationContext.xml，内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.spring.User&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>(4)编写测试类进行测试，通过配置文件创建类对象<br>TestIoC.java</p><pre><code>package com.spring;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestIoc {    @Test    public void runUser() {        //加载Spring配置文件，根据创建对象        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //得到配置创建的对象        User user = (User) context.getBean(&quot;user&quot;);        System.out.println(user);        user.add();    }}</code></pre><p> 以上是个简单应用Spring实例化Bean的入门例子，可以看到在TestIoC中我们创建User类对象并不是通过new实例化，而是Spring容器通过无参构造方法实例化。</p><p>好了，Spring入门就到这里，下篇我会具体说说Spring的IoC，关于Spring的使用我不会讲很细，因为内容真的很多，我只会挑出重点来进行讲解，望理解。</p>]]></content>
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单例模式</title>
      <link href="/2018/08/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/13/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="一、单例模式动机"><a href="#一、单例模式动机" class="headerlink" title="一、单例模式动机"></a>一、单例模式动机</h3><p>对于系统中的某些类来说，只有一个实例很重要， 如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。 </p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。 </p><h3 id="二、单例模式概述"><a href="#二、单例模式概述" class="headerlink" title="二、单例模式概述"></a>二、单例模式概述</h3><p>让我们来用单例模式的思想模拟实现任务管理器，下面是具体代码</p><pre><code>public class TaskManager {    //TaskManager提供的唯一实例    private static TaskManager tm = null;    //私有构造方法使外部类无法使用new关键字创建TaskManager实例    private TaskManager() {        ...    }    //该方法用于给外部类返回TaskManager唯一实例    public static TaskManager getInstance() {        if(tm == null) {            tm = new TaskManager();        }        return tm;    }     //任务管理器功能方法    public void display() {        ...    }} </code></pre><p>为什么getInstance()方法要定义为静态方法？因为外部类需要调用getInstance()方法得到唯一TaskManager实例，而调用非成员方法只有两种方式，通过对象调用或者类调用，对象调用肯定不行（我们调用getInstance()方法目的就是要得到对象，就是缺对象），所以只能通过TaskManager类调用，而类只能调用静态成员方法，所以必须将getInstance()定义为静态。</p><p>上述代码是单例模式的一种典型实现方式，理解之后我们再来看看单例模式的定义：<strong>确保一个类只有一个实例，而且自行实例化并向整个系统提供这个类实例，这个类称为单例类，它提供全局访问的方法。</strong></p><p>单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 </p><h3 id="三、饿汉式单例与懒汉式单例"><a href="#三、饿汉式单例与懒汉式单例" class="headerlink" title="三、饿汉式单例与懒汉式单例"></a>三、饿汉式单例与懒汉式单例</h3><h5 id="1-饿汉式单例类"><a href="#1-饿汉式单例类" class="headerlink" title="1.饿汉式单例类"></a>1.饿汉式单例类</h5><p>饿汉式单例类是实现起来最简单的单例类，在定义静态变量的时候马上实例化，因此类加载时候就已经创建单例对象，代码如下：</p><pre><code>public class EagerSingleton {    //唯一实例    private static EagerSingleton instance = new EagerSingleton();    //私有构造方法    private EagerSingleton(){}    //静态工厂方法    public static EagerSingleton getInstance() {        return instance;    }}</code></pre><p>在这个类被加载时，静态变量instance会被初始化，此时类的私有构造方法会被调用。这时候，单例类的唯一实例就被创建出来了。</p><p>饿汉式是典型的空间换时间，当类装载的时候就会创建类实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断了，节省了运行时间。 </p><h5 id="2-懒汉式单例类"><a href="#2-懒汉式单例类" class="headerlink" title="2.懒汉式单例类"></a>2.懒汉式单例类</h5><p>懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。 </p><pre><code>public class LazySingleton {    //唯一实例    private static LazySingleton instance = null;    //私有构造方法     private LazySingleton(){}    // 静态工厂方法    public static synchronized LazySingleton getInstance() {        if(instance == null){            instance = new LazySingleton();        }        return instance;    }}</code></pre><p>上面的懒汉式单例类实现里对静态工厂方法使用了同步化，以处理多线程环境。 由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。所以对比饿汉式，懒汉式是时间换空间，那么有没有更好的方式实现呢？ </p><h5 id="3-双重检查加锁"><a href="#3-双重检查加锁" class="headerlink" title="3.双重检查加锁"></a>3.双重检查加锁</h5><p>可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。那么什么是“双重检查加锁”机制呢？</p><p>所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance()方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</p><p>“双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</p><pre><code>public class Singleton {    //唯一实例    private volatile static Singleton instance = null;    //私有构造方法    private Singleton(){}    // 静态工厂方法    public static Singleton getInstance(){        //先检查实例是否存在，如果不存在才进入下面的同步块        if(instance == null){            //同步块，线程安全的创建实例            synchronized (Singleton.class) {                //再次检查实例是否存在，如果不存在才真正的创建实例                if(instance == null){                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre><p>这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。 </p><p>提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。 </p><h5 id="4-饿汉式单例类与懒汉式单例类的比较"><a href="#4-饿汉式单例类与懒汉式单例类的比较" class="headerlink" title="4.饿汉式单例类与懒汉式单例类的比较"></a>4.饿汉式单例类与懒汉式单例类的比较</h5><p>饿汉式单例类：无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；系统加载时间可能会比较长(考虑简单，性能略低)。</p><p>懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响(考虑复杂，资源利用效率高)。</p><h3 id="三、更好的实现方式"><a href="#三、更好的实现方式" class="headerlink" title="三、更好的实现方式"></a>三、更好的实现方式</h3><p>根据上面的分析，常见的两种单例实现方式都存在小小的缺陷，那么有没有一种方案，既能实现延迟加载，又能实现线程安全呢？ </p><h5 id="1-Lazy-initialization-holder-class模式"><a href="#1-Lazy-initialization-holder-class模式" class="headerlink" title="1.Lazy initialization holder class模式"></a>1.Lazy initialization holder class模式</h5><p>大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括：</p><p>(1)由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</p><p>(2)访问final字段时</p><p>(3)在创建线程之前创建对象时</p><p>(4)线程可以看见它将要处理的对象时</p><p>要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。</p><p>如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。示例代码如下：</p><pre><code>public class Singleton {    private Singleton(){}    /**     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。     */    private static class SingletonHolder{        // 静态初始化器，由JVM来保证线程安全        private static Singleton instance = new Singleton();    }    public static Singleton getInstance() {        return SingletonHolder.instance;    }}</code></pre><p>当getInstance()方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。</p><p>这个模式的优势在于，getInstance()方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。</p><h5 id="2-单元素枚举单例"><a href="#2-单元素枚举单例" class="headerlink" title="2.单元素枚举单例"></a>2.单元素枚举单例</h5><p>单例的枚举实现在《Effective Java》中有提到，因为其功能完整、使用简洁、无偿地提供了序列化机制、在面对复杂的序列化或者反射攻击时仍然可以绝对防止多次实例化等优点，单元素的枚举类型被作者认为是实现单例模式的最佳方法。 </p><p> 用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。 </p><pre><code>public enum Singleton {    // 定义一个枚举的元素，它就代表了Singleton的一个实例    uniqueInstance;    // 单例可以有自己的操作    public void singletonOperation(){        //功能处理    }}</code></pre><p>使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。 </p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVC模式与三层架构</title>
      <link href="/2018/08/11/MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/08/11/MVC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>很多基础不好的人总是把MVC和三层架构混为一谈，并不了解它们的区别是什么，甚至以为是一种东西，现在我就具体讲讲，也复习一下。</p><h3 id="一、MVC模式"><a href="#一、MVC模式" class="headerlink" title="一、MVC模式"></a>一、MVC模式</h3><h5 id="1-Model1-JSP-JavaBean"><a href="#1-Model1-JSP-JavaBean" class="headerlink" title="1.Model1(JSP + JavaBean)"></a>1.Model1(JSP + JavaBean)</h5><p>之前说了JSP，我们知道在JSP中可以写Java代码，那仔细想想，这JSP不是很棒棒，一方面可以负责界面显示，一方面又可以负责处理业务逻辑和流程控制 。那项目只写JSP和JavaBean不就好了，还有Servlet什么事，实际上在早期的JavaWeb应用中， 开发人员也是这么做的。这就是Model1模型。</p><img src="/2018/08/11/MVC模式与三层架构/model1.png"><p>上面是Model1的流程图，在Model1模型中，是以JSP为中心，它既要做页面显示，又要负责业务逻辑处理和流程控制，对于单一职责的原则来说，这显然不符合，JSP的职责太重，就显得中间部分有些臃肿 。因此Model1不适合开发复杂的大型应用程序。 </p><h5 id="2-Model2-Servlet-JSP-JavaBean"><a href="#2-Model2-Servlet-JSP-JavaBean" class="headerlink" title="2.Model2(Servlet + JSP + JavaBean)"></a>2.Model2(Servlet + JSP + JavaBean)</h5><p>因为Model1的缺点太过明显，在Model1的基础上，Model2对JSP的任务进行分离，将获取参数，流程控制这些和页面显示无关的转到Servlet处理，JSP只做显示即可。</p><img src="/2018/08/11/MVC模式与三层架构/model2.png"><p>在Model2中，JSP只负责界面显示，Servlet负责应用的处理过程控制 ，JavaBean负责对数据库操作的类。但是相对于Model1，Model2对程序员的要求要高，各部分之间分工明确，各司其职。结果是开发的粒度较细，代码的复用性提高了，后期维护也容易了，所以Model2比较适合大型项目的开发。 </p><h5 id="3-MVC模式是什么"><a href="#3-MVC模式是什么" class="headerlink" title="3.MVC模式是什么"></a>3.MVC模式是什么</h5><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。最典型的MVC就是上面说的Model2模型，其实究起来，Model1也实现了MVC模式，只不过view和controller两个角色都由JSP来扮演，实现得并不彻底。</p><p>model:常用JavaBean去实现，通过各种类来对数据库的数据进行获取，并封装在对象当中。</p><p>view:常用JSP来实现，通过可直接观察的JSP页面来展示我们从数据库中获取的数据。</p><p>controller:常用Servlet来实现，用来接收用户提交的请求，然后获取请求中的数据，将之转换为业务模型需要的数据模型，然后调用业务模型相应的业务方法进行更新，同时根据业务执行结果来选择要返回的视图。</p><h3 id="二、三层架构"><a href="#二、三层架构" class="headerlink" title="二、三层架构"></a>二、三层架构</h3><h5 id="1-三层架构是什么"><a href="#1-三层架构是什么" class="headerlink" title="1.三层架构是什么"></a>1.三层架构是什么</h5><p>通常意义上的三层架构就是将整个业务应用划分为：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。区分层次的目的即为了“高内聚低耦合”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层、表现层，如图所示</p><img src="/2018/08/11/MVC模式与三层架构/三层架构.jpg"><h5 id="2-各层次的任务"><a href="#2-各层次的任务" class="headerlink" title="2.各层次的任务"></a>2.各层次的任务</h5><p>表现层（UI）：表现层可以说是距离用户最近的层，主要是用于接收用户输入的数据和显示处理后用户需要的数据。一般表现为界面，用户通过界面输入查询数据和得到需要的数据。</p><p>业务逻辑层（BLL）：业务逻辑层是处于表现层和数据访问层之间，主要是从数据库中得到数据然后对数据进行逻辑处理。</p><p>数据访问层（DAL）：数据访问层是直接和数据库打交道的，对数据进行“增、删、改、查”等基本的操作。</p><h5 id="3-与MVC模式的区别与联系"><a href="#3-与MVC模式的区别与联系" class="headerlink" title="3.与MVC模式的区别与联系"></a>3.与MVC模式的区别与联系</h5><p>(1)区别：首先，它们根本不是一个概念。三层架构是一个分层式的软件体系架构设计，它可适用于任何一个项目。MVC是一个架构模式，可以用它来创建在域对象和UI表示层对象之间的区分。在三层架构中没有定义Controller的概念，这是最不同的地方 。</p><p>(2)联系：网上谈到三层架构与MVC模式的联系时，主要有两种说法，我看了他们的观点，发现主要区别在于对MVC模式中model的功能的理解。</p><p>一种观点认为三层架构中每一层都有不同的架构模式，表示层最常用的架构模式就是MVC，而MVC中的model只是一些简单实体类。下面是基于这种观点的一个常见的J2EE项目结构（我一般也是这种结构）</p><ul><li>users.jsp (V)</li><li>UserController.java (C)</li><li>UserService.java (业务逻辑层)</li><li>UserDao.java (数据访问层)</li><li>User.java (M)</li></ul><p>另一种观点认为MVC模式内的view和controller组成了三层架构的表现层，而model的功能分业务逻辑层和数据访问层来实现，这时的model就不能只是简单实体类了，还必须包括逻辑处理类和数据访问类，如下图所示<br><img src="/2018/08/11/MVC模式与三层架构/mvc与三层架构.jpg"></p><p>发现没，刚刚提到的Model2模型就是基于这个观点。</p><p>具体哪种正确我认为没有绝对的答案，两种观点我都理解，具体情况具体分析，况且实际开发中对这些理念也没纠结那么多，代码敲出来就完事了！以上是经过我自己理解及网上资料对MVC模式和三层架构的总结，如果有什么疑惑或者错误欢迎联系我。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVC模式 </tag>
            
            <tag> 三层架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSP总结</title>
      <link href="/2018/08/08/JSP%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/08/JSP%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>感觉自己三分钟热度要过去了，不想更博想偷懒了，以后不知道能不能做到一周二更，果然做个快乐肥宅太舒服了。。。废话不说，今天讲JSP，下面就开始吧。</p><h3 id="一、什么是JSP"><a href="#一、什么是JSP" class="headerlink" title="一、什么是JSP"></a>一、什么是JSP</h3><p>掌握了编写Servlet程序后，我们有能力让网页“动”起来——根据不同的输入（URL参数、Session等）生成不同的页面内容。但由于Web中大量用到HTML作为展示语言，在Servlet中去拼接HTML代码显然不是一个好办法。Java EE里制定的JSP标准，就是帮助开发者基于HTML/XML来动态生成Web页面内容。 </p><p>JSP全名为Java Server Pages，中文名叫Java服务器页面，其根本是一个简化的Servlet设计，它是由Sun提出的一种动态网页技术标准。在传统的网页HTML（标准通用标记语言的子集）文件中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件。  </p><p>本质上来说，JSP是Servlet的一个更高层的抽象。<strong>Servlet容器会将JSP在运行时转化为Servlet程序</strong>，接下来的处理流程就和Servlet完全一样了。</p><p>下面是一个最简单的一段jsp代码： </p><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;%&gt;&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;&gt;&lt;html&gt;  &lt;head&gt;    &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;    &lt;title&gt;First Jsp&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;%        out.print(&quot;Hello Jsp&quot;);    %&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p> 对应的，Servlet容器将上面的JSP转化为Servlet如下：</p><pre><code>package org.apache.jsp;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;import java.util.*;public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase    implements org.apache.jasper.runtime.JspSourceDependent {  private static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();  private static java.util.List _jspx_dependants;  private javax.el.ExpressionFactory _el_expressionfactory;  private org.apache.AnnotationProcessor _jsp_annotationprocessor;  public Object getDependants() {    return _jspx_dependants;  }  public void _jspInit() {    _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();    _jsp_annotationprocessor = (org.apache.AnnotationProcessor) getServletConfig().getServletContext().getAttribute(org.apache.AnnotationProcessor.class.getName());  }  public void _jspDestroy() {  }  public void _jspService(HttpServletRequest request, HttpServletResponse response)        throws java.io.IOException, ServletException {    PageContext pageContext = null;    HttpSession session = null;    ServletContext application = null;    ServletConfig config = null;    JspWriter out = null;    Object page = this;    JspWriter _jspx_out = null;    PageContext _jspx_page_context = null;    try {      response.setContentType(&quot;text/html;charset=UTF-8&quot;);      pageContext = _jspxFactory.getPageContext(this, request, response,                  null, true, 8192, true);      _jspx_page_context = pageContext;      application = pageContext.getServletContext();      config = pageContext.getServletConfig();      session = pageContext.getSession();      out = pageContext.getOut();      _jspx_out = out;      out.write(&#39;\r&#39;);      out.write(&#39;\n&#39;);String path = request.getContextPath();String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;/&quot;;      out.write(&quot;\r\n&quot;);      out.write(&quot;\r\n&quot;);      out.write(&quot;&lt;!DOCTYPE HTML PUBLIC \&quot;-//W3C//DTD HTML 4.01 Transitional//EN\&quot;&gt;\r\n&quot;);      out.write(&quot;&lt;html&gt;\r\n&quot;);      out.write(&quot;  &lt;head&gt;\r\n&quot;);      out.write(&quot;    &lt;base href=\&quot;&quot;);      out.print(basePath);      out.write(&quot;\&quot;&gt;\r\n&quot;);      out.write(&quot;    \r\n&quot;);      out.write(&quot;    &lt;title&gt;First Jsp&lt;/title&gt;\r\n&quot;);      out.write(&quot;\t\r\n&quot;);      out.write(&quot;  &lt;/head&gt;\r\n&quot;);      out.write(&quot;  \r\n&quot;);      out.write(&quot;  &lt;body&gt;\r\n&quot;);      out.write(&quot;    &quot;);        out.print(&quot;Hello Jsp&quot;);      out.write(&quot;\r\n&quot;);      out.write(&quot;  &lt;/body&gt;\r\n&quot;);      out.write(&quot;&lt;/html&gt;\r\n&quot;);    } catch (Throwable t) {      if (!(t instanceof SkipPageException)){        out = _jspx_out;        if (out != null &amp;&amp; out.getBufferSize() != 0)          try { out.clearBuffer(); } catch (java.io.IOException e) {}        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);      }    } finally {      _jspxFactory.releasePageContext(_jspx_page_context);    }  }}</code></pre><h3 id="二、JSP运行原理"><a href="#二、JSP运行原理" class="headerlink" title="二、JSP运行原理"></a>二、JSP运行原理</h3><p>当客户端浏览器向服务器发出访问一个JSP页面的请求时，服务器根据该请求加载相应的JSP页面，并对该页面进行编译，然后执行。JSP页面的执行过程如下图所示：</p><img src="/2018/08/08/JSP总结/JSP1.png"><p>1.当用户访问一个JSP页面时，会向一个Servlet容器（Tomcat等）发出请求。</p><p>2.服务器根据接收到的客户端的请求来加载相应的JSP文件。</p><p>3.Web服务器中的JSP引擎会将被加载的JSP文件转化为Servlet(.java文件)。</p><p>4.JSP引擎将生成的Servlet代码编译成.class文件。</p><p>5.服务器执行这个.class文件， 将执行结果发送给浏览器进行显示。 </p><p>并不是每次请求都需要重复进行这样的处理。当服务器第一次接收到对某个页面的请求时，JSP引擎就开始按照上述的处理过程来将被请求的JSP文件编译成.class文件。当再次对该页面进行请求时，如果该页面没有任何改动，服务器就会直接调用对应的.class文件来执行，因此当某个JSP页面第一次被请求时，会有一些延迟，而再次访问时会感觉速度快了很多。如果被请求的页面经过了修改，那么服务器会重新编译这个文件，然后再执行。 </p><h3 id="三、JSP基础语法"><a href="#三、JSP基础语法" class="headerlink" title="三、JSP基础语法"></a>三、JSP基础语法</h3><h5 id="1-JSP表达式"><a href="#1-JSP表达式" class="headerlink" title="1.JSP表达式"></a>1.JSP表达式</h5><p>JSP表达式用于向页面中输出信息，其语法格式如下：</p><p><code>&lt;%= expression %&gt;</code></p><p>参数说明：</p><p>expression：可以是任何Java语言的完整表达式，该表达式的最终运算结果将被转换为字符串。</p><p>需要注意 : </p><p>(1)JSP 的表达式中没有分号 !</p><p>(2)”%=” 间不能有空格</p><p>程序示例： </p><pre><code>&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;   今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; </code></pre><h5 id="2-JSP脚本片断"><a href="#2-JSP脚本片断" class="headerlink" title="2.JSP脚本片断"></a>2.JSP脚本片断</h5><p>JSP脚本片断(scriptlet)用于在JSP页面中编写多行Java代码，其语法格式如下：</p><pre><code>&lt;%         　　　    多行java代码  　　　%&gt;</code></pre><p>需要注意 : </p><p>(1)在&lt;% %&gt;中可以定义变量，编写语句，不能定义方法。</p><p>(2)JSP脚本片断中只能出现java代码，不能出现其它模板元素，JSP引擎在翻译JSP页面中，会将JSP脚本片断中的Java代码将被原封不动地放到Servlet的_jspService方法中。</p><p>(3)在一个JSP页面中可以有多个脚本片断，在两个或多个脚本片断之间可以嵌入文本、HTML标记和其他JSP元素。</p><p>(4)JSP脚本片断中的Java代码必须严格遵循Java语法，例如，每执行语句后面必须用分号结束。</p><p>程序示例：</p><pre><code>&lt;%    int sum=0;     for(int i=1;i&lt;=100;i++) {        sum+=i;    }    out.println(&quot;&lt;h1&gt;Sum=&quot;+sum+&quot;&lt;/h1&gt;&quot;);%&gt;</code></pre><h5 id="3-JSP声明"><a href="#3-JSP声明" class="headerlink" title="3.JSP声明"></a>3.JSP声明</h5><p>JSP页面中编写的所有代码，默认会翻译到Servlet的service方法中， 而JSP声明中的Java代码被翻译到_jspService方法的外面，其语法格式如下：</p><pre><code>&lt;% !        　　　    Java代码  　　　%&gt;</code></pre><p>需要注意 : </p><p>(1)声明以 “&lt;%!” 开头 , 以 “%&gt;” 结尾 , “%!” 必须紧挨。</p><p>(2)多个静态代码块，变量和函数可以定义在一个JSP声明中，也可以分别单独定义在多个JSP声明中。JSP隐式对象的作用范围仅限于Servlet的_jspService方法，所以在JSP声明中不能使用这些隐式对象。</p><p>程序示例：</p><pre><code>&lt;%! int i = 0; %&gt; &lt;%! int a, b, c; %&gt; &lt;%! Circle a = new Circle(2.0); %&gt;</code></pre><h5 id="4-JSP注释"><a href="#4-JSP注释" class="headerlink" title="4.JSP注释"></a>4.JSP注释</h5><p>JSP 程序的注释有隐藏注释、HTML 注释、Java 语言注释</p><p>(1)隐藏注释是 JSP 的标准注释 , 在编写 JSP 程序中 , 在发布网页时完全被忽略, 不发送至客户端。</p><p>语法格式如下 :</p><p><code>&lt;%-- comment --%&gt;</code> </p><p>comment 为被注释内容</p><p>(2)HTML 注释在发布网页时可以在浏览器文件窗口中看到 HTML 注释 , 在这种注释中 , 也可以使用 JSP 的表达式。</p><p>语法格式如下 :</p><p><code>&lt;!-- comment [&lt;%=expression%&gt;]--&gt;</code>　　</p><p>comment 为被注释内容</p><p>(3)Java 注释和隐藏注释相似 , 在浏览器的源文件窗口中也看不到注释内容。</p><p>语法格式如下:</p><p><code>&lt;%// 单行注释 %&gt;</code></p><p><code>&lt;%/* 多行注释 */%&gt;</code></p><h5 id="5-JSP指令"><a href="#5-JSP指令" class="headerlink" title="5.JSP指令"></a>5.JSP指令</h5><p>JSP指令用来设置与整个JSP页面相关的属性。</p><p>JSP指令语法格式：</p><p><code>&lt;%@ directive attribute=&quot;value&quot; %&gt;</code></p><p>这里有三种指令标签：</p><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>&lt;%@ page … %&gt;</td><td>定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等</td></tr><tr><td>&lt;%@ include … %&gt;</td><td>包含其他文件</td></tr><tr><td>&lt;%@ taglib … %&gt;</td><td>引入标签库的定义，可以是自定义标签</td></tr></tbody></table><h5 id="6-JSP行为"><a href="#6-JSP行为" class="headerlink" title="6.JSP行为"></a>6.JSP行为</h5><p>JSP行为标签使用XML语法结构来控制Servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。</p><p>行为标签只有一种语法格式，它严格遵守XML标准：</p><p><code>&lt;jsp:action_name attribute=&quot;value&quot; /&gt;</code></p><p>行为标签基本上是一些预先就定义好的函数，下表罗列出了一些可用的JSP行为标签：</p><table><thead><tr><th><strong>语法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>jsp:include</td><td>用于在当前页面中包含静态或动态资源</td></tr><tr><td>jsp:useBean</td><td>寻找和初始化一个JavaBean组件</td></tr><tr><td>jsp:setProperty</td><td>设置 JavaBean组件的值</td></tr><tr><td>jsp:getProperty</td><td>将 JavaBean组件的值插入到 output中</td></tr><tr><td>jsp:forward</td><td>从一个JSP文件向另一个文件传递一个包含用户请求的request对象</td></tr><tr><td>jsp:plugin</td><td>用于在生成的HTML页面中包含Applet和JavaBean对象</td></tr><tr><td>jsp:element</td><td>动态创建一个XML元素</td></tr><tr><td>jsp:attribute</td><td>定义动态创建的XML元素的属性</td></tr><tr><td>jsp:body</td><td>定义动态创建的XML元素的主体</td></tr><tr><td>jsp:text</td><td>用于封装模板数据</td></tr></tbody></table><h5 id="7-JSP隐含对象"><a href="#7-JSP隐含对象" class="headerlink" title="7.JSP隐含对象"></a>7.JSP隐含对象</h5><p>JSP支持九个自动定义的变量，江湖人称隐含对象。这九个隐含对象的简介见下表：</p><table><thead><tr><th><strong>对象</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>request</td><td><strong>HttpServletRequest</strong>类的实例</td></tr><tr><td>response</td><td><strong>HttpServletResponse</strong>类的实例</td></tr><tr><td>out</td><td><strong>PrintWriter</strong>类的实例，用于把结果输出至网页上</td></tr><tr><td>session</td><td><strong>HttpSession</strong>类的实例</td></tr><tr><td>application</td><td><strong>ServletContext</strong>类的实例，与应用上下文有关</td></tr><tr><td>config</td><td><strong>ServletConfig</strong>类的实例</td></tr><tr><td>pageContext</td><td><strong>PageContext</strong>类的实例，提供对JSP页面所有对象以及命名空间的访问</td></tr><tr><td>page</td><td>类似于Java类中的this关键字</td></tr><tr><td>Exception</td><td><strong>Exception</strong>类的对象，代表发生错误的JSP页面中对应的异常对象</td></tr></tbody></table><p>好了，JSP的内容有点多，我就先介绍到这里了，理论知识很多，记不住就多敲多看，有兴趣的可以再去网上看看EL表达式和自定义标签，但是我不建议花太多时间。以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p><p>参考文章：<a href="http://www.runoob.com/jsp/jsp-syntax.html" target="_blank" rel="noopener">菜鸟教程–JSP语法</a></p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java会话管理：Cookie和Session</title>
      <link href="/2018/08/07/Java%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9ACookie%E5%92%8CSession/"/>
      <url>/2018/08/07/Java%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9ACookie%E5%92%8CSession/</url>
      <content type="html"><![CDATA[<p>http是<strong>无状态</strong>的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。 </p><p>具体解释一下这个“无状态”：</p><ol><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li><p>人生若只如初见</p><p>这有个具体的生活例子说明了无状态http的不便性：</p></li></ol><p>当我们在一个购物网站上登陆自己的帐号后，我们便开始浏览商品，这时我们发现了心仪的商品，点进去打算看商品详情，发现竟然又要我们登陆帐号，为什么？因为无状态http请求无法保存我们用户信息，点击商品是一个请求，刚刚进入网站主页也是一个请求，这两个请求没有上下文联系，服务器无法判断这是同一个用户的请求，所以我们不得不再输入我们的账号密码，点击添加购物车，这也是一个请求，我们还是得输入帐号密码，还有其它商品操作，还有结算按钮。。。</p><p>没有会话管理技术会给我们生活带来多大不便从上个例子就可以略知一二，Java中我们有Cookie和Session来帮助我们解决这个麻烦。</p><h3 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h3><h5 id="1-什么是Cookie"><a href="#1-什么是Cookie" class="headerlink" title="1.什么是Cookie"></a>1.什么是Cookie</h5><p>“Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从： [系统盘]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。 ”这是百度百科上关于Cookie的解释，说得很明了也很详细，下图是利用Cookie与服务器交流的简图：</p><img src="/2018/08/07/Java会话管理：Cookie和Session/Cookie.png"><h5 id="2-Cookie的使用"><a href="#2-Cookie的使用" class="headerlink" title="2.Cookie的使用"></a>2.Cookie的使用</h5><p>如何使用Cookie？Java API关于Cookie提供了很多方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Cookie(String name, String value)</td><td>实例化<code>Cookie</code>对象，传入<code>Cookie</code>名称和<code>Cookie</code>的值</td></tr><tr><td>public String getName()</td><td>取得<code>Cookie</code>的名字</td></tr><tr><td>public String getValue()</td><td>取得<code>Cookie</code>的值</td></tr><tr><td>public void setValue(String newValue)</td><td>设置<code>Cookie</code>的值</td></tr><tr><td>public void setMaxAge(int expiry)</td><td>设置<code>Cookie</code>的最大保存时间，即<code>Cookie</code>的有效期</td></tr><tr><td>public int getMaxAge()</td><td>获取<code>Cookie</code>的有效期</td></tr><tr><td>public void setPath(String uri)</td><td>设置<code>Cookie</code>的有效路径</td></tr><tr><td>public String getPath()</td><td>获取<code>Cookie</code>的有效路径</td></tr><tr><td>public void setDomain(String pattern)</td><td>设置<code>Cookie</code>的有效域</td></tr><tr><td>public String getDomain()</td><td>获取<code>Cookie</code>的有效域</td></tr></tbody></table><p>已下是Cookie使用的一个例子，记录用户访问网站信息</p><pre><code>public class CookieServlet extends HttpServlet {    public void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        //设置服务器端以UTF-8编码进行输出        response.setCharacterEncoding(&quot;UTF-8&quot;);        //设置浏览器以UTF-8编码进行接收,解决中文乱码问题        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter out = response.getWriter();        //获取浏览器访问访问服务器时传递过来的cookie数组        Cookie[] cookies = request.getCookies();        //如果用户是第一次访问，那么得到的cookies将是null        if (cookies!=null) {            out.write(&quot;您上次访问的时间是：&quot;);            for (int i = 0; i &lt; cookies.length; i++) {                Cookie cookie = cookies[i];                if (cookie.getName().equals(&quot;lastAccessTime&quot;)) {                    Long lastAccessTime =Long.parseLong(cookie.getValue());                    Date date = new Date(lastAccessTime);                    out.write(date.toLocaleString());                }            }        }else {            out.write(&quot;这是您第一次访问本站！&quot;);        }        //用户访问过之后重新设置用户的访问时间，存储到cookie中，然后发送到客户端浏览器        Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis()+&quot;&quot;);//创建一个cookie，cookie的名字是lastAccessTime        //将cookie对象添加到response对象中，这样服务器在输出response对象中的内容时就会把cookie也输出到客户端浏览器        response.addCookie(cookie);    }    public void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doGet(request, response);    }}</code></pre><h5 id="3-Cookie的安全性"><a href="#3-Cookie的安全性" class="headerlink" title="3.Cookie的安全性"></a>3.Cookie的安全性</h5><p>Cookie的目的是为用户带来方便，为网站带来增值，一般情况下不会造成严重的安全威胁。Cookie文件不能作为代码执行，也不会传送病毒，它为用户所专有并只能由创建它的服务器来读取。另外，浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为3KB，因此，Cookie不会塞满硬盘，更不会被用作”拒绝服务”攻击手段。</p><p>但是，Cookie作为用户身份的替代，其安全性有时决定了整个系统的安全性，Cookie的安全性问题不容忽视。</p><p>(1)Cookie欺骗</p><p>Cookie记录了用户的帐户ID、密码之类的信息，通常使用MD5方法加密后在网上传递。经过加密处理后的信息即使被网络上一些别有用心的人截获也看不懂。然而，现在存在的问题是，截获Cookie的人不需要知道这些字符串的含义，只要把别人的Cookie向服务器提交，并且能够通过验证，就可以冒充受害人的身份登陆网站，这种行为叫做Cookie欺骗。<br>非法用户通过Cookie欺骗获得相应的加密密钥，从而访问合法用户的所有个性化信息，包括用户的E-mail甚至帐户信息，对个人信息造成严重危害。<br>(2)Cookie截获<br>Cookie以纯文本的形式在浏览器和服务器之间传送，很容易被他人非法截获和利用。任何可以截获Web通信的人都可以读取Cookie。<br>Cookie被非法用户截获后，然后在其有效期内重放，则此非法用户将享有合法用户的权益。例如，对于在线阅读，非法用户可以不支付费用即可享受在线阅读电子杂志。</p><h3 id="二、Session"><a href="#二、Session" class="headerlink" title="二、Session"></a>二、Session</h3><h5 id="1-什么是Session"><a href="#1-什么是Session" class="headerlink" title="1.什么是Session"></a>1.什么是Session</h5><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个Session的时候，服务器首先检查这个客户端的请求里是否已包含了一个Session标识，称为SessionId，如果已包含一个SessionId则说明以前已经为此客户端创建过Session，服务器就按照SessionId把这个Session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含SessionId，则为此客户端创建一个Session并且生成一个与此Session相关联的SessionId，SessionId的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个SessionId将被在本次响应中返回给客户端保存。 保存这个SessionId的方式可以采用Cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。 </p><h5 id="2-Session的使用"><a href="#2-Session的使用" class="headerlink" title="2.Session的使用"></a>2.Session的使用</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String getId()</td><td>获取<code>SessionID</code>值</td></tr><tr><td>public void setAttribute()</td><td>设置属性</td></tr><tr><td>public Object getAttribute()</td><td>获取属性</td></tr><tr><td>public void removeAttribute()</td><td>移除属性</td></tr><tr><td>public []String getAllAttributeNames()</td><td>获取所有的属性名</td></tr><tr><td>public int getMaxInactiveInterval()</td><td>获取最长到期时间</td></tr><tr><td>public void setMaxInactiveInterval()</td><td>设置最长到期事件</td></tr><tr><td>public void  invalidate()</td><td>使该<code>Session</code>对象失效</td></tr><tr><td>public long getCreationTime()</td><td>获取创建时间</td></tr><tr><td>public long getLastAccessedTime()</td><td>获取上次访问时间</td></tr></tbody></table><p>已下是Session使用的一个例子</p><pre><code>//使用Session保存数据public class Demo01 extends HttpServlet {        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            response.setContentType(&quot;text/html;charset=UTF-8&quot;);            request.setCharacterEncoding(&quot;UTF-8&quot;);            // 获取参数            String username = request.getParameter(&quot;username&quot;);            // 获取session对象            HttpSession session = request.getSession();            // 保存数据            session.setAttribute(&quot;username&quot;, username);            // 打印SessionID            System.out.println(session.getId());        }        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            doGet(request, response);        }}//测试获取Session域中的数据public class Demo02 extends HttpServlet {        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            response.setContentType(&quot;text/html;charset=UTF-8&quot;);            request.setCharacterEncoding(&quot;UTF-8&quot;);            HttpSession session = request.getSession();            String username = (String)session.getAttribute(&quot;username&quot;);            // 响应到网页上            response.getWriter().write(username + &quot; &quot; + session.getId());        }        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            doGet(request, response);        }}</code></pre><h3 id="三、Cookie和Session的区别"><a href="#三、Cookie和Session的区别" class="headerlink" title="三、Cookie和Session的区别"></a>三、Cookie和Session的区别</h3><p>1.Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie是把用户的数据写在用户本地浏览器上, 其他网站也可以扫描使用你的Cookie，容易泄露自己网站用户的隐私，而且一般浏览器对单个网站站点有Cookie数量与大小的限制，Cookie也是实现Session的一种方式。 </p><p>2.Session 的运行依赖SessionId，而SessionId 是存在Cookie中的，也就是说，如果浏览器禁用了Cookie ，同时 Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 SessionId） 。</p><p>3.一般情况，登录信息等重要信息存储在Session中，其他信息存储在Cookie中 。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂方法模式&amp;抽象工厂模式</title>
      <link href="/2018/08/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F&amp;%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F&amp;%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>先介绍工厂方法模式和抽象工厂模式，这是23种设计模式的其中两种。不过在此之前我想先说说简单工厂模式，它不属于23种设计模式，却是今天要说的两种设计模式的入门。</p><h3 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h3><p>我们刚开始写代码的时候，如果需要一个类的对象，我们习惯利用关键字new把它直接创建出来，其实这并不是一个好习惯，因为这样不得已把对象的创建和使用绑定在一起，造成对象类和客户端代码非常高的耦合度，这无疑是我们不想看到的结果，那应该怎么办？简单工厂模式在一定程度上能解决这个问题。</p><p>简单工厂模式是<strong>由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。 </p><p>上面是定义，现在看不懂没关系，下面我来举例。市面上手机有各种各样的品牌，华为，小米，oppo等，不同场景下我们需要的手机品牌不同，那我们要怎么定义这个手机类？有些人可能觉得直接根据品牌定义类就好，华为一个类小米一个类这样，但仔细思考后会发现这样并不可取，因为手机品牌虽然不同，但很多功能都是类似的，重复的代码尽量不要写，这也是我们编码的原则之一，比较好的方法是定义一个抽象的手机类，如下</p><pre><code>abstract class Phone {    //所有手机都有的功能，这里我举打电话这个例子    public void call() {        //具体实现省略    }    //不同品牌手机不同的功能    public abstract void method();}</code></pre><p>然后在根据具体手机品牌定义各自的类</p><pre><code>//华为class HUAWEI extends Phone {    public void method() {    //具体实现    }}//小米class XiaoMi extends Phone {    public void method() {    //具体实现    }}...</code></pre><p>这样定义结束后，如果我们需要使用不同品牌的手机对象，根据简单工厂模式我们还需要定义一个工厂类</p><pre><code>class Factory {    //静态工厂方法，返回不同手机品牌对象    public static Phone getPhone(String type) {        Phone phone = null;        if(type.equals(&quot;HUAWEI&quot;)) {            phone = new HUAWEI();        } else if(type.equals(&quot;XiaoMi&quot;)) {            phone = new XiaoMi();        } else {            //...        }        return phone;    }}</code></pre><p>有了这个工厂类我们创建对象就方便了，以下是客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        Phone myPhone1 = Factory.getPhone(&quot;XiaoMi&quot;);        Phone myPhone2 = Factory.getPhone(&quot;HUAWEI&quot;);    }}</code></pre><p>这就是简单工厂模式的常用场景，你发现没，利用简单工厂模式我们很自然地将对象的创建与使用分开（创建交给工厂类，使用在客户端代码中），看完这个例子再看它的定义，会清楚很多，如果你理解了，那恭喜你可以继续学习工厂方法模式了，如果还是不懂的话不建议继续往下看，请多看相关的其他文章。</p><h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p>简单工厂模式固然简单，但是也有问题，如果我们需要一个手机品牌（例如三星），而工厂类中没有相应的创建代码怎么办？我们就不得不修改我们的工厂类，但是这样就违背了我们的开闭原则，如何在新增手机品牌的情况下而不修改源代码？这时候工厂方法模式就出现了。</p><p>工厂方法模式在简单工厂模式上做出了改进，意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 </p><p>按照上面说的我们只要将Factory类做些改动，把它变成一个接口</p><pre><code>interface Factory {    public Phone getPhone();}</code></pre><p>然后根据不同手机品牌编写对应的品牌工厂类</p><pre><code>//小米class XiaoMiFactory implements Factory {    public Phone getPhone() {        return new XiaoMi();    }}//三星class SAMSUNGFactory implements Factory {    public Phone getPhone() {        return new SAMSUNG();    }}...</code></pre><p>把工厂类改写成接口，将实际创建工作推迟到子类当中，这样我们需要什么手机品牌的对象，写个品牌工厂实现工厂类接口就行了，不就解决了新手机品牌的问题。不得不说早期提出设计模式的大牛们是多厉害，仰望一下。好了，下面是使用工厂方法模式后的客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        Factory factory = null;        factory = new SAMSUNGFactory();        Phone myPhone = factory.getPhone();    }}</code></pre><h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p>接着我们上面的例子，手机有各式的品牌，然而每个手机品牌也不止只生产手机，比如小米还有充电宝，空气净化器等等，如果都为它们创建工厂类可能会导致系统中存在大量工厂类，这样势必会产生系统开销，此时我们的抽象工厂模式运营而生。</p><h5 id="1-产品等级结构与产品族"><a href="#1-产品等级结构与产品族" class="headerlink" title="1.产品等级结构与产品族"></a>1.产品等级结构与产品族</h5><p>要理解抽象工厂模式，我们就要先来学习一下产品等级结构与产品族是什么。</p><img src="/2018/08/05/工厂方法模式&抽象工厂模式/抽象工厂模式-产品族与产品等级.jpg"><p>上图是产品族与产品等级结构示意图，产品等级结构是产品的继承结构，如我们的抽象类Phone，其子类有XiaoMi，HUAWEI，SAMSUNG，则Phone与XiaoMi,HUAWEI,SAMSUNG之间构成了一个产品等级结构。产品族是指由同一个工厂生产的，位于不同产品等级结构的同一组产品，如小米的手机，充电宝，空气净化器，它们各自属于不同的产品等级结构，因此它们属于一个产品族，即小米。</p><h5 id="2-抽象工厂模式举例"><a href="#2-抽象工厂模式举例" class="headerlink" title="2.抽象工厂模式举例"></a>2.抽象工厂模式举例</h5><p>如果利用工厂方法模式为小米华为的手机，充电宝和空气净化器都创建对象，一共需要6个工厂类，而抽象工厂模式简单许多，我们先为产品族新建一个抽象类（接口也行）</p><pre><code>abstract class AbstractFactory {    //为一个产品族创建不同产品等级结构的方法    public abstract Phone getPhone();    public abstract PowerBank getPowerBank();    public abstract AirPurifier getAirPurifier();}</code></pre><p>对于每个品牌，其代码如下</p><pre><code>//小米class XiaoMiFactory extends AbstractFactory {    public abstract Phone getPhone() {        return new XiaoMi();    }    public abstract PowerBank getPowerBank() {        return new XiaoMiPowerBank();    }    public abstract AirPurifier getAirPurifier() {        return new XiaoMiAirPurifier();    }}//华为class HUAWEIFactory extends AbstractFactory {    public abstract Phone getPhone() {        return new HUAWEI();    }    public abstract PowerBank getPowerBank() {        return new HUAWEIPowerBank();    }    public abstract AirPurifier getAirPurifier() {        return new HUAWEIAirPurifier();    }}</code></pre><p>做到这样就可以了，两个产品族我们只要两个具体工厂类，一个抽象工厂类，是不是比工厂方法模式简单？下面是客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        AbstractFactory factory = null;        factory = new XiaoMiFactory();        Phone myPhone = factory.getPhone();        PowerBank myPower = factory.getPowerBank();    }}</code></pre><h5 id="3-与工厂方法模式的对比"><a href="#3-与工厂方法模式的对比" class="headerlink" title="3.与工厂方法模式的对比"></a>3.与工厂方法模式的对比</h5><p>抽象工厂模式的使用就是上面这样，下面我们来将它与工厂方法模式做个对比</p><table><thead><tr><th>工厂方法模式</th><th>抽象工厂模式</th></tr></thead><tbody><tr><td>针对的是一个产品等级结构</td><td>针对的是多个产品等级结构</td></tr><tr><td>一个抽象产品类</td><td>多个抽象产品类</td></tr><tr><td>每个抽象产品类可以派生出多个具体产品类</td><td>每个抽象产品类可以派生出多个具体产品类</td></tr><tr><td>一个抽象工厂类，可以派生出多个具体工厂类</td><td>一个抽象工厂类，可以派生出多个具体工厂类</td></tr><tr><td>每个具体工厂类只能创建一个具体产品类的实例</td><td>每个具体工厂类可以创建多个具体产品类的实例</td></tr></tbody></table><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。 </p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式起篇</title>
      <link href="/2018/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E7%AF%87/"/>
      <url>/2018/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>今天挖坑，来讲讲我们23种设计模式，设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。虽然如此，但是滥用设计模式很可能会造成与自己预期相反的结果，所以我在起篇先给自己和大家提个醒，<strong>设计模式是经验总结，不是公理公式 ，要为实现需求而编码，而不是为使用设计模式而编码 ！</strong></p><h3 id="一、设计模式的六大原则"><a href="#一、设计模式的六大原则" class="headerlink" title="一、设计模式的六大原则"></a>一、设计模式的六大原则</h3><p>总原则：开闭原则，即对扩展开放，对修改关闭。 </p><h5 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h5><p>每个类应该实现单一的职责，否则应该把类拆分。 </p><h5 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2.里氏替换原则"></a>2.里氏替换原则</h5><p>任何基类可以出现的地方，子类一定可以出现。它是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 </p><h5 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h5><p>这是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。 </p><h5 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4.接口隔离原则"></a>4.接口隔离原则</h5><p>使用多个隔离的接口，比使用单个接口要好。每个接口不存在子类用不到却必须实现的方法，否则要将接口拆分。 </p><h5 id="5-迪米特法则（最少知道原则）"><a href="#5-迪米特法则（最少知道原则）" class="headerlink" title="5.迪米特法则（最少知道原则）"></a>5.迪米特法则（最少知道原则）</h5><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统的功能模块相对独立。 </p><h5 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6.合成复用原则"></a>6.合成复用原则</h5><p>尽量使用合成/聚合方式，而不是使用继承。</p><h3 id="二、设计模式的三大类"><a href="#二、设计模式的三大类" class="headerlink" title="二、设计模式的三大类"></a>二、设计模式的三大类</h3><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>好了，起篇就先有这么多，下一篇开始正式讲我们的23种设计模式，以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p><p>参考文章：<a href="https://my.oschina.net/tiancai/blog/224624" target="_blank" rel="noopener">Java开发中的23种设计模式详解</a></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Servlet总结</title>
      <link href="/2018/08/03/Servlet/"/>
      <url>/2018/08/03/Servlet/</url>
      <content type="html"><![CDATA[<p>这几天忙着玩忙着睡都没有更博，不过也稍微计划了下大概要写些什么，具体就不说了，我不画大饼，没做到尴尬。。</p><p>写技术博客也不是想给谁看，就是个人总结和复习，也当做笔记，以后忘了什么知识点可以来看看，仅此而已。行了，废话也不说了，来说说我们的Servlet。</p><h3 id="一、什么是Servlet"><a href="#一、什么是Servlet" class="headerlink" title="一、什么是Servlet"></a>一、什么是Servlet</h3><p>Servlet是什么？”狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。“这是百度上说的，以我的理解，Servlet就是一个Java接口，是一套处理网络请求的规范 ，我们平时写的Servlet必须实现刚刚那个接口，按它的规范完成我们的编写，这样完成的Java类我们管它叫自己的Servlet。</p><p>好的，Servelt既然是一个接口，那具体是怎样的接口呢，下图详细地解释了Servlet体系与各自的方法。</p><img src="/2018/08/03/Servlet/servlet1.png"><p>每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是的init()，service()，destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet，它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet()方法，如为Post请求，则调用doPost()方法。所以我们在编写Servlet时，通常只需要覆写doGet()或doPost()方法。 </p><h3 id="二、Servlet生命周期"><a href="#二、Servlet生命周期" class="headerlink" title="二、Servlet生命周期"></a>二、Servlet生命周期</h3><p>说到Servlet不提它的生命周期显然是不行的，要掌握Servlet这个是重点，那么Servlet工作流程分为以下几个阶段：</p><h5 id="1-加载和实例化"><a href="#1-加载和实例化" class="headerlink" title="1.加载和实例化"></a>1.加载和实例化</h5><p>当检测到需要Servlet的第一个请求时，读取xml文件找到要加载的servlet类，创建Servlet实例。 加载一般是在运行Servlet容器时来完成，将servlet类加载到tomcat中，或者是客户端发来请求时也可以。</p><h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h5><p>初始化信息一般是读取配置信息、读取初始化参数等，对于每一个servlet实例，init()方法值被调用一次。</p><h5 id="3-请求处理"><a href="#3-请求处理" class="headerlink" title="3.请求处理"></a>3.请求处理</h5><p>调用Servlet的service()方法对请求进行处理，在调用该方法之前，init()方法必须先成功执行。根据请求的到来，service()方法决定请求的请求，常用的是doGet()或doPost()。</p><h5 id="4-销毁"><a href="#4-销毁" class="headerlink" title="4.销毁"></a>4.销毁</h5><p>销毁一般是Servlet的卸载是由容器本身定义和实现，在destroy()方法调用后，容器释放对应的Servlet请求。实例随后会被Java的垃圾收集器所回收，整个Servlet的生命周期结束。一般tomcat关闭，servlet就会被销毁。</p><p>Servlet没有main方法，所有行为由Servlet容器控制，我们最常见的Servlet容器就是Tomcat了。整个流程如下图：</p><img src="/2018/08/03/Servlet/servlet2.jpg"><p>（图来自《Head First Servlets &amp; JSP》，逸夫有，是本入门经典 ，推荐！ ）</p><h3 id="三、servlet配置及其含义"><a href="#三、servlet配置及其含义" class="headerlink" title="三、servlet配置及其含义"></a>三、servlet配置及其含义</h3><p>servlet配置在项目的web.xml下，这里其实最想说的是配置中各节点的含义： </p><pre><code>&lt;!-- 配置一个servlet --&gt;&lt;!-- servlet的配置 --&gt;&lt;servlet&gt;    &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!-- servlet的类全名： 包名+简单类名 --&gt;    &lt;servlet-class&gt;lm.practice.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt;    &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!-- servlet的映射路径（访问servlet的名称） --&gt;    &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p> 可以看到，在配置Servlet时，有两个地方需要配置，一个是&lt;servlet&gt;,另一个是&lt;servlet-Mapping&gt;，这两个一个是配置Servlet，一个是配置其映射信息，其中&lt;servlet&gt;中的&lt;servlet-name&gt;可以随意指定，但要有一定的意义，一般取为类的名称，例如我的类名为ServletDemo，这里取名为ServletDemo,下面的&lt;servlet-class&gt;是类的全路径 ，一定要是全路径！ </p><p>&lt;servlet-Mapping&gt;是映射信息，它也有一个&lt;servlet-name&gt;，里面的名字是对应的Servlet名，也就是我们上面配置的Servlet名字，这里是ServletDemo，下面的是映射路径，也就是访问Servlet的名称，这里也是以方便和有意义为前提的，是我们在访问Servlet在浏览器地址栏后面输入的那个信息。</p><p>注意：这里的映射路径一定不是丢掉/，否则就会出错了，一定要写成/servlet，不能是servlet。</p><p>行了，关于Servlet的知识点目前就想到这么多，其实还有九大内置对象，四个作用域什么的，大家想了解可以参考这个帖子，<a href="https://www.cnblogs.com/sunli0205/p/5896980.html" target="_blank" rel="noopener">了解一下</a>。以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/28/Hello%20World/"/>
      <url>/2018/07/28/Hello%20World/</url>
      <content type="html"><![CDATA[<p>搭建个人博客的想法一直都有，算起来断断续续也有一年了吧。</p><p>今天心血来潮说做就做了，想起来会很难，但实际做完了才知道其实也挺简单的。东拼西凑，如你所见，博客的雏形大概就出来了。也算完成一个小目标？</p><p>今天是18年7月28日，我的大二暑假快要过半了，而我现在还在整合ssm框架，争取在这个暑假结束时熟悉ssm项目的结构，建立流程以及Maven的使用，能顺便了解一下SpringCloud或者SpringBoot最好，这样我也不算虚度这一个多月。</p><p>很惭愧，还要继续完善这个博客，所以第一篇就写得简单了些，只想再努力些，再加油些，Hello World！</p>]]></content>
      
      <categories>
          
          <category> 个人日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
