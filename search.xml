<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java会话管理：Cookie和Session</title>
      <link href="/2018/08/07/Java%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9ACookie%E5%92%8CSession/"/>
      <url>/2018/08/07/Java%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%9ACookie%E5%92%8CSession/</url>
      <content type="html"><![CDATA[<p>http是<strong>无状态</strong>的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断他是否有权限继续这个请求。这个过程就是常说的会话管理。它也可以简单理解为一个用户从登录到退出应用的一段期间。 </p><p>具体解释一下这个“无状态”：</p><ol><li>协议对于事务处理没有记忆能力</li><li>对同一个url请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li><p>人生若只如初见</p><p>这有个具体的生活例子说明了无状态http的不便性：</p></li></ol><p>当我们在一个购物网站上登陆自己的帐号后，我们便开始浏览商品，这时我们发现了心仪的商品，点进去打算看商品详情，发现竟然又要我们登陆帐号，为什么？因为无状态http请求无法保存我们用户信息，点击商品是一个请求，刚刚进入网站主页也是一个请求，这两个请求没有上下文联系，服务器无法判断这是同一个用户的请求，所以我们不得不再输入我们的账号密码，点击添加购物车，这也是一个请求，我们还是得输入帐号密码，还有其它商品操作，还有结算按钮。。。</p><p>没有会话管理技术会给我们生活带来多大不便从上个例子就可以略知一二，Java中我们有Cookie和Session来帮助我们解决这个麻烦。</p><h3 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h3><h5 id="1-什么是Cookie"><a href="#1-什么是Cookie" class="headerlink" title="1.什么是Cookie"></a>1.什么是Cookie</h5><p>“Cookie是通过客户端保持状态的解决方案。从定义上来说，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从： [系统盘]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。 ”这是百度百科上关于Cookie的解释，说得很明了也很详细，下图是利用Cookie与服务器交流的简图：</p><p><img src="http://i1.bvimg.com/656545/4ff99375d4cc1098.png" alt="Markdown"></p><h5 id="2-Cookie的使用"><a href="#2-Cookie的使用" class="headerlink" title="2.Cookie的使用"></a>2.Cookie的使用</h5><p>如何使用Cookie？Java API关于Cookie提供了很多方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Cookie(String name, String value)</td><td>实例化<code>Cookie</code>对象，传入<code>Cookie</code>名称和<code>Cookie</code>的值</td></tr><tr><td>public String getName()</td><td>取得<code>Cookie</code>的名字</td></tr><tr><td>public String getValue()</td><td>取得<code>Cookie</code>的值</td></tr><tr><td>public void setValue(String newValue)</td><td>设置<code>Cookie</code>的值</td></tr><tr><td>public void setMaxAge(int expiry)</td><td>设置<code>Cookie</code>的最大保存时间，即<code>Cookie</code>的有效期</td></tr><tr><td>public int getMaxAge()</td><td>获取<code>Cookie</code>的有效期</td></tr><tr><td>public void setPath(String uri)</td><td>设置<code>Cookie</code>的有效路径</td></tr><tr><td>public String getPath()</td><td>获取<code>Cookie</code>的有效路径</td></tr><tr><td>public void setDomain(String pattern)</td><td>设置<code>Cookie</code>的有效域</td></tr><tr><td>public String getDomain()</td><td>获取<code>Cookie</code>的有效域</td></tr></tbody></table><p>已下是Cookie使用的一个例子，记录用户访问网站信息</p><pre><code>public class CookieServlet extends HttpServlet {    public void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        //设置服务器端以UTF-8编码进行输出        response.setCharacterEncoding(&quot;UTF-8&quot;);        //设置浏览器以UTF-8编码进行接收,解决中文乱码问题        response.setContentType(&quot;text/html;charset=UTF-8&quot;);        PrintWriter out = response.getWriter();        //获取浏览器访问访问服务器时传递过来的cookie数组        Cookie[] cookies = request.getCookies();        //如果用户是第一次访问，那么得到的cookies将是null        if (cookies!=null) {            out.write(&quot;您上次访问的时间是：&quot;);            for (int i = 0; i &lt; cookies.length; i++) {                Cookie cookie = cookies[i];                if (cookie.getName().equals(&quot;lastAccessTime&quot;)) {                    Long lastAccessTime =Long.parseLong(cookie.getValue());                    Date date = new Date(lastAccessTime);                    out.write(date.toLocaleString());                }            }        }else {            out.write(&quot;这是您第一次访问本站！&quot;);        }        //用户访问过之后重新设置用户的访问时间，存储到cookie中，然后发送到客户端浏览器        Cookie cookie = new Cookie(&quot;lastAccessTime&quot;, System.currentTimeMillis()+&quot;&quot;);//创建一个cookie，cookie的名字是lastAccessTime        //将cookie对象添加到response对象中，这样服务器在输出response对象中的内容时就会把cookie也输出到客户端浏览器        response.addCookie(cookie);    }    public void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException {        doGet(request, response);    }}</code></pre><h5 id="3-Cookie的安全性"><a href="#3-Cookie的安全性" class="headerlink" title="3.Cookie的安全性"></a>3.Cookie的安全性</h5><p>Cookie的目的是为用户带来方便，为网站带来增值，一般情况下不会造成严重的安全威胁。Cookie文件不能作为代码执行，也不会传送病毒，它为用户所专有并只能由创建它的服务器来读取。另外，浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为3KB，因此，Cookie不会塞满硬盘，更不会被用作”拒绝服务”攻击手段。</p><p>但是，Cookie作为用户身份的替代，其安全性有时决定了整个系统的安全性，Cookie的安全性问题不容忽视。</p><p>(1)Cookie欺骗</p><p>Cookie记录了用户的帐户ID、密码之类的信息，通常使用MD5方法加密后在网上传递。经过加密处理后的信息即使被网络上一些别有用心的人截获也看不懂。然而，现在存在的问题是，截获Cookie的人不需要知道这些字符串的含义，只要把别人的Cookie向服务器提交，并且能够通过验证，就可以冒充受害人的身份登陆网站，这种行为叫做Cookie欺骗。<br>非法用户通过Cookie欺骗获得相应的加密密钥，从而访问合法用户的所有个性化信息，包括用户的E-mail甚至帐户信息，对个人信息造成严重危害。<br>(2)Cookie截获<br>Cookie以纯文本的形式在浏览器和服务器之间传送，很容易被他人非法截获和利用。任何可以截获Web通信的人都可以读取Cookie。<br>Cookie被非法用户截获后，然后在其有效期内重放，则此非法用户将享有合法用户的权益。例如，对于在线阅读，非法用户可以不支付费用即可享受在线阅读电子杂志。</p><h3 id="二、Session"><a href="#二、Session" class="headerlink" title="二、Session"></a>二、Session</h3><h5 id="1-什么是Session"><a href="#1-什么是Session" class="headerlink" title="1.什么是Session"></a>1.什么是Session</h5><p>Session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个Session的时候，服务器首先检查这个客户端的请求里是否已包含了一个Session标识，称为SessionId，如果已包含一个SessionId则说明以前已经为此客户端创建过Session，服务器就按照SessionId把这个Session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含SessionId，则为此客户端创建一个Session并且生成一个与此Session相关联的SessionId，SessionId的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个SessionId将被在本次响应中返回给客户端保存。 保存这个SessionId的方式可以采用Cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器。 </p><h5 id="2-Session的使用"><a href="#2-Session的使用" class="headerlink" title="2.Session的使用"></a>2.Session的使用</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String getId()</td><td>获取<code>SessionID</code>值</td></tr><tr><td>public void setAttribute()</td><td>设置属性</td></tr><tr><td>public Object getAttribute()</td><td>获取属性</td></tr><tr><td>public void removeAttribute()</td><td>移除属性</td></tr><tr><td>public []String getAllAttributeNames()</td><td>获取所有的属性名</td></tr><tr><td>public int getMaxInactiveInterval()</td><td>获取最长到期时间</td></tr><tr><td>public void setMaxInactiveInterval()</td><td>设置最长到期事件</td></tr><tr><td>public void  invalidate()</td><td>使该<code>Session</code>对象失效</td></tr><tr><td>public long getCreationTime()</td><td>获取创建时间</td></tr><tr><td>public long getLastAccessedTime()</td><td>获取上次访问时间</td></tr></tbody></table><p>已下是Session使用的一个例子</p><pre><code>//使用Session保存数据public class Demo01 extends HttpServlet {        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            response.setContentType(&quot;text/html;charset=UTF-8&quot;);            request.setCharacterEncoding(&quot;UTF-8&quot;);            // 获取参数            String username = request.getParameter(&quot;username&quot;);            // 获取session对象            HttpSession session = request.getSession();            // 保存数据            session.setAttribute(&quot;username&quot;, username);            // 打印SessionID            System.out.println(session.getId());        }        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            doGet(request, response);        }}//测试获取Session域中的数据public class Demo02 extends HttpServlet {        public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            response.setContentType(&quot;text/html;charset=UTF-8&quot;);            request.setCharacterEncoding(&quot;UTF-8&quot;);            HttpSession session = request.getSession();            String username = (String)session.getAttribute(&quot;username&quot;);            // 响应到网页上            response.getWriter().write(username + &quot; &quot; + session.getId());        }        public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {            doGet(request, response);        }}</code></pre><h3 id="三、Cookie和Session的区别"><a href="#三、Cookie和Session的区别" class="headerlink" title="三、Cookie和Session的区别"></a>三、Cookie和Session的区别</h3><p>1.Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie是把用户的数据写在用户本地浏览器上, 其他网站也可以扫描使用你的Cookie，容易泄露自己网站用户的隐私，而且一般浏览器对单个网站站点有Cookie数量与大小的限制，Cookie也是实现Session的一种方式。 </p><p>2.Session 的运行依赖SessionId，而SessionId 是存在Cookie中的，也就是说，如果浏览器禁用了Cookie ，同时 Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 SessionId） 。</p><p>3.一般情况，登录信息等重要信息存储在Session中，其他信息存储在Cookie中 。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂方法模式&amp;抽象工厂模式</title>
      <link href="/2018/08/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F&amp;%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/08/05/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F&amp;%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>先介绍工厂方法模式和抽象工厂模式，这是23种设计模式的其中两种。不过在此之前我想先说说简单工厂模式，它不属于23种设计模式，却是今天要说的两种设计模式的入门。</p><h3 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h3><p>我们刚开始写代码的时候，如果需要一个类的对象，我们习惯利用关键字new把它直接创建出来，其实这并不是一个好习惯，因为这样不得已把对象的创建和使用绑定在一起，造成对象类和客户端代码非常高的耦合度，这无疑是我们不想看到的结果，那应该怎么办？简单工厂模式在一定程度上能解决这个问题。</p><p>简单工厂模式是<strong>由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。 </p><p>上面是定义，现在看不懂没关系，下面我来举例。市面上手机有各种各样的品牌，华为，小米，oppo等，不同场景下我们需要的手机品牌不同，那我们要怎么定义这个手机类？有些人可能觉得直接根据品牌定义类就好，华为一个类小米一个类这样，但仔细思考后会发现这样并不可取，因为手机品牌虽然不同，但很多功能都是类似的，重复的代码尽量不要写，这也是我们编码的原则之一，比较好的方法是定义一个抽象的手机类，如下</p><pre><code>abstract class Phone {    //所有手机都有的功能，这里我举打电话这个例子    public void call() {        //具体实现省略    }    //不同品牌手机不同的功能    public abstract void method();}</code></pre><p>然后在根据具体手机品牌定义各自的类</p><pre><code>//华为class HUAWEI extends Phone {    public void method() {    //具体实现    }}//小米class XiaoMi extends Phone {    public void method() {    //具体实现    }}...</code></pre><p>这样定义结束后，如果我们需要使用不同品牌的手机对象，根据简单工厂模式我们还需要定义一个工厂类</p><pre><code>class Factory {    //静态工厂方法，返回不同手机品牌对象    public static Phone getPhone(String type) {        Phone phone = null;        if(type.equals(&quot;HUAWEI&quot;)) {            phone = new HUAWEI();        } else if(type.equals(&quot;XiaoMi&quot;)) {            phone = new XiaoMi();        } else {            //...        }        return phone;    }}</code></pre><p>有了这个工厂类我们创建对象就方便了，以下是客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        Phone myPhone1 = Factory.getPhone(&quot;XiaoMi&quot;);        Phone myPhone2 = Factory.getPhone(&quot;HUAWEI&quot;);    }}</code></pre><p>这就是简单工厂模式的常用场景，你发现没，利用简单工厂模式我们很自然地将对象的创建与使用分开（创建交给工厂类，使用在客户端代码中），看完这个例子再看它的定义，会清楚很多，如果你理解了，那恭喜你可以继续学习工厂方法模式了，如果还是不懂的话不建议继续往下看，请多看相关的其他文章。</p><h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p>简单工厂模式固然简单，但是也有问题，如果我们需要一个手机品牌（例如三星），而工厂类中没有相应的创建代码怎么办？我们就不得不修改我们的工厂类，但是这样就违背了我们的开闭原则，如何在新增手机品牌的情况下而不修改源代码？这时候工厂方法模式就出现了。</p><p>工厂方法模式在简单工厂模式上做出了改进，意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 </p><p>按照上面说的我们只要将Factory类做些改动，把它变成一个接口</p><pre><code>interface Factory {    public Phone getPhone();}</code></pre><p>然后根据不同手机品牌编写对应的品牌工厂类</p><pre><code>//小米class XiaoMiFactory implements Factory {    public Phone getPhone() {        return new XiaoMi();    }}//三星class SAMSUNGFactory implements Factory {    public Phone getPhone() {        return new SAMSUNG();    }}...</code></pre><p>把工厂类改写成接口，将实际创建工作推迟到子类当中，这样我们需要什么手机品牌的对象，写个品牌工厂实现工厂类接口就行了，不就解决了新手机品牌的问题。不得不说早期提出设计模式的大牛们是多厉害，仰望一下。好了，下面是使用工厂方法模式后的客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        Factory factory = null;        factory = new SAMSUNGFactory();        Phone myPhone = factory.getPhone();    }}</code></pre><h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p>接着我们上面的例子，手机有各式的品牌，然而每个手机品牌也不止只生产手机，比如小米还有充电宝，空气净化器等等，如果都为它们创建工厂类可能会导致系统中存在大量工厂类，这样势必会产生系统开销，此时我们的抽象工厂模式运营而生。</p><h5 id="1-产品等级结构与产品族"><a href="#1-产品等级结构与产品族" class="headerlink" title="1.产品等级结构与产品族"></a>1.产品等级结构与产品族</h5><p>要理解抽象工厂模式，我们就要先来学习一下产品等级结构与产品族是什么。</p><p><img src="http://i4.bvimg.com/656545/c18d26d84d16b2bc.jpg" alt="Markdown"></p><p>上图是产品族与产品等级结构示意图，产品等级结构是产品的继承结构，如我们的抽象类Phone，其子类有XiaoMi，HUAWEI，SAMSUNG，则Phone与XiaoMi,HUAWEI,SAMSUNG之间构成了一个产品等级结构。产品族是指由同一个工厂生产的，位于不同产品等级结构的同一组产品，如小米的手机，充电宝，空气净化器，它们各自属于不同的产品等级结构，因此它们属于一个产品族，即小米。</p><h5 id="2-抽象工厂模式举例"><a href="#2-抽象工厂模式举例" class="headerlink" title="2.抽象工厂模式举例"></a>2.抽象工厂模式举例</h5><p>如果利用工厂方法模式为小米华为的手机，充电宝和空气净化器都创建对象，一共需要6个工厂类，而抽象工厂模式简单许多，我们先为产品族新建一个抽象类（接口也行）</p><pre><code>abstract class AbstractFactory {    //为一个产品族创建不同产品等级结构的方法    public abstract Phone getPhone();    public abstract PowerBank getPowerBank();    public abstract AirPurifier getAirPurifier();}</code></pre><p>对于每个品牌，其代码如下</p><pre><code>//小米class XiaoMiFactory extends AbstractFactory {    public abstract Phone getPhone() {        return new XiaoMi();    }    public abstract PowerBank getPowerBank() {        return new XiaoMiPowerBank();    }    public abstract AirPurifier getAirPurifier() {        return new XiaoMiAirPurifier();    }}//华为class HUAWEIFactory extends AbstractFactory {    public abstract Phone getPhone() {        return new HUAWEI();    }    public abstract PowerBank getPowerBank() {        return new HUAWEIPowerBank();    }    public abstract AirPurifier getAirPurifier() {        return new HUAWEIAirPurifier();    }}</code></pre><p>做到这样就可以了，两个产品族我们只要两个具体工厂类，一个抽象工厂类，是不是比工厂方法模式简单？下面是客户端代码</p><pre><code>class Client {    public static void main(String[] args) {        AbstractFactory factory = null;        factory = new XiaoMiFactory();        Phone myPhone = factory.getPhone();        PowerBank myPower = factory.getPowerBank();    }}</code></pre><h5 id="3-与工厂方法模式的对比"><a href="#3-与工厂方法模式的对比" class="headerlink" title="3.与工厂方法模式的对比"></a>3.与工厂方法模式的对比</h5><p>抽象工厂模式的使用就是上面这样，下面我们来将它与工厂方法模式做个对比</p><table><thead><tr><th>工厂方法模式</th><th>抽象工厂模式</th></tr></thead><tbody><tr><td>针对的是一个产品等级结构</td><td>针对的是多个产品等级结构</td></tr><tr><td>一个抽象产品类</td><td>多个抽象产品类</td></tr><tr><td>每个抽象产品类可以派生出多个具体产品类</td><td>每个抽象产品类可以派生出多个具体产品类</td></tr><tr><td>一个抽象工厂类，可以派生出多个具体工厂类</td><td>一个抽象工厂类，可以派生出多个具体工厂类</td></tr><tr><td>每个具体工厂类只能创建一个具体产品类的实例</td><td>每个具体工厂类可以创建多个具体产品类的实例</td></tr></tbody></table><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。 </p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式起篇</title>
      <link href="/2018/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E7%AF%87/"/>
      <url>/2018/08/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B5%B7%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>今天挖坑，来讲讲我们23种设计模式，设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。虽然如此，但是滥用设计模式很可能会造成与自己预期相反的结果，所以我在起篇先给自己和大家提个醒，<strong>设计模式是经验总结，不是公理公式 ，要为实现需求而编码，而不是为使用设计模式而编码 ！</strong></p><h3 id="一、设计模式的六大原则"><a href="#一、设计模式的六大原则" class="headerlink" title="一、设计模式的六大原则"></a>一、设计模式的六大原则</h3><p>总原则：开闭原则，即对扩展开放，对修改关闭。 </p><h5 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h5><p>每个类应该实现单一的职责，否则应该把类拆分。 </p><h5 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2.里氏替换原则"></a>2.里氏替换原则</h5><p>任何基类可以出现的地方，子类一定可以出现。它是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。 </p><h5 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h5><p>这是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。 </p><h5 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4.接口隔离原则"></a>4.接口隔离原则</h5><p>使用多个隔离的接口，比使用单个接口要好。每个接口不存在子类用不到却必须实现的方法，否则要将接口拆分。 </p><h5 id="5-迪米特法则（最少知道原则）"><a href="#5-迪米特法则（最少知道原则）" class="headerlink" title="5.迪米特法则（最少知道原则）"></a>5.迪米特法则（最少知道原则）</h5><p>一个实体应当尽量少的与其他实体之间发生相互作用，使得系统的功能模块相对独立。 </p><h5 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6.合成复用原则"></a>6.合成复用原则</h5><p>尽量使用合成/聚合方式，而不是使用继承。</p><h3 id="二、设计模式的三大类"><a href="#二、设计模式的三大类" class="headerlink" title="二、设计模式的三大类"></a>二、设计模式的三大类</h3><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>好了，起篇就先有这么多，下一篇开始正式讲我们的23种设计模式，以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p><p>参考文章：<a href="https://my.oschina.net/tiancai/blog/224624" target="_blank" rel="noopener">Java开发中的23种设计模式详解</a></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Servlet总结</title>
      <link href="/2018/08/03/Servlet/"/>
      <url>/2018/08/03/Servlet/</url>
      <content type="html"><![CDATA[<p>这几天忙着玩忙着睡都没有更博，不过也稍微计划了下大概要写些什么，具体就不说了，我不画大饼，没做到尴尬。。</p><p>写技术博客也不是想给谁看，就是个人总结和复习，也当做笔记，以后忘了什么知识点可以来看看，仅此而已。行了，废话也不说了，来说说我们的Servlet。</p><h3 id="一、什么是Servlet"><a href="#一、什么是Servlet" class="headerlink" title="一、什么是Servlet"></a>一、什么是Servlet</h3><p>Servlet是什么？”狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。“这是百度上说的，以我的理解，Servlet就是一个Java接口，是一套处理网络请求的规范 ，我们平时写的Servlet必须实现刚刚那个接口，按它的规范完成我们的编写，这样完成的Java类我们管它叫自己的Servlet。</p><p>好的，Servelt既然是一个接口，那具体是怎样的接口呢，下图详细地解释了Servlet体系与各自的方法。</p><p><img src="http://i2.bvimg.com/656545/782108effef7a4f8.png" alt="Markdown"></p><p>每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是的init()，service()，destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet，它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet()方法，如为Post请求，则调用doPost()方法。所以我们在编写Servlet时，通常只需要覆写doGet()或doPost()方法。 </p><h3 id="二、Servlet生命周期"><a href="#二、Servlet生命周期" class="headerlink" title="二、Servlet生命周期"></a>二、Servlet生命周期</h3><p>说到Servlet不提它的生命周期显然是不行的，要掌握Servlet这个是重点，那么Servlet工作流程分为以下几个阶段：</p><h5 id="1-加载和实例化"><a href="#1-加载和实例化" class="headerlink" title="1.加载和实例化"></a>1.加载和实例化</h5><p>当检测到需要Servlet的第一个请求时，读取xml文件找到要加载的servlet类，创建Servlet实例。 加载一般是在运行Servlet容器时来完成，将servlet类加载到tomcat中，或者是客户端发来请求时也可以。</p><h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h5><p>初始化信息一般是读取配置信息、读取初始化参数等，对于每一个servlet实例，init()方法值被调用一次。</p><h5 id="3-请求处理"><a href="#3-请求处理" class="headerlink" title="3.请求处理"></a>3.请求处理</h5><p>调用Servlet的service()方法对请求进行处理，在调用该方法之前，init()方法必须先成功执行。根据请求的到来，service()方法决定请求的请求，常用的是doGet()或doPost()。</p><h5 id="4-销毁"><a href="#4-销毁" class="headerlink" title="4.销毁"></a>4.销毁</h5><p>销毁一般是Servlet的卸载是由容器本身定义和实现，在destroy()方法调用后，容器释放对应的Servlet请求。实例随后会被Java的垃圾收集器所回收，整个Servlet的生命周期结束。一般tomcat关闭，servlet就会被销毁。</p><p>Servlet没有main方法，所有行为由Servlet容器控制，我们最常见的Servlet容器就是Tomcat了。整个流程如下图：<img src="http://i4.bvimg.com/656545/b5d4a154ef91eca4.jpg" alt="Markdown"></p><p>（图来自《Head First Servlets &amp; JSP》，逸夫有，是本入门经典 ，推荐！ ）</p><h3 id="三、servlet配置及其含义"><a href="#三、servlet配置及其含义" class="headerlink" title="三、servlet配置及其含义"></a>三、servlet配置及其含义</h3><p>servlet配置在项目的web.xml下，这里其实最想说的是配置中各节点的含义： </p><pre><code>&lt;!-- 配置一个servlet --&gt;&lt;!-- servlet的配置 --&gt;&lt;servlet&gt;    &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!-- servlet的类全名： 包名+简单类名 --&gt;    &lt;servlet-class&gt;lm.practice.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt;    &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt;    &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt;    &lt;!-- servlet的映射路径（访问servlet的名称） --&gt;    &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;</code></pre><p> 可以看到，在配置Servlet时，有两个地方需要配置，一个是&lt;servlet&gt;,另一个是&lt;servlet-Mapping&gt;，这两个一个是配置Servlet，一个是配置其映射信息，其中&lt;servlet&gt;中的&lt;servlet-name&gt;可以随意指定，但要有一定的意义，一般取为类的名称，例如我的类名为ServletDemo，这里取名为ServletDemo,下面的&lt;servlet-class&gt;是类的全路径 ，一定要是全路径！ </p><p>&lt;servlet-Mapping&gt;是映射信息，它也有一个&lt;servlet-name&gt;，里面的名字是对应的Servlet名，也就是我们上面配置的Servlet名字，这里是ServletDemo，下面的是映射路径，也就是访问Servlet的名称，这里也是以方便和有意义为前提的，是我们在访问Servlet在浏览器地址栏后面输入的那个信息。</p><p>注意：这里的映射路径一定不是丢掉/，否则就会出错了，一定要写成/servlet，不能是servlet。</p><p>行了，关于Servlet的知识点目前就想到这么多，其实还有九大内置对象，四个作用域什么的，大家想了解可以参考这个帖子，<a href="https://www.cnblogs.com/sunli0205/p/5896980.html" target="_blank" rel="noopener">了解一下</a>。以后如果想到什么重要的还会添加的，如果有什么疑惑或者错误欢迎联系我。</p>]]></content>
      
      <categories>
          
          <category> JavaEE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/07/28/Hello%20World/"/>
      <url>/2018/07/28/Hello%20World/</url>
      <content type="html"><![CDATA[<p>搭建个人博客的想法一直都有，算起来断断续续也有一年了吧。</p><p>今天心血来潮说做就做了，想起来会很难，但实际做完了才知道其实也挺简单的。东拼西凑，如你所见，博客的雏形大概就出来了。也算完成一个小目标？</p><p>今天是18年7月28日，我的大二暑假快要过半了，而我现在还在整合ssm框架，争取在这个暑假结束时熟悉ssm项目的结构，建立流程以及Maven的使用，能顺便了解一下SpringCloud或者SpringBoot最好，这样我也不算虚度这一个多月。</p><p>很惭愧，还要继续完善这个博客，所以第一篇就写得简单了些，只想再努力些，再加油些，Hello World！</p>]]></content>
      
      <categories>
          
          <category> 个人日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
